

<script>

    /**
     * Series creation for track:
     * - provide an option for swapping lanes (two atheltes change their lanes.) With draggable this can be done as shown here:https://stackoverflow.com/questions/63433028/vue-draggable-how-to-only-replace-item-chosen-to-prevent-shifting-all-other-it
     * - provide the possibility that pressing Ctrl and or Shift change the behavior between "insert element and automatically move all others" (draggable default), "swap lanes" and "add to same lane"
     **/


    // connect to the room (defined by te ID in the URL/http-GET-param)
    class vuContestTech extends roomClientVue{
        constructor(vue, meetingShortname, xContest){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super(`contests/${xContest}@${meetingShortname}`, true, true, '/static/rContestTechHighClient.js', 'rContestTechHighClient', '')

            // needed to call things in the vue class
            this.vue = vue;
        }

        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            this.vue.readOnly = this.room.writingTicketID==false;
        }

        onChange(){
            //this.vue.$forceUpdate();
            this.vue.sortHeightsAddOrder();

            // show the correct time; additionally, we have to start the interval for updating the time, if the timer was started on the server and is not started yet here
            let timeRunning = this.vue.updateShownTime();
            if (timeRunning && this.vue.timeUpdateInterval===undefined && this.vue.selectedXSeries && this.room.data.auxData[this.vue.selectedXSeries].periodStartTime){
                // start the timer
                this.vue.timeUpdateInterval = setInterval(this.vue.updateShownTime, 100);
            }
            

            // Do NOT call calculateNextAthlete when: 
            // - the client is writing, then the necessary changes were already applied
            // - the client is reading only and the positionsNext did not change
            let positionNextChanged = false;
            if (this.vue.selectedXSeries){
                if (JSON.stringify(this.vue.positionNext) != JSON.stringify(this.room.data.auxData[this.vue.selectedXSeries].positionNext)){
                    positionNextChanged = true;
                }
            }
            if (this.room.writingTicketID || positionNextChanged==false){
                this.vue.calculateTemporaryRankingData();
            } else {
                this.vue.calculateNextAthlete();
            }

            // manually transfer some of the aux properties (position and positionNext are transferred in calculateNextAthlete):
            this.vue.transferAuxData()


            // some computed properties such as resultGridTemplate are not updated when its content changes (e.g. xHeight changed from negative values to the true value); thus we need this stupid fake property
            this.vue.fakeProperty++;

        }

        setProps(){
            // set the changed data-property as data of the vue-instance
            this.vue.contest = this.room.data.contest;
            this.vue.series = this.room.data.series;
            this.vue.startgroups = this.room.data.startgroups;
            this.vue.relatedGroups = this.room.data.relatedGroups;
            this.vue.disciplines = this.room.data.disciplines;
            this.vue.meeting = this.room.data.meeting;
            this.vue.categories = this.room.data.categories;
            this.vue.roomAuxData = this.room.data.auxData;
            
            
            // this.vue.baseDisciplines = this.room.data.disciplines;
            // this.vue.categories = this.room.data.categories;

            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            this.room.data.contest = this.vue.contest;
            this.room.data.startgroups = this.vue.startgroups;
            this.room.data.series = this.vue.series;
            this.room.data.relatedGroups = this.vue.relatedGroups;
            this.room.data.disciplines = this.vue.disciplines;
            this.room.data.auxData = this.vue.roomAuxData;
            // no backtransfer of meeting and categories required
        }
        
        afterFullreload(){

            // first, calculate the time offset of the browser's time and the time on the server
            // the offset is defiend as serverTime - timeHere; i.e. the value is positive, when the time here is lower than on the server.
            this.vue.timeOffset = new Date(this.room.data.serverTime) - new Date();

            // 
            this.setProps()

            // also update the writing status
            this.onWritingTicketChange();

            
            this.vue.createAllHeights();
            this.vue.evaluateHeightDeletable();
            this.vue.sortSeries();
            this.vue.sortHeightsAddOrder();
            let timeRunning = this.vue.updateShownTime();
            if (timeRunning && this.vue.timeUpdateInterval===undefined && this.vue.selectedXSeries && this.room.data.auxData[this.vue.selectedXSeries].periodStartTime){
                // start the timer
                this.vue.timeUpdateInterval = setInterval(this.vue.updateShownTime, 100);
            }
            
            this.vue.calculateNextAthlete(); // if this was not here, the broswer would not set the correct mode, e.g. not realize that the startHeights are ready and the competition can start

        }
        
        dataArrived(){

            this.setProps();

            // get the selected series from the GET parameter
            let u = new URL(window.location.href);
            if (u.searchParams.has('xSeries')){
                let xSeries = Number(u.searchParams.get('xSeries'))

                // get the index of the respective series
                let ind = this.vue.series.findIndex(s=>s.xSeries==xSeries);
                if (ind>=0){
                    this.vue.selectedSeries = ind;
                }
            }
            
            // also update the writing status
            this.onWritingTicketChange();
            
            this.vue.createAllHeights();
            this.vue.evaluateHeightDeletable();
            this.vue.sortSeries();
            this.vue.sortHeightsAddOrder();
            
            this.vue.calculateNextAthlete(); // if this was not here, the broswer would not set the correct mode, e.g. not realize that the startHeights are ready and the competition can start

        }

    }

    var rCTech;
    var vueSeriesAdminTech; 

    function startSeriesAdminTech(){

        /**
         * IMPORTANT NOTE: 
         * 1.) this room shall also work offline, i.e. all changes are written to a stack on the client which will be synchronized as soon as possible. However, this also needs that the changes are directly applied on the client, instead of applying them not before the answer of the server in "online-only" pages.
         * 2) If a change cannot be processed on the server, it has to be reverted on the client! This makes it necessary that the addToStack function is called with everything needed to perform a rollback of the change. This basically needs that the init-function in the room gets the new and old data. 
         * 3) Unfortunately, basic html events such as "onchange" do not provide the old and new value, but only the new. The best function we can use instead is a vue-watcher on the property. However, this has the problem that it is not only called when a change is done through the veu-app, but also if the data is changed from the room (because both raise the Proxy...). If we simply would watch for data changes and always send a change request to the server on change, we might end in an infinite loop, where client A changes something, B gets the change and modifies its data, the B's vue-watcher is raised, send the change to the server, client A gets it and there the watcher is raised again and so on...
         * 4) To ommit this problem, the best solution I have found is to have a special proeprty (here: propagateChange), which is set to true in an onchange event, hopefully raised before the watcher, and only if this is set to true, the change is sent to the server. The property then of course must be reset instantly.
         **/

        // TODO: eventually move this into vue

        let vueAppConfig = {
            data(){
                return {

                    developMode:false,
                    showContestInfo: false,

                    // the data is split into three parts, to be able to reuse the seriesAdmin parts
                    // TODO: also split computed properties, watchers and methods!

                    /* !!! data for SERIES CREATION and COMPETITION !!! */
                    categories:[],
                    meeting:{},     // informational only
                    disciplines:[], // informational only, to be able to show the name of the discipline and get some conf-data about the discipline, such as the max-reasonable height used to create the limit until where the heights shall be created
                    // TODO

                    //activateLate: false, // thing that cannot be drawn at startup, e.g. because they rely 
                    readOnly: false, // whether we can do changes or not (have a writingTicket or not)
                    
                    // info overlay
                    infoTitle: '',
                    infoContent:'',
                    infoVisible:false,

                    contest:{ // to be overridden as soon as the room-data arrives
                        status: 10,
                    },
                    startgroups: [],
                    relatedGroups: [],
                    // IMPORTANT: the contest data must be equivalent to the data in techHigh (which should be the case since this was based on the database structure)

                    // the names and id's of series and contest states:
                    // Note: the comment before the ejs-include only affects the first row of the included file; (thats why it still works)
                    // also gets seriesStates and participationStates
                    //<%- include('contestStates.ejs') %>

                    numSeries:0,
                    //unassignedAthletes:[100,101, 102, 103],
                    unassignedAthletesCreate:[], // the array is manually populated when the initial series assignment is shown

                    series:[],
                    seriesObj:[], //{1:[15,16], 2:[17,18]},

                    overlay: undefined, // either undefined or 'createSeries' or 'config'
                    overlay2: undefined, // createSeries or undefined
                    // there will be no waiting page, but a limit to one client and this will be the first offline working page.

                    /* !!! data for SERIES CREATION ONLY !!! */

                    propagateChange: false, // if the most recent change on the data (registered and monitored via "watchers") must be propagated to the server or not. (Not is typically the case when the changes comes from the server or any other change on the data done in the room but not in the data)

                    updateHeightIncrease: -1, // show change-line for height increases
                    heightIncreaseBeforeUpdate: {}, // resetting to previous values on height increase change
                    confForMod: {}, // the conf-object that is modified during conf changes. Recreated everytime conf-change is opened. At the end, the changes are either stored back to to the JSON in contest.conf (which then is applied to the computed property conf) or we just do nothing. 
                    newHeightIncreaseStart: undefined,
                    newInterval: undefined,

                    // series assignments (the different strategies that can be applied)
                    seriesAssignments: [
                    //includes<% seriesAssignments.forEach((SA)=>{ %>
                        // next include:<%- include(SA, {type:"js"}) %>,
                    //<% }); %>
                    ],
                    seriesAssignmentConfiguration:{}, // object will be populated by init functions of the respective functions
                    selectedSeriesAssignment: 0, // by default choose the first series assignment strategy

                    filterAthletes:'',
                    showFullDetails: false, // TODO: true for debugging only

                    /* !!! data for COMPETITION only !!! */
                    
                    xHeightTemp: -1, // temporary xHeight, until the height could be written to the DB and we get the actual index, we use this. Auto-increment into negative. When the correct key arrives, we must not only change the key in xHeight, but also in every result!  
                    xResultTemp: -1, // temporary xResult (needed for identical element id's; it is not referenced somewhere)
                    updateHeightIncrease: -1, // show change-line for height increases
                    heightIncreaseBeforeUpdate: {}, // resetting to previous values on height increase change

                    selectedSeries: 0, // which series we are working on. 
                    allHeights:[], // contains all already fixed and all predicted heights
                    mode: 0, // 0: before all startHeights are set, 1=competition running (or is ready to be started), 2=jumpoff, 3=finished
                    currentHeight: -1,  // in cm
                    currentJumpoffHeightInd: -1, // during jumpoff, store here the current index in the jumpoff order
                    jumpoffHeightRequired: false, // true if a new height should be defined by the user
                    bestAtEachJumpoffHeight: [],
                    manualJumpoffHeight:0, // used to set the default next jumpoff height, before we actually see the input element
                    position:[], // array with the xStartgroup of all athletes starting on the current height, defining the order in the copetition; changed by the drag and drop part; in the jumpoff, it contains all athletes that still participate in the jumpoff, independent whether they aready jumped on the current height
                    positionNext: [], // the first element contains the index in the position array of the first athlete to come, the second element the second, and so on; during the main competition, positionNext has the same length as position; in the jumpoff, it can be smaller, since it only contains the athletes that will still jump on the current jumpoff-height, while position also contains the athletes that already jumped on the current height
                    tempRankingData: { // all data needed for ranking and for gettign the current athlete
                        //xSeriesStart
                        /*12:{
                            totalFailedAttempts: 0, // until and with the last valid hight
                            failedAttemptsSinceLastValid: 0, // after 3, the person is out of the competition. 
                            failedAttemptsOnLastValid: 0,
                            lastValidHeight: 0,
                            nextJumpingHeight: 0, // is this really needed? lastValidHeight should be enough..?
                            rank: 0, // (temporary, ) locally calculated rank. 
                        },
                        13:{

                        }*/
                    },
                    maxLastValidHeight: 0, // store which was the heighest, last valid height; required in the jumpoff
                    attempt: 0, // in normal mode==1: 1 to 3; in jumpoff used to announce the i-th jumpoff height
                    attemptNext: 0, // 1 to 3; for the next athlete (not the current). It is easier to store this value than to (re)calculate it for drawing.
                    
                    currentResultChange: {}, // the result that we are currently changing in the results view 1
                    currentResultString:'',
                    currentResultStringCopy:'',
                    resultKeyPressed: -1, // the key that was pressed last inside a addResult-input. If this is the esc-key, the blur event will not be evaluated. 
                    sortValue1: 1,
                    sortValue2: 2, // default by rank
                    fakeProperty:0, // just needed to make sure that the sortedStart's are updated when the ranks change. (Start Vue's updating process)
                    temporaryDeactivation: false, // just to deactivate parts of the html form being rendered temporarily
                    timeOffset: 0,
                    roomAuxData:{
                        // uses xSeries to reference objects storing the following information:
                        // positionNext:[],
                        // position:[],
                        // attemptPeriod: 60, // s
                        // periodStartTime: undefined, // date-string of the server time when the attempt period started
                        // showAttemptPeriod: false,
                        // currentHeight
                        // currentJumpoffHeightInd
                        // attempt
                        // attemptNext 
                    },
                    autoAdvance: false,
                    attemptTime: "1:00", // TODO: aventually as time instead of string
                    attemptTimeSetting: "00:30",
                    shownTime: "0:00", // shall be string
                    timeUpdateInterval: undefined,
                    last15: false, // last 15 s
                    //currentResultRegistered: false,
                }
            },
            methods:{

                /* !!! methods for both SERIES creation and COMPETITION !!! */

                selectedSeriesChanged(){

                    let u = new URL(window.location.href)
                    u.searchParams.set('xSeries', this.series[this.selectedSeries].xSeries);
                    // this would reload the page
                    // window.location.href = u.href;
                    // this way only the path in the tab should be changed without any reload. 
                    window.history.replaceState(window.history.state, "", u.href)
                    
                },

                /**
                 * returns the index and the object itself of the first object where the property prop is equal to value 
                 * @param {array of objects} arr 
                 * @param {string} prop 
                 * @param {*} val 
                 * @return {array} [index, the object]
                 */
                findObjInArrayByProp(arr, prop, val){
                    for (let i=0; i<arr.length;i++){
                        if (arr[i][prop] == val){
                            return [i, arr[i]];
                        }
                    }
                    return [-1, {}];
                },
                autoManageAuxData(autoSaveToServer=true){
                    // based on the available series, automatically create (with default values) and delete the auxData per series.
                    // returns true if something has changed

                    let changed = false;

                    // first make sure, that all currently available auxData have their respective series
                    for (let xSeries in this.roomAuxData){
                        let series = this.series.find(s=>s.xSeries==xSeries);
                        if (!series){
                            delete this.roomAuxData[xSeries];
                            changed=true;
                        }
                    }

                    // then check that all available series have also an entry in auxData
                    for (let series of this.series){
                        if (!(series.xSeries in this.roomAuxData)){
                            this.roomAuxData[series.xSeries] = {
                                positionNext:[],
                                position:[],
                                attemptPeriod: 60, // s; mainly related to the next athlete
                                periodStartTime: null, // date-string of the server time when the attempt period started
                                showAttemptPeriod: false, 
                                currentHeight: -1,
                                currentJumpoffHeightInd: -1,
                                attempt: 0,
                                attemptNext: 0,
                            };
                            changed = true;
                        }
                    }

                    if (changed && autoSaveToServer){
                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                    return changed;

                },
                overlayInfo(title, content){
                    this.infoTitle = title;
                    this.infoContent = content;
                    this.infoVisible = true;
                },
                startUpdatingHeightIncrease(heightIncreaseIndex){
                    this.updateHeightIncrease = heightIncreaseIndex;
                    this.heightIncreaseBeforeUpdate = JSON.parse(JSON.stringify(this.confForMod.heightIncreases[heightIncreaseIndex]));
                },
                deleteHeightIncrease(index){
                    this.confForMod.heightIncreases.splice(index,1);
                    //this.createAllHeights();
                },
                saveUpdateHeightIncrease(){
                    this.updateHeightIncrease = -1;
                    this.sortHeightIncrease();
                    //this.createAllHeights();
                },
                abortUpdateHeightIncrease(index){
                    this.confForMod.heightIncreases[index] = this.heightIncreaseBeforeUpdate; // TODO: change this! It does not work, as it will remove the observers! TODO: check if this is still the case in Vue3!
                    this.updateHeightIncrease = -1;
                },
                addHeightIncrease(){
                    this.confForMod.heightIncreases.push({
                        // TODO: check the values
                        heightIncreaseStartheight: parseInt(this.newHeightIncreaseStart),
                        heightIncrease: parseInt(this.newInterval)
                    })
                    this.sortHeightIncrease();
                    //this.createAllHeights();
                    // reset the create field
                    this.newHeightIncreaseStart = undefined;
                    this.newInterval = undefined;
                },
                sortHeightIncrease(){
                    this.confForMod.heightIncreases.sort((el1, el2)=>{
                        return el1.heightIncreaseStartheight-el2.heightIncreaseStartheight;
                    });
                },
                sortSeries(){
                    this.series.sort((s1, s2)=>s1.number-s2.number);
                },

                /* !!! methods for SERIES creation only !!! */


                dragEnded(evt){
                    // TODO implement here all the logic to derive the changes on athletes (in the version where the changes are propagated live.)
                    console.log(`from ${evt.from.id} to ${evt.to.id}`);
                },
                unassignedAthleteChanged(evt){
                    // override the default behavior (add/remove to/from 'displayData' within v-table, which does not work) and add/remove the element instead to/from 'unassignedAthletesCreate'
                    console.log('drag changed');
                    if ('removed' in evt){
                        // remove the element from 'unassignedAthletesCreate'
                        var i = this.unassignedAthletesCreate.indexOf(evt.removed.element);
                        if (i!=-1){
                            // should always come here; remove the element
                            this.unassignedAthletesCreate.splice(i,1);
                        }

                    } else if ('added' in evt){
                        // add the element to 'unassignedAthletesCreate'
                        this.unassignedAthletesCreate.push(evt.added.element)
                    }
                },
                seriesChanged(evt){
                    // TODO: implement reordering of series here
                    let test
                },
                seriesStateChanged(evt){
                    // not needed for series assignment
                },
                presentChanged(affectedRow){
                    // the present status of an athlete was changed. Hand over the request to the room. 
                    rCTech.room.updatePresentStateInit(affectedRow);
                },
                startUpdateConf(){
                    this.confForMod = this.parseConf(this.contest.conf);
                    this.overlay = 'config';
                },
                abortUpdateConf(){
                    this.overlay = undefined;
                },
                saveUpdateConf(){
                    this.overlay = undefined;
                    this.propagateChange = true; // store the change to server!
                    this.contest.conf = JSON.stringify(this.confForMod);
                },

                parseConf(jason){
                    // a valid JSON must contain {} or []; an empty string, as it might occur in the DB as a default, is not valid!
                    let conf;
                    try{
                        conf = JSON.parse(jason);
                    }catch(ex){
                        conf = {};
                    }
                    // make sure conf has an array called heightIncreases
                    if (!('heightIncreases' in conf)){
                        conf.heightIncreases = [];
                    }
                    return conf;
                },
                getCategory(xCategory, property='shortname'){
                    let cat = this.categories.find(c=>c.xCategory==xCategory)
                    if (cat){
                        return  cat[property]
                    } else {
                        return '';
                    }
                },
                getYearShort: function(dateString){
                    let d = new Date(dateString);
                    return d.getFullYear().toString().slice(-2);
                },
                endRollCallCreateSeries(){
                    this.propagateChange = true;
                    this.contest.status = 70;
                    this.showInitialSeriesAssignment();
                },
                formatHeight(heightInDB){
                    if (heightInDB){
                        return (heightInDB/100).toString() + " m";
                    }

                    return "";
                },
                formatTime(time, dateIfNeeded=true, secondsIfNeeded=true){
                    // return a formatted time value.
                    // if dateFrom=dateTo, only return the time; otherwise include the portion of date needed.
                    // if seconds are given, include them
                    let s = '';
                    let d = new Date(time);
                    if (dateIfNeeded && this.meeting.dateFrom != this.meeting.dateTo){
                        s += (d.getMonth()+1).toString().padStart(2,0);
                        s += "." + d.getDate().toString().padStart(2,0) + ' ';
                    }
                    s += `${d.getHours()}`.padStart(2, '0');
                    s += ":" + `${d.getMinutes()}`.padStart(2,'0');
                    if (secondsIfNeeded && d.getSeconds() != 0){
                        s += ':' + `${d.getSeconds()}`.padStart(2,'0');
                    }

                    return s;

                },
                showInitialSeriesAssignment: function(){
                    // create a list of all unassigned athletes for the initial series assignment. This is a separate list from the unassignedAthletes for the base configuration
                    this.resetInitialSeriesAssignment()
                    
                    this.overlay2 = 'createSeries';
                },
                addEmptySeriesInitial: function(){
                    // add an empty series to the seriesObj used in the inital series configuration tool
                    this.seriesObj.push({
                        number:this.seriesObj.length+1, xSite: undefined, status: 10, name:'', startsingroup:[]
                    });
                },
                resetInitialSeriesAssignment: function(){
                    // recreate the set of unassigned athletes (=all startingroup where present=true): 
                    this.unassignedAthletesCreate = this.startgroups.filter(el=>el.present);

                    // delete all current series:
                    this.seriesObj = [];
                },
                createSeriesAutomatically: function(){
                    // first, reset current series
                    this.resetInitialSeriesAssignment();

                    // use selected algorithm to do automatic assignment
                    this.seriesAssignments[this.selectedSeriesAssignment].assignFunc.bind(this)()

                    // hide the overlay
                    this.overlay=undefined;
                    
                    // activate the ok button
                    this.$refs["saveInitSeries"].focus();
                },
                saveInitSeries: function(){
                    // save the initial series assignment
                    
                    // TODO: manually populate the actual series object; as soon as the change is processed on the server, the IDs will be replaced here with the actual IDs. 
                    // DIFFICULTY: Assume a client without connection, a series is (locally) generated, then it is deleted again. As soon as we have connection, the changes are sent to the server. However, the answer for the series creation cannot be processed completely, because the series was deleted meanwhile in the local data. HOW CAN THIS PROBLEM BE SOLVED?:
                    // IDEA 1: fail-safe programming. If an object does not exist anymore, simply do not care and just continue. This only works when we do not try to know, what element must be updated on data arrival via e.g. the series number, when we have a unique identifier, e.g. a temporary ID or we have function where the objects are referenced (not the position in the array or the array itself!)
                    
                    // The series structure should look like this
                    // series : all series objects
                    // series[0].heights : the heights jumped in this series
                    // series[0].seriesstartsresults : all athletes in this series
                    // series[0].seriesstartsresults[0].resultshigh : the results of the athletes

                    // do all the data managament in the room and not within vue!
                    rCTech.room.initialSeriesCreationInit(this.seriesObj);

                    this.overlay2 = undefined;

                    return false; // avoid reload of the page

                },
                deleteAllSeries: function(){
                    // TODO: implement a warning dialog!

                    // the room functiuon will also change the local data
                    rCTech.room.deleteAllSeriesInit();
                },
                moveSeries: function(evt){
                    // called, when series are reordered
                    // no differentiation needed between moved/added/removed, since only move is possible; 

                    // Note: evt.moved.element is NOT the series-element in data.series, since we work on a copy seriesAsStartgroups
                    rCTech.room.moveSeriesInit(evt.moved.oldIndex, evt.moved.newIndex)

                },
                removeSSR: function(evt){
                    if ("added" in evt){
                        rCTech.room.deleteSSR(evt.added.element.seriesOriginal, evt.added.element.ssrOriginal)
                    }
                    // nothing to do when removed or moved; removed is handled in the add event of the series and moving within the unassignedAthletes is useless, since it is done via the sortable table.
                },
                changePosition: function(series, evt){
                    // this function is responsible for:
                    // - moving athletes within series
                    // - moving athletes beyond series
                    // - newly assign athletes to a series
                    // --> unassign athgletes is handled in "removeSSR"! 

                    // if an athlete is moved from one series to another, the function is called in both series, once with "removed" and once with "added" as the argument; if it is within the same series, then with "moved"
                    // evt .element .newIndex .oldIndex

                    if ("removed" in evt){
                        // if we do the work in added, we  do not need to do anything in removed, since the data will already be gone.
                        // the opposite way around is not possible, since it would not be known where to move the element to.
                    } else if ("added" in evt){

                        // differentiate whether the element is a seriesstartsresult or an xStartgroup (i.e. unassignedAthlete)
                        if ("athleteName" in evt.added.element){
                            // previously was an unassigned athlete
                            // create seriesstartsresults
                            rCTech.room.addSSR(series.seriesOriginal, evt.added.element.xStartgroup, evt.added.newIndex);
                        } else {
                            // athlete moved from one series to another; data is a seriesstartsresults entry
                            // hand over all needed references to the original, referenced objects. Make sure the room stays independent from the copied series structure within 
                            // let the room do the rest
                            rCTech.room.changePositionInit(evt.added.element.ssrOriginal, evt.added.element.seriesOriginal, series.seriesOriginal, evt.added.newIndex);
                        }


                    } else if ("moved" in evt){
                        // hand over all needed references to the original, referenced objects. Make sure the room stays independent from the copied series structure within 
                        // let the room do the rest
                        rCTech.room.changePositionInit(evt.moved.element.ssrOriginal, evt.moved.element.seriesOriginal, series.seriesOriginal, evt.moved.newIndex);
                    }
                    
                },

                /* !!! methods for COMPETITION only !!! */

                transferAuxData(){
                    // manually transfer some of the aux properties (position and positionNext are transferred in calculateNextAthlete)
                    // this is needed when the positionNext and position do not change (when a change arrives on reading clients), because normally those properties are transferred there
                    this.currentHeight = this.roomAuxData[this.selectedXSeries].currentHeight;
                    this.currentJumpoffHeightInd = this.roomAuxData[this.selectedXSeries].currentJumpoffHeightInd;
                    this.attempt = this.roomAuxData[this.selectedXSeries].attempt;
                    this.attemptNext = this.roomAuxData[this.selectedXSeries].attemptNext;

                },

                setTime(){
                    // set the time for the attempt period and show it

                    // split the time between hours (here: minutes) and minutes (here: seconds)
                    let t = this.attemptTimeSetting.split(':');
                    let minutes = Number(t[0])
                    let seconds = Number(t[1])
                    if (isNaN(minutes) || isNaN(seconds)){
                        alert('Time is not valid')
                    } else {
                        this.roomAuxData[this.selectedXSeries].attemptPeriod = minutes*60+seconds;

                        this.roomAuxData[this.selectedXSeries].showAttemptPeriod = true;
                        this.roomAuxData[this.selectedXSeries].periodStartTime = null;

                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                    this.updateShownTime();

                },
                birthdayToXX(bd){
                // convert the birthday to a two letter year code
                    return bd.substr(2,2);
                },
                getStartByXSeriesStart(xSeriesStart){
                    //return this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart == xSeriesStart)
                    // TODO: revert this, since it is only for debugging
                    let x = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart == xSeriesStart)
                    if (!x){
                        //alert('could not find the athlete!');
                        // return some empty properties; because there is a short moment where the change of the series is only "halfway" processed, e.g. the value in the model is already changed, but the "calculateNextAthlete" is not yet called

                        // TODO: this is NOT a solution, since the returned object is also used to reference xStartgroup, which will fail with this default, non.existing value 
                        return {
                            xSeriesStart: xSeriesStart,
                            xStartgroup: -1,
                            xSeries: -1,
                            position: -1,
                            resultOverrule: 0,
                            resultRemark:'',
                            qualification: 0,
                            startConf: '',
                            resultshigh:[],
                        }

                    }
                    return x; 
                },
                meterStr(cm){
                    // translate cm to m-string with two decimal points; without unit!
                    let m = cm/100; 
                    return m.toFixed(2);
                },
                evaluateHeightDeletable(){
                    // heights cannot be deleted when there are already results for this height or when it is a startheight of an athlete (the latter might actually be neglected, when we want to accept that the startheight points to something that does not exist anymore. However, we would have to rethink the startheight-selection-dropdown)

                    if (this.mode>0){
                        let series = this.series[this.selectedSeries];

                        // store a list of all heights which are in use
                        let usedHeights = [];

                        // the currentHeight (regular and jumpoff) shall not be deleted!
                        if (this.currentHeight>0){
                            let hEl = series.heights.find((h)=>h.height==this.currentHeight && h.jumpoffOrder==0)
                            usedHeights.push(hEl.xHeight);
                        }
                        if (this.currentJumpoffHeight>0){
                            let hEl = series.heights.find((h)=>h.height==this.currentJumpoffHeight && h.jumpoffOrder==this.currentJumpoffHeightInd)
                            usedHeights.push(hEl.xHeight);
                        }

                        // loop over every result of all athletes and create a long array with heights
                        series.seriesstartsresults.forEach((start)=>{
                            start?.resultshigh?.forEach((heightEl)=>{
                                usedHeights.push(heightEl.xHeight);
                                /*
                                // find the height element
                                let hInd = series.heights.findIndex((h)=>heightEl.xHeight==h.xHeight)
                                if (hInd==-1){
                                    alert('Something went terribly wrong! Please reload the page. (A result references a height that does not exist.)');
                                }
                                deletable[hInd]=false;*/
                            })
                        })

                        // loop over all startheights and add these heights too
                        series.seriesstartsresults.forEach((start)=>{
                            if (start.startConf){
                                let hEl = series.heights.find((h)=>h.height==start.startConf && h.jumpoffOrder==0)
                                usedHeights.push(hEl.xHeight);
                            }
                        })

                        // store the 'deletable' state to the height
                        series.heights.forEach((hEl)=>{
                            let ind = usedHeights.indexOf(hEl.xHeight);
                            hEl.deletable = ind==-1;
                        })
                    }

                },
                sortAthletes(seriesIndex){
                    /* this must be the only sort function run on the seriesstartsresults! They need to keep this order all the time. */
                    this.series[seriesIndex].seriesstartsresults.sort((el1, el2)=>{
                        return el1.position-el2.position;
                    })
                },
                sortAthletesAllSeries(){
                    for (i=0;i<this.series.length;i++){
                        this.sortAthletes(i);
                    }
                },
                
                createAllHeights(){

                    // TODO: must be called when the series was changed!
                    if (this.series.length>0){
                        // combine the already done heights with the heights specified in the heightIncreases
                        this.allHeights = this.series[this.selectedSeries].heights.map((el)=>{return el.height}); // use "map" or analog here
                        // the index of the first heights must equal the index of the respective height in the series.heights array!!!

                        // add the future heights according to the current heightIncreases up to 6.5m in PV and up to 2.6m in HJ
                        /*let ind = this.allHeights.length;
                        let lastHeight = 0;
                        if (ind>0){
                            lastHeight = this.allHeights[ind-1];
                        }*/
                        
                        let maxHeight = 0;
                        this.conf.heightIncreases.forEach((el,ind)=>{
                            if (ind < this.conf.heightIncreases.length-1){
                                maxHeight = this.conf.heightIncreases[ind+1].heightIncreaseStartheight;
                            } else {
                                // get the correct value from a configuration (eventually also from baseDiscipline) 
                                maxHeight = this.disciplineConfiguration.heightMax;
                            }
                            for (let height=el.heightIncreaseStartheight;height<=maxHeight;height+=el.heightIncrease){
                                // not very efficient, but efficient enough
                                if (!this.allHeights.some(el=>{return el==height})){
                                    lastHeight = height;
                                    this.allHeights.push(height);
                                }
                            }
                        })
                        this.allHeights.sort((el1, el2)=>{return el1-el2})
                        // alert('heights done')
                    }
                },
                addHeight(height){
                    // this function can add a new height at any place in the array. If the height already exists, nothing is done. 
                    // The function will always check if the order of elements is correct and sort it if necessary

                    // make sure height is a number
                    height = Number(height);
                    if (isNaN(height)){
                        alert("ERROR: the height is not a number!");
                        return;
                    }

                    // DO NOT USE THIS FUNCTION IN THE JUMPOFF!!
                    if (this.mode>1){
                        alert('Jumpoff is running. Do not use "addHeight" in jumpoff!');
                        return false;
                    }

                    let heights = this.series[this.selectedSeries].heights;
                    // check if the height already exists
                    let heightExists = heights.some(el=>{if (el.jumpoffOrder==0 && el.height==height){return true}else{return false}})

                    if (!heightExists){
                        // add the height
                        let newHeight = {
                            xHeight: this.xHeightTemp--, // get the xHeight and then decrease it by one
                            xSeries: this.series[this.selectedSeries].xSeries, 
                            jumpoffOrder: 0,
                            height: height
                        };
                        
                        // do not actually add the height to the local data here, but through the room

                        // let the room add the height on the server
                        rCTech.room.addHeightInit(this.series[this.selectedSeries], newHeight)

                        this.sortHeightsAddOrder()
                        return true;
                    }else{
                        return false
                    }
                },
                sortHeightsAddOrder(){

                    if (this.mode>0){
                        let heights = this.series[this.selectedSeries].heights;

                        // sort the array
                        heights.sort((el1, el2)=>{
                            // sort: 1st: jumpoff order, 2nd, height
                            if (el1.jumpoffOrder==el2.jumpoffOrder) {
                                return el1.height-el2.height
                            } else {
                                return el1.jumpoffOrder - el2.jumpoffOrder;
                            }
                        })

                        // redefine the heightOrder
                        // is not used and not a real property of the DB 
                        /*let i=1;
                        heights.forEach(el=>{
                            // check if the height order must be changed and if yes, report to the server.

                            el.heightOrder = i;
                            i += 1;
                        })*/                        
                    }


                },
                addManualHeightEnter(e){
                    // when the enter key is pressed to add a new height
                    if (e.keyCode===13){
                        this.addManualHeight();
                    }
                },
                addManualJumpoffHeightEnter(e){
                    // when the enter key is pressed to add a new height
                    if (e.keyCode===13){
                        this.addManualJumpoffHeight();
                    }
                },
                addManualHeight(){
                    // TODO: check the inputted value and transform it to cm
                    let val = document.getElementById('manualHeight').value;

                    let ret;
                    if (this.mode==2){
                        ret = this.addHeightJumpoff(val);
                    } else {
                        ret = this.addHeight(val);
                    }

                    if(ret){
                        // success
                        document.getElementById('manualHeight').value = "";
                        this.createAllHeights();
                        this.evaluateHeightDeletable();
                    }else{
                        // failure (e.g. as the height exists already)
                        alert("<%= __('Height could not be added, e.g. because it exists already.') %>");
                    }

                    // we must now recalculate who is the next athlete. It changes e.g. when 
                    this.calculateNextAthlete();
                    
                },
                addManualJumpoffHeight(){
                    // TODO: check the inputted value and transform it to cm
                    //let val = document.getElementById('manualJumpoffHeight').value;
                    let val = this.manualJumpoffHeight;

                    let ret;
                    if (this.mode==2){
                        ret = this.addHeightJumpoff(val);

                        if(ret){
                            // success
                            this.manualJumpoffHeight = 0;
                            this.createAllHeights();
                            this.evaluateHeightDeletable();
                            this.jumpoffHeightRequired = false;
                        }else{
                            // failure (e.g. as the height exists already)
                            alert("<%= __('Height could not be added.') %>");
                        }

                        // we must now recalculate who is the next athlete. It changes e.g. when 
                        this.calculateNextAthlete();
                    } 
                    
                },
                addHeightJumpoff(height){

                    height = Number(height)
                    if (isNaN(height)){
                        alert("ERROR: the height is not a number!");
                        return;
                    }

                    // ONLY USE THIS FUNCITON IN JUMPOFF
                    if (this.mode<2){
                        alert('This function is only to be used during the jumpoff');
                        return false;
                    }

                    let newHeight = {
                        xHeight: this.xHeightTemp--,
                        xSeries: this.selectedSeries, 
                        jumpoffOrder: this.bestAtEachJumpoffHeight.length + 1,
                        height: height
                    }

                    // do not actually add the height to the local data here, but through the room

                    // let the room add the height on the server
                    rCTech.room.addHeightInit(this.series[this.selectedSeries], newHeight)

                    this.sortHeightsAddOrder();
                    return true;

                },
                deleteHeight(index){

                    // get the height
                    let height = this.series[this.selectedSeries].heights[index];

                    rCTech.room.deleteHeightInit(height);

                    this.createAllHeights();
                    if (this.mode==2){
                        // in jumpoff, if we delete the next height, the menu showing "create next height" must return --> will appear when the next athletes were calculated
                        this.currentJumpoffHeightInd = 0
                        this.calculateNextAthlete(); 

                    }
                },
                replaceXResult(xSeriesStart, oldKey, newKey){
                    alert('TODO')

                    // replace the old key by the new key
                    // TODO

                    // if the result is currently changed, we need to change the key of the input element there, as it will be invalid afterwards otherwise
                    let el = document.getElementById('resChange' + oldKey)
                    if (el){
                        el.id = 'resChange' + newKey;
                    }
                },
                startHeightChanged(xSeriesStartEl){
                    // if the chosen height is not yet fixed (i.e. in the heights array of the series), add it to the heights

                    this.addHeight(xSeriesStartEl.startConf); // will check if it is new automatically

                    this.evaluateHeightDeletable();

                    // send the change to the server
                    rCTech.room.updateSSRInit(xSeriesStartEl);


                    // check if the competition can start already
                    this.calculateNextAthlete();
                },
                updateSSR(ssr){
                    // send the change to the server
                    rCTech.room.updateSSRInit(ssr);

                },
                allStartHeightsDefined(){
                    if (this.series.length==0){
                        return false;
                    }
                    let allDefined = this.series[this.selectedSeries].seriesstartsresults.every(el=>{
                        if (el.startConf){
                            return true;
                        }else {
                            this.mode = 0;
                            return false;
                        }
                    })

                    return allDefined;

                },
                calculateTemporaryRankingData(){
                    // calculate all data needed for ranking and to find out, who is next

                    /*                             12:{
                        totalFailedAttempts: 0, // until and with the last valid hight
                        failedAttemptsSinceLastValid: 0, // after 3, the person is out of the competition. 
                        failedAttemptsOnLastValid: 0,
                        lastValidHeight: 0,
                        lastFinishedHeight:,
                        firstUnfinishedHeight:,
                    },*/

                                                    /*{
                            xResult:1,
                            xHeight: 1, // the link to the height!
                            //resultshighSortOrder, // not needed!, the current position (temporary different athlete order) is handled differently
                            resultsHighFailedAttempts: 1, // how many fails on this hight
                            resultsHighValid: true, 
                            resultsHighPassed:false // verzichtet (-)
                        },*/

                    // maybe we need to sort the results first...

                    // TODO: cleanup the jumpoff; some variable were introduced, which are not used anymore.

                    // jumpoff statistics for ranking: 
                    let maxNumJumpoffAttempts = 0;
                    this.bestAtEachJumpoffHeight = []; // [0,0,1] --> at the first two jumpoff heights, the best athlet has failed (i.e. all have failed), at5 the third height at least one athlete has passed the bar. This is (probably) needed for the ranking

                    // go through every result of every athlete; assumes that the results are sorted
                    this.series[this.selectedSeries].seriesstartsresults.forEach((start)=>{

                        /*if (start.resultOverrule>0){
                            // i.e. when DNS, retired, DQ, ...
                            // TODO: is this needed?
                        }else{*/

                        let totalFailedAttempts = 0;
                        let failedAttemptsSinceLastValid = 0;
                        let failedAttemptsOnLastValid = 0;
                        let lastValidHeight = 0;

                        let lastFinishedHeight = undefined; // in cm, finished = valid or passed
                        let firstUnfinishedHeight = undefined; // in cm

                        // jumpoff
                        let numFailedJumpoffAttempts = 0; // probably only the array jumpoffResults is needed
                        let numValidJumpoffAttempts = 0; // probably only the array jumpoffResults is needed
                        let jumpoffResults = []; // valid=true, failed=false

                        // if resultOverrule is >0 (i.e. DNS, DQ, retired) then the athlete is 'finished'
                        let finished = start.resultOverrule>0;
                        start.resultshigh.forEach((heightResult)=>{
                            // find out whether it is a regular height (i.e. not jumpoff)
                            let heightEl = this.series[this.selectedSeries].heights.find((el)=>{return el.xHeight == heightResult.xHeight});
                            //let heightEl = this.series[this.selectedSeries].heights[hIndex];
                            if (!heightEl){
                                alert('Fatal error: Result for a non-existing height appeared. Should never happen!');
                                return;
                            }
                            // normal and jumpoff results must be handled separately 
                            if (heightEl.jumpoffOrder==0){    
                                // normal
                                if (heightResult.resultsHighValid || heightResult.resultsHighPassed){
                                    totalFailedAttempts += heightResult.resultsHighFailedAttempts;
                                    if (lastFinishedHeight){
                                        lastFinishedHeight = Math.max(heightEl.height, lastFinishedHeight);
                                    } else {
                                        lastFinishedHeight = heightEl.height;
                                    }
                                } else {
                                    if (!firstUnfinishedHeight){
                                        firstUnfinishedHeight = heightEl.height;
                                    } else {
                                        firstUnfinishedHeight = Math.min(heightEl.height, firstUnfinishedHeight); // the elements may be out of order!
                                    }
                                }
                                if (heightResult.resultsHighValid){
                                    lastValidHeight = Math.max(heightEl.height, lastValidHeight);
                                    failedAttemptsOnLastValid = heightResult.resultsHighFailedAttempts;
                                    failedAttemptsSinceLastValid = 0;
                                }else{
                                    failedAttemptsSinceLastValid += heightResult.resultsHighFailedAttempts;

                                    if (failedAttemptsSinceLastValid >= 3){
                                        finished = true;
                                    }                                                 

                                }
                                
                            }else{
                                // jumpoff
                                if (heightResult.resultsHighValid){
                                    numValidJumpoffAttempts += 1;
                                    jumpoffResults[heightEl.jumpoffOrder-1] = true;
                                } else {
                                    numFailedJumpoffAttempts += 1;
                                    jumpoffResults[heightEl.jumpoffOrder-1] = false;
                                }
                                maxNumJumpoffAttempts = Math.max(maxNumJumpoffAttempts, numValidJumpoffAttempts+numFailedJumpoffAttempts);
                                
                            }
                        })
                        
                        this.tempRankingData[start.xSeriesStart] = {
                            totalFailedAttempts: totalFailedAttempts, // until and with the last valid hight
                            failedAttemptsSinceLastValid: failedAttemptsSinceLastValid, // after 3, the person is out of the competition. 
                            failedAttemptsOnLastValid: failedAttemptsOnLastValid,
                            lastValidHeight: lastValidHeight,
                            //nextJumpingHeight: 0, // TODO?
                            finished: finished,
                            lastFinishedHeight: lastFinishedHeight,
                            firstUnfinishedHeight: firstUnfinishedHeight,
                            numFailedJumpoffAttempts: numFailedJumpoffAttempts,
                            numValidJumpoffAttempts: numValidJumpoffAttempts,
                            jumpoffResults: jumpoffResults,
                            resultOverrule: start.resultOverrule, // just needed for jumpoff
                            jumpoffFailedAtI: 10000, // do not change this value, or change it as well in 'calculateNextAthlete'
                        }
                        
                        if (lastValidHeight>this.maxLastValidHeight){
                            this.maxLastValidHeight = lastValidHeight;
                        }

                    })

                    // -----------
                    // additional analysis for jumpoff:
                    // calculate the best result on every jumpoff height
                    Object.values(this.tempRankingData).forEach((tempRankData)=>{
                        if (tempRankData.jumpoffResults.length>0){
                            tempRankData.jumpoffResults.forEach((valid, i)=>{
                                if (this.bestAtEachJumpoffHeight[i]==undefined){
                                    // no best result yet defined, so take this result as a start
                                    this.bestAtEachJumpoffHeight[i]=valid;
                                }else{
                                    // best result already defined; can only get 'better' (from failed to valid)
                                    if (valid){
                                        this.bestAtEachJumpoffHeight[i]=valid;
                                    }
                                }
                            })
                        }
                    })

                    // calculate when the athletes have failed in the jumpoff and/or what would be his next height
                    Object.values(this.tempRankingData).forEach((tempRankData)=>{
                        tempRankData.outOfJumpoff = false; // TODO: this probably does not work like this... lets see how it works in ranking. (The value is also set for athletes that are not in the jumpoff; however, it will be the same for all those athletes and thus doesnt matter)
                        if (tempRankData.jumpoffResults.length>0){
                            // compare every heigh with the best result at this height
                            for (let i=0; i<tempRankData.jumpoffResults.length;i++){
                                if (!tempRankData.jumpoffResults[i] && this.bestAtEachJumpoffHeight[i]){
                                    tempRankData.jumpoffFailedAtI = i;
                                    tempRankData.outOfJumpoff = true;
                                }
                            }
                        } 
                        if (!tempRankData.outOfJumpoff) {
                            if (tempRankData.resultOverrule==1){
                                // athlete has retired --> "failed" at his last height +1
                                tempRankData.jumpoffFailedAtI = tempRankData.jumpoffResults.length;
                            }
                            // write as if they failed on the next height --> new: shall remain at 10000!
                            //tempRankData.jumpoffFailedAtI = this.bestAtEachJumpoffHeight.length+1;
                        }
                    })
                    //-------------

                    // the actual ranking:
                    
                    // create an array-copy of the starts
                    let starts = this.series[this.selectedSeries].seriesstartsresults.slice();

                    // sort this array:
                    starts.sort((s1, s2)=>{
                        if (Math.max(s1.resultOverrule,1) !=  Math.max(s2.resultOverrule,1)){ // regular (0) and retired (1) must be treated the same
                            return s1.resultOverrule - s2.resultOverrule; // this should meansingfully sort also within resultOverrule
                        }
                        // both result overrules are the same or both <2
                        if (s1.resultOverrule <2){
                            // usual result: 
                            let r1 = this.tempRankingData[s1.xSeriesStart];
                            let r2 = this.tempRankingData[s2.xSeriesStart];

                            // 1) lastValidHeight
                            if (r1.lastValidHeight != r2.lastValidHeight){
                                return r2.lastValidHeight - r1.lastValidHeight; // the lower the more to the right.
                            }

                            // 2) failed attempts on last valid height
                            if (r1.failedAttemptsOnLastValid != r2.failedAttemptsOnLastValid){
                                return r1.failedAttemptsOnLastValid - r2.failedAttemptsOnLastValid; // the lower the more to the left
                            }

                            // 3) failed attempts in total
                            if (r1.totalFailedAttempts != r2.totalFailedAttempts){
                                return r1.totalFailedAttempts - r2.totalFailedAttempts; // the lower the more to the left
                            }

                            // jumpoff:

                            // 4) failed later in jumpoff
                            if (r1.jumpoffFailedAtI != r2.jumpoffFailedAtI){
                                return r2.jumpoffFailedAtI - r1.jumpoffFailedAtI; // the heigher the better
                            }

                            // 5) it is also deemed 'failure' when an athlete retired after the last height. Thus if both have failed at the same height, but one is finally called reitred, he actually left before and thus is ranked worse
                            if (r1.resultOverrule != r2.resultOverrule){
                                return r1.resultOverrule - r2.resultOverrule;
                            }

                        } 

                        // equal results
                        return 0;

                    })

                    // current rank during rank assignment
                    let rank=1;
                    // from the sorted array, derive the ranking
                    for (let i=0; i<starts.length;i++){
                        if (starts[i].resultOverrule<2){
                            let r2 = this.tempRankingData[starts[i].xSeriesStart];
                            if (i>0){
                                let r1 = this.tempRankingData[starts[i-1].xSeriesStart];
                                // check if the element equals the last
                                let equal = (r1.lastValidHeight == r2.lastValidHeight && r1.failedAttemptsOnLastValid == r2.failedAttemptsOnLastValid && r1.totalFailedAttempts == r2.totalFailedAttempts && r2.jumpoffFailedAtI == r1.jumpoffFailedAtI && r1.resultOverrule == r2.resultOverrule); 
                                if (!equal){
                                    rank = i+1;
                                }
                            }
                            // assign a rank only if there is a valid height
                            if (r2.lastValidHeight){
                                this.tempRankingData[starts[i].xSeriesStart].rank = rank;
                            }else{
                                this.tempRankingData[starts[i].xSeriesStart].rank = 0;
                            }
                            
                        } else {
                            this.tempRankingData[starts[i].xSeriesStart].rank = 0; // TODO: eventually, no rank is something undefined instead of 0 or we use rank as a string and tranlate the overrule-code here to DQ, DNS, DNF, ...
                        }
                        
                    }



                },
                calculateNextAthlete(){

                    // Jumpoff: 
                    /*
                    - the jupoff does not necessary take place --> is defined in the jumpoff-variable
                    - ranking in jumpoff: retired athletes are last, in the order of their retiring (i.e. 3 athletes in jumpoff, one retires at the beginning (--> rank 3), the second retires after three more heights (--> second rank) while tha last would continue (--> rank 1))
                    - attention: it is possible that all athletes retire at the same time at any time in the competition. Then all are ranked first. 
                    - the ranking should only be done after a height is jumped by all athletes in the jumpoff (in order to avoid that eventually one person is temporary ranked second, if he still has the chance to be in competition afterwards!)
                    - ranking the following way: (1) more valid is better; (2) more failed is better (i.e. the athlete retired later; only used when >2 athletes in jumpoff)
                    Note: if all athletes want to withdraw, the last withdrawel has to be made in the change-result section; until then, the remaining person is declared the winner.
                    */

                    //this.currentResultRegistered = false;

                    let series = this.series[this.selectedSeries];

                    // check if all startheights are given
                    if (this.allStartHeightsDefined()){

                        // TODO: eventually we should determine the mode automatically as well..? This would also imply changes in calculateTemporaryRankingData

                        // change the mode to competition running, if it was at 'define startheigts' before. (This check is needed since otherwise it would leave jumpoff!) 
                        if (this.mode==0){
                            this.mode=1;
                        }

                        // the currentHeight is calculated automatically:

                        // find the lowest height, where an athlete is in competition (min(nextJumpingHeight)) (neither retired nor DQ nor DNS...) or get the next height after the last valid height of an athlete. 

                        this.calculateTemporaryRankingData();

                        // for athletes that are not yet in competition (no results), get the startheight; for athletes that are in competition, use the lower of lastFinistedHeight+next and firstUnfinished
                        let lowestUnfinished = 1000; // here we can also include the startheight of athletes that were not in competition yet
                        let lowestFinishedDefault = 1000;
                        let lowestFinished = lowestFinishedDefault; // to calculate the next height after this

                        // calculate some Jumpoff-stuff within the same loop
                        let numJumpoffParticipants = 0;
                        let nextJumpoffHeightInd = 1000; // the index in the jumpoffResults-Array represnting the jumping height th next athlete is doing. It is not necessarily the next coming height, e.g. when a few athletes already jumped on that height, while at least one has not.

                        let mainCompetitionFinished = true;
                        series.seriesstartsresults.forEach(start=>{

                            let tmp = this.tempRankingData[start.xSeriesStart];
                            if (!tmp.finished){

                                mainCompetitionFinished = false;

                                // athlete is still in competition
                                if (start.resultshigh.length){
                                    if (tmp.firstUnfinishedHeight){ // might be undefined, when there is no unfinished height
                                        lowestUnfinished = Math.min(lowestUnfinished, tmp.firstUnfinishedHeight);    
                                    }
                                    if (tmp.lastFinishedHeight){ // undefined when there is no finished height yet
                                        // at least one height is finished for this athlete
                                        lowestFinished = Math.min(lowestFinished, tmp.lastFinishedHeight);
                                    }
                                    
                                } else {
                                    // no result yet; use the startheight
                                    lowestUnfinished = Math.min(lowestUnfinished, start.startConf);
                                }
                            }
                            if(tmp.finished && tmp.rank==1) {
                                // finished, and rank 1 --> currently part of the jumpoff
                                numJumpoffParticipants += 1;

                                // get the next height in the jumpoff:
                                if (nextJumpoffHeightInd>tmp.jumpoffResults.length && tmp.jumpoffFailedAtI==10000){
                                    nextJumpoffHeightInd=tmp.jumpoffResults.length+1;
                                }
                            }
                            if (tmp.jumpoffResults.length>0){
                                // if an older jumpoffResult is deleted (which should NOT be done!), it would create a hole (<empty>) in the jumpoffResults --> in that case, the currentJumpoffHeight would be the first empty element in the array!
                                let firstUndef = tmp.jumpoffResults.findIndex(val=>val==undefined);
                                if (firstUndef>=0 && nextJumpoffHeightInd>firstUndef){
                                    nextJumpoffHeightInd = firstUndef;
                                    console.log('There was a jumpoff-height missing. This should not happen, since parts of the code might not work as expected in that case.')
                                    // then we might also have to add this person to the count of the number of participants in the jumpoff:
                                    if (!(tmp.finished && tmp.rank==1)){
                                        numJumpoffParticipants++;
                                    }
                                }
                            }


                        })

                        // when the competition is over, stop here (the rest is not needed and would not work appropriately)
                        if (mainCompetitionFinished){
                            if (numJumpoffParticipants>1 && this.conf.jumpoff){
                                this.mode = 2;
                            } else{
                                this.mode = 3;
                                this.positionNext = [];
                                this.position = [];
                                return; // dont need to continue when the competition is over
                            }
                        }

                        if (this.mode==1){

                            let newCurrentHeight;
                            if (lowestFinished == lowestFinishedDefault){
                                // nothing finished yet, thus always lowestUnfinished is governing
                                newCurrentHeight = lowestUnfinished;
                            } else {
                                // the current height is the minimum of: lowestUnfinishedHeight and the next height after the lowestFinishedHeight
                                let i = this.allHeights.indexOf(lowestFinished);
                                let lowestNextHeight = this.allHeights[i+1];
                                
                                newCurrentHeight = Math.min(lowestNextHeight,lowestUnfinished)
                            }

                            // get the height-element
                            let hEl = series.heights.find(h=>h.height==newCurrentHeight && h.jumpoffOrder==0);
                            if (!hEl){
                                // create the height, as it does not exist yet
                                this.addHeight(newCurrentHeight);
                                hEl = series.heights.find(h=>h.height==newCurrentHeight && h.jumpoffOrder==0);
                            }

                            // calculate the new position and positionNext arrays; however, do NOT directly store them to this, but do this copy at the end, based on whether this client is writing or not!
                            let position=[], positionNext=[];
                            if (newCurrentHeight != this.currentHeight){
                                // the currentHeight has changed! We must a.o. recreate the positions array
                                this.currentHeight = newCurrentHeight;

                                // if the currentHeight changes:
                                // 2022-03: I think the following paragraph is wrong. I indeed implemented an algorithm to find the bast position and add the athlete there!
                                // OLD: 
                                // as it is hardly possible to transfer the different order in 'positions' compared to the default given in sSeriesStart, the position is always resetted to the default. 
                                // WHY is is hardly possible: The positions array always stores, who is still in competition on the current height (i.e. not overall). That means at the end, it will finally only contain the very last athlete, as all the others either failed 3 times or have a valid result already. Now we could think of not removing the elements from the array when the athlete do not jump on this height anymore, which would make transferring the changed order much simpler. However, if the user wants to change the order on the current height e.g. in the second attempt, then it would be strange if also athletes would appear that have passed already in the first attempt.

                                // position gives the current (during this height) order of athletes; create this array from scratch:

                                // find out what athletes are starting on this height: not finished, startheight <= currentHeight, has not finished this height yet
                                // first add all starts to the following array, before creating the final position array (TODO: or should we keep the array with the full data? I'm a bit worried because of the observers bound to the object for Vue...)
                                let starts = [];
                                series.seriesstartsresults.forEach(el=>{
                                    if (el.startConf <= this.currentHeight && !this.tempRankingData[el.xSeriesStart].finished && (this.tempRankingData[el.xSeriesStart].lastFinishedHeight === undefined || this.tempRankingData[el.xSeriesStart].lastFinishedHeight < this.currentHeight)){
                                        starts.push(el);
                                    }
                                })

                                // sort the starts
                                starts.sort((a,b)=>{
                                    return a.position-b.position
                                })

                                // derive the position array
                                position = []; 
                                starts.forEach(el=>position.push(el.xSeriesStart));
                            } else {
                                // update the position array, without recreating it from default in order not to lose the current changes to it. 
                                // check for every athlete that should jump on the current height whether he is in the position array or not; finally delete all those entries that are not jumping (anymore)
                                let posCopy = this.position.slice(); 
                                position = this.position.slice();

                                series.seriesstartsresults.forEach(el=>{
                                    if (el.startConf <= this.currentHeight && !this.tempRankingData[el.xSeriesStart].finished && (this.tempRankingData[el.xSeriesStart].lastFinishedHeight === undefined || this.tempRankingData[el.xSeriesStart].lastFinishedHeight < this.currentHeight)){
                                        
                                        let ind = this.position.findIndex(el2=>el2==el.xSeriesStart)
                                        if (ind == -1){
                                            // start must be added on the best position!
                                            // first create an array with the deafult positions of the athletes in the current positions-list
                                            let positionDefault = Array(this.position.length);
                                            for (let i=0;i<this.position.length;i++){
                                                let start = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart==this.position[i])
                                                if (!start){
                                                    alert('Error: Something went terribly wrong.');
                                                }
                                                positionDefault[i] = start.position;
                                            }

                                            // go through the possible positions (number of positions: position.length+1)
                                            // best position is where most of the athletes would be correctly before and after according to the position default
                                            let minSortedWrong = this.position.length+10;
                                            let minSortedWrongIndex = -1;
                                            for (let i=0; i<=this.position.length;i++){
                                                let sortedWrong = 0;
                                                // before:
                                                for (let j=0;j<i;j++){
                                                    if (positionDefault[j]>el.position){
                                                        sortedWrong++;
                                                    }
                                                }
                                                // after: 
                                                for (let j=i;j<this.position.length; j++){
                                                    if (positionDefault[j]<el.position){
                                                        sortedWrong++;
                                                    }
                                                }
                                                if (sortedWrong<minSortedWrong){
                                                    minSortedWrong = sortedWrong;
                                                    minSortedWrongIndex = i;
                                                }
                                            }

                                            // add the element at the best position
                                            position.splice(minSortedWrongIndex,0,el.xSeriesStart);

                                        } else {
                                            // remove from posCopy
                                            let ind = posCopy.indexOf(el.xSeriesStart);
                                            if (ind==-1){
                                                alert('Error: Should not happen...');
                                            }else{
                                                posCopy.splice(ind,1);
                                            }
                                        }
                                    }
                                })

                                // delete all elements in position that are still in posCopy
                                posCopy.forEach(el=>{
                                    let ind = position.indexOf(el);
                                    position.splice(ind,1);
                                })
                                // done.

                            }


                            // find out which athlete is the next
                            // 1. find out the minimum number of failed attempts
                            let minFailedAttempts = 10;
                            let minFailedAttemptsCount = 0; // how many times this number of attempts appeared
                            position.forEach(xSeriesStart=>{
                                // get the corresponding start
                                let start = series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart);

                                // get the correspnding height result (if there is one! --> otherwise minFailedAttempts is zero!)
                                let hAth = start.resultshigh.find((el)=>{
                                    h = series.heights.find(hEl=>el.xHeight==hEl.xHeight); // if everything is correct, must always find an element
                                    if (h===undefined){
                                        alert('ERROR: Should never be here. Could not find the corresponding height for a given xHeight.');
                                        throw('ERROR: Should never be here. Could not find the corresponding height for a given xHeight.');
                                        
                                    }
                                    return h.height==this.currentHeight;
                                })
                                if (hAth===undefined){
                                    if (minFailedAttempts==0){
                                        minFailedAttemptsCount++;
                                    }else{
                                        minFailedAttempts=0;
                                        minFailedAttemptsCount=1;
                                    }
                                }else{
                                    if (minFailedAttempts>hAth.resultsHighFailedAttempts){ 
                                        minFailedAttempts=hAth.resultsHighFailedAttempts;
                                        minFailedAttemptsCount=1;
                                        
                                    }else if(minFailedAttempts == hAth.resultsHighFailedAttempts){
                                        minFailedAttemptsCount++;
                                    }
                                }

                            })
                            // now we know what attempt we are in (--> minFailedAttempts+1)
                            this.attempt = minFailedAttempts+1;
                            this.attemptNext = minFailedAttemptsCount>1 ? minFailedAttempts+1 : minFailedAttempts+2;

                            // now, create the order of the next athletes (positionNext):

                            
                            // OLD:                             
                            //if ((!this.readOnly) || positionNext.length==0){
                            // NEW: 
                            if (true){
                                // get the first athlete where minFailedAttempts == hEl.resultsHighFailedAttempts
                                let currentAthlete = -1;
                                // reinitialize the positionNext array
                                positionNext = Array(position.length);
                                let n = 0;
                                for (let a = minFailedAttempts; a<3; a++){
                                    for (let i=0;i<position.length;i++){
                                        // check for every athlete in the order of the position array, if failed attempt == a; then he starts as n'th athlete from now.
                                        let xSeriesStart = position[i];

                                        // get the corresponding start
                                        let start = series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart);
                                        // get the correspnding height result (if there is one! --> otherwise minFailedAttempts is zero!)
                                        let hAth = start.resultshigh.find((el)=>{
                                            h = series.heights.find(hEl=>el.xHeight==hEl.xHeight); 
                                            return h.height==this.currentHeight;
                                        })
                                        if (hAth==undefined){
                                            if (minFailedAttempts != 0){
                                                alert ("Error: Should never get here!");
                                            } else {
                                                // if hAth is undefined, then the athlete has no result yet on this height, i.e. his resultsHighFailedAttempts=0
                                                if (a==0){
                                                    positionNext[n] = i;
                                                    n++;
                                                }
                                            }
                                        }else {
                                            if (hAth.resultsHighFailedAttempts==a){
                                                positionNext[n] = i
                                                n++;
                                            }
                                        }
                                    }
                                }
                                if (n != position.length){
                                    alert('Error: something went wrong in this loop.. :-(( The order of next athletes might be wrong.')
                                } 
                            } 

                            //
                            if (this.readOnly){
                                // we actually do not use the position and positionNext data that we just have created, but we use the data that was given via the aux data. But we compare the length of the array in order to detect problems (which should never happen.)
                                if (position.length != this.roomAuxData[series.xSeries].position.length || positionNext.length != this.roomAuxData[series.xSeries].positionNext.length){
                                    console.log('Error: the number of athletes jumping on the current height was calculated differently by this browser than given by the data from the server. This should not happen. Please report the constellation, where this happened, to the developers.')
                                }
                                this.positionNext = this.roomAuxData[series.xSeries].positionNext.slice(); // we use slice to create a copy!
                                this.position = this.roomAuxData[series.xSeries].position;

                                this.currentHeight = this.roomAuxData[series.xSeries].currentHeight;
                                this.currentJumpoffHeightInd = this.roomAuxData[series.xSeries].currentJumpoffHeightInd;
                                this.attempt = this.roomAuxData[series.xSeries].attempt;
                                this.attemptNext = this.roomAuxData[series.xSeries].attemptNext;

                            } else {
                                // writing client. Set position and positionNext. If they have changed, send the changes to the server.
                                if (JSON.stringify(this.position) != JSON.stringify(position) || JSON.stringify(this.positionNext) != JSON.stringify(positionNext) || this.roomAuxData[series.xSeries].currentHeight != this.currentHeight || this.roomAuxData[series.xSeries].currentJumpoffHeightInd != this.currentJumpoffHeightInd || this.roomAuxData[series.xSeries].attempt != this.attempt || this.roomAuxData[series.xSeries].attemptNext != this.attemptNext) {
                                    this.autoManageAuxData(false);
                                    this.roomAuxData[series.xSeries].positionNext = positionNext;
                                    this.roomAuxData[series.xSeries].position = position;

                                    // additionally propagate the following properties to all clients (this is especially needed when the site is reloaded after the result is entered, but before it is advanced to the next athlete. Then, the current height and attempt would reference to the next height, while the position arrays still reference the last jump on the previous height, as intended.)
                                    this.roomAuxData[series.xSeries].currentHeight = this.currentHeight;
                                    this.roomAuxData[series.xSeries].currentJumpoffHeightInd = this.currentJumpoffHeightInd;
                                    this.roomAuxData[series.xSeries].attempt = this.attempt;
                                    this.roomAuxData[series.xSeries].attemptNext = this.attemptNext;

                                    // send the changed data to the server
                                    rCTech.room.updateAuxDataInit(this.roomAuxData);
                                }
                                this.position = position;
                                this.positionNext = positionNext;
                            }

                            
                        } else if (this.mode==2){
                            // in jumpoff mode.

                            // Important: Regarding the position and positionNext arrays, the whole jumpoff is handled as "one height", i.e. the positions array is reduced when somebody did his jump. Instead, the positionNext array gets modified. (In other words: the different jumpoff heights are equivalend to the attempts in the regular competition.)

                            // a new jumpoff height is requried when there is no jumpoff height with jumpoffOrder==nextJumpoffHeightInd
                            this.jumpoffHeightRequired = false; // needed such that adding the next jumpoff height in the heights-menu works as well 
                            if (series.heights.findIndex(h=>h.jumpoffOrder==nextJumpoffHeightInd)==-1){
                                this.jumpoffHeightRequired = true;

                                // suggest the next height for the jumpoff
                                // check whether the new height already exists or let the user define the next jumpoff height!
                                let lastJumpoffIndex = 0;
                                let lastJumpoffHeight = 0;
                                for(let i=0;i<series.heights.length;i++){
                                    let el = series.heights[i];
                                    if (lastJumpoffIndex<el.jumpoffOrder){
                                        lastJumpoffHeight = el.height;
                                        lastJumpoffIndex = el.jumpoffOrder;
                                    }
                                }
                                
                                // create the new height
                                let val = 0; 
                                if (nextJumpoffHeightInd==1){
                                    // the first jumpoffHeight if the first height after the height where all jumpoff-paritcipants have succeeded

                                    // find the smallest height after the maxlastValidHeight
                                    val = 10000;
                                    series.heights.forEach((el,ind)=>{
                                        if (el.height>this.maxLastValidHeight && el.height<val){
                                            val = el.height;
                                        }
                                    })

                                } else {
                                    if (this.bestAtEachJumpoffHeight[this.bestAtEachJumpoffHeight.length-1]){
                                        // TODO: get the jumpoffHeightVariation via baseDiscipline
                                        // increase the last jumpoffHeight by this.jumpoffHeightVariation (i.e. 2cm for HJ and 5cm fo PV)
                                        val = lastJumpoffHeight + this.disciplineConfiguration.jumpoffHeightVariation;
                                    }else {
                                        // decrease the last jumpoffHeight by this.jumpoffHeightVariation (i.e. 2cm for HJ and 5cm fo PV)
                                        val = lastJumpoffHeight - this.disciplineConfiguration.jumpoffHeightVariation;
                                    }
                                }
                                // predefine the next height and let the user confirm teh height
                                this.manualJumpoffHeight = val;
                                
                            }

                            // formerly, nextJumpoffHeight was really the next jumpoffHeight. However, it is used as the currentJumpoffHeight now.
                            this.currentJumpoffHeightInd = nextJumpoffHeightInd;
                            // try to take over the positions from the previous height. This only works, when there are the same or fewer athletes.

                            // get all athletes that are still in the jumpoff (including those that jumped already on the current height!), i.e. all athletes where jumpoffFailedAtI>currentJumpoffHeightInd
                            
                            let recreatePos = false;
                            let starts = []; // only used in case of additional athletes, which may only happen after changes in past results
                            Object.entries(this.tempRankingData).forEach(([xSeriesStart, el])=>{

                                if (el.jumpoffFailedAtI>this.currentJumpoffHeightInd && el.rank==1){//(el.jumpoffResults.length==nextJumpoffHeightInd || el.jumpoffResults[nextJumpoffHeightInd]==undefined){
                                    starts.push(series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart));
                                    if(this.position.indexOf(parseInt(xSeriesStart))==-1){
                                        // if would have to add, we will recreate the positions array  afterwards
                                        recreatePos = true;
                                    }
                                }
                            })

                            // work on local copies of position and positionNext and finally detect possible changes
                            let position = this.position.slice();
                            let positionNext = this.positionNext.slice();
                            if (recreatePos){
                                // sort the starts
                                starts.sort((a,b)=>{
                                    return a.position-b.position;
                                })

                                // derive the position array
                                position = []; 
                                starts.forEach(el=>position.push(el.xSeriesStart));

                                /* positionNext = Array(position.length);
                                for (let i=0;i<positionNext.length;i++){
                                    positionNext[i] = i;
                                } */

                            } else {
                                // delete positions that do not start on this height:
                                let i = position.length;
                                while (i--){
                                    let xSeriesStart = position[i];
                                    if (this.tempRankingData[xSeriesStart].jumpoffFailedAtI<=this.currentJumpoffHeightInd){//(this.tempRankingData[xSeriesStart].jumpoffResults.length != nextJumpoffHeightInd && this.tempRankingData[xSeriesStart].jumpoffResults[nextJumpoffHeightInd]!=undefined){
                                        position.splice(i,1);
                                    }
                                }
                            }

                            // OLD (pre 2022-03 = pre position/positionNext work as they should and non-autoAdvance works):
                            //if ((!this.readOnly) || positionNext.length==0) {
                            // NEW: 
                            if (true){
                                // define the order of athletes on the current height (positionNext)
                                // loop over the position array and check which athletes will still jump on the current height
                                positionNext = [];
                                for (let i=0; i<position.length; i++){
                                    let xSeriesStart = position[i];
                                    if(this.tempRankingData[xSeriesStart].jumpoffResults[this.currentJumpoffHeightInd-1]==undefined){
                                        positionNext.push(i);
                                    }
                                }
                            }

                            if (this.readOnly){
                                // we actually do not use the position and positionNext data that we just have created, but we use the data that was given via the aux data. But we compare the length of the array in order to detect problems (which should never happen.)
                                if (position.length != this.roomAuxData[series.xSeries].position.length || positionNext.length != this.roomAuxData[series.xSeries].positionNext.length){
                                    console.log('Error: the number of athletes jumping on the current height was calculated differently by this browser than given by the data from the server. This should not happen. Please report the constellation, where this happened, to the developers.')
                                }
                                this.positionNext = this.roomAuxData[series.xSeries].positionNext.slice(); // we use slice to create a copy!
                                this.position = this.roomAuxData[series.xSeries].position;

                                this.currentHeight = this.roomAuxData[series.xSeries].currentHeight;
                                this.currentJumpoffHeightInd = this.roomAuxData[series.xSeries].currentJumpoffHeightInd;
                                this.attempt = this.roomAuxData[series.xSeries].attempt;
                                this.attemptNext = this.roomAuxData[series.xSeries].attemptNext;

                            } else {
                                // writing client. Set position and positionNext. If they have changed, send the changes to the server.
                                if (JSON.stringify(this.position) != JSON.stringify(position) || JSON.stringify(this.positionNext) != JSON.stringify(positionNext) || this.roomAuxData[series.xSeries].currentHeight != this.currentHeight || this.roomAuxData[series.xSeries].currentJumpoffHeightInd != this.currentJumpoffHeightInd || this.roomAuxData[series.xSeries].attempt != this.attempt || this.roomAuxData[series.xSeries].attemptNext != this.attemptNext) {
                                    this.autoManageAuxData(false);
                                    this.roomAuxData[series.xSeries].positionNext = positionNext;
                                    this.roomAuxData[series.xSeries].position = position;

                                    // additionally propagate the following properties to all clients (this is especially needed when the site is reloaded after the result is entered, but before it is advanced to the next athlete. Then, the current height and attempt would reference to the next height, while the position arrays still reference the last jump on the previous height, as intended.)
                                    this.roomAuxData[series.xSeries].currentHeight = this.currentHeight;
                                    this.roomAuxData[series.xSeries].currentJumpoffHeightInd = this.currentJumpoffHeightInd;
                                    this.roomAuxData[series.xSeries].attempt = this.attempt;
                                    this.roomAuxData[series.xSeries].attemptNext = this.attemptNext;

                                    // send the changed data to the server
                                    rCTech.room.updateAuxDataInit(this.roomAuxData);
                                }
                                this.position = position;
                                this.positionNext = positionNext;
                            }
                        }


                        // make sure the ordering is updated (needed at least when the ordering is set to ranking)
                        this.fakeProperty++;

                    } else {
                        // show: not all athletes have a startheight
                        this.mode = 0;
                        this.position = [];
                        this.positionNext = [];
                    }

                    // since calculateNextAthlete is called whenever something has changed, we can also start updating height-deleable.status from here 
                    this.evaluateHeightDeletable()
                },
                /*                getCurrentAthletesHeight(autoAddHeight = true, sendChangeToServer=false){
                    // find the seriesStart of the current athlete and the result for the current height. If this result does not exist yet and autoAddHeight=true, it will automatically be generated with initialization values. Returns undefined when either the athlete does not exist or the height was not found and autoAddHeight=false
                    // if sendChangeToServer

                    let series = this.series[this.selectedSeries];

                    let start = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart==this.position[this.positionNext[0]])
                    if (!start){
                        alert('Error: Could not find athlete, which should never happen.')
                        return undefined;
                    }

                    // find the xHeight of the current height
                    let hEl = series.heights.find(h=>h.height==this.currentHeight && h.jumpoffOrder==0);
                    // find the height-result-element
                    let h = start.resultshigh.find(el=>el.xHeight==hEl.xHeight)
                    if (!h){
                        if (autoAddHeight){
                            h = {
                                xResult: this.xResultTemp--,
                                xHeight: hEl.xHeight,
                                resultsHighFailedAttempts: 0, // how many fails on this hight
                                resultsHighValid: false, 
                                resultsHighPassed:false // verzichtet (-)
                            };
                            start.resultshigh.push(h);
                        }else{
                            return undefined;
                        }
                    }
                    return h;

                },
                failed(){
                    // current athlete failed: 
                    // increase the failed counter on the current height
                    let h = this.getCurrentAthletesHeight();
                    h.resultsHighFailedAttempts++;

                    // if the number fo failures is 3 now, remove the athlete from the position array
                    this.calculateNextAthlete();
                },
                cleared(){
                    // current athlete cleared the height
                    // note this in the result data
                    let h = this.getCurrentAthletesHeight();
                    h.resultsHighValid = true;

                    // remove the athlete from the position array

                    this.calculateNextAthlete();
                },
                passed(){
                    // current athlete passes this height
                    // write to results
                    let h = this.getCurrentAthletesHeight();
                    h.resultsHighPassed = true;

                    // remove the athlete from the position array

                    this.calculateNextAthlete();
                },*/
                addResultToCurrent(res){
                    // res must be either passed, failed or cleared
                    // find the seriesStart of the current athlete and the result for the current height. If this result does not exist yet, it will automatically be generated. 
                    // if sendChangeToServer

                    let series = this.series[this.selectedSeries];

                    let start = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart==this.position[this.positionNext[0]])
                    if (!start){
                        alert('Error: Could not find athlete, which should never happen.')
                        return undefined;
                    }

                    // find the xHeight of the current height
                    let hEl = series.heights.find(h=>h.height==this.currentHeight && h.jumpoffOrder==0);
                    // find the height-result-element
                    let h = start.resultshigh.find(el=>el.xHeight==hEl.xHeight)
                    let isNew = false;
                    if (!h){
                        isNew = true;
                        h = {
                            xResult: start.xSeriesStart,  // this is actually the xSeriesStart
                            xHeight: hEl.xHeight,
                            resultsHighFailedAttempts: 0, // how many fails on this hight
                            resultsHighValid: false, 
                            resultsHighPassed:false // verzichtet (-)
                        };
                        start.resultshigh.push(h);
                    }
                    
                    // add the actual result:
                    if (res=='passed'){
                        h.resultsHighPassed = true;
                    } else if (res=='cleared'){
                        h.resultsHighValid = true;
                    } else if (res=="failed"){
                        h.resultsHighFailedAttempts += 1;
                    }

                    // send change:
                    if (isNew){
                        rCTech.room.addResultInit(h, start);
                    } else {
                        rCTech.room.updateResultInit(h, start);
                    }

                },
                failed(){
                    // current athlete failed: 
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('failed');
                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        this.calculateNextAthlete();
                    }else{
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();
                },
                cleared(){
                    // current athlete cleared the height
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('cleared');

                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        this.calculateNextAthlete();
                    } else {
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();
                },
                passed(){
                    // current athlete passes this height
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('passed');

                    // remove the athlete from the position array
                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        this.calculateNextAthlete();
                    }else{
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();
                },
                clearedJumpoff(){
                    let xSeriesStart = this.position[this.positionNext[0]];
                    let jumpoffOrder = this.currentJumpoffHeightInd;
                    this.setJumpoffResult(xSeriesStart, jumpoffOrder, true)
                },
                failedJumpoff(){
                    let xSeriesStart = this.position[this.positionNext[0]];
                    let jumpoffOrder = this.currentJumpoffHeightInd;
                    this.setJumpoffResult(xSeriesStart, jumpoffOrder, false)
                },
                setJumpoffResult(xSeriesStart, jumpoffOrder, cleared){
                    // define the jumpoffResult at a certain jumpoff height of the given athlete (xSeriesStart)

                    // get the athlete
                    let series = this.series[this.selectedSeries];

                    let start = series.seriesstartsresults.find((el)=>{return el.xSeriesStart == xSeriesStart;});
                    if (!start){
                        alert("ERROR: could not find the athlete. Should never happen...");
                        return;
                    }

                    // get the height element
                    let hEl = series.heights.find(h=>h.jumpoffOrder==jumpoffOrder);
                    if (!hEl){
                        alert("ERROR: could not find the height entry. Should never happen...");
                        return;
                    }

                    let resEl = start.resultshigh.find(el=>el.xHeight==hEl.xHeight);
                    if (!resEl){
                        // add the result element
                        resEl = {
                                xResult: start.xSeriesStart, // this is actually the xSeriesStart
                                xHeight: hEl.xHeight,
                                resultsHighFailedAttempts: 0, // how many fails on this hight
                                resultsHighValid: false, 
                                resultsHighPassed:false // verzichtet (-)
                            };
                        start.resultshigh.push(resEl);
                    }
                    if (cleared){
                        resEl.resultsHighValid = true;
                        resEl.resultsHighFailedAttempts = 0;
                    }else{
                        resEl.resultsHighValid = false;
                        resEl.resultsHighFailedAttempts = 1;
                    }

                    // send change:
                    rCTech.room.addResultInit(resEl, start);


                    this.calculateNextAthlete();

                },
                //{{getHeight(res.xHeight)}}: {{resToStr(res)}}
                getHeight(xHeight){
                    // get the height formatted as a string (2.10m) for the given xHeight
                    let h = this.series[this.selectedSeries].heights.find(el=>el.xHeight==xHeight);
                    if (h){
                        let hCalc = (h.height/100).toFixed(2);
                        // add a J in front of the height when it is a jumpoff height
                        if (h.jumpoffOrder>0){
                            return '<%= __("J:") %>' + hCalc + ' m';
                        } else {
                            return hCalc + ' m';
                        }
                    }else {
                        return 'Error';
                    }
                },
                resultToStr(res){
                    let resStr = 'X'.repeat(res.resultsHighFailedAttempts);
                    if (res.resultsHighValid){
                        resStr += 'O';
                    }else if (res.resultsHighPassed){
                        resStr += '-'
                    }
                    return resStr;
                    },
                    strToResult(resStr, showAlert=false, jumpoff=false){
                    resStr = resStr.toUpperCase();
                    failedCount = 0;
                    valid = false;
                    passed = false;
                    for (let i=0;i<resStr.length;i++){
                        let c = resStr.charAt(i);
                        if (c=='X'){
                            failedCount++
                        } else if (c=='O'){
                            valid = true;
                        } else if (c=='0'){
                            valid = true;
                        } else if (c=='-'){
                            passed = true;
                        } else {
                            if (showAlert){
                                alert(c + " " + "<%= __(' is not a valid character. It is ignored.') %>")
                            }
                        }
                    }

                    // do some checks:
                    // at max one:
                    if (!jumpoff){
                        // normal
                        if (valid + passed + (failedCount==3) > 1){
                            return false;
                        }
                        if (failedCount>3){
                            return false;
                        }
                    }else{
                        // jumpoff
                        if (valid + passed + failedCount > 1){
                            return false;
                        }
                    }

                    return {
                        resultsHighFailedAttempts: failedCount, // how many fails on this hight
                            resultsHighValid: valid, 
                            resultsHighPassed: passed
                    }

                    /*{
                        xResult:1,
                        xHeight: 1, // the link to the height!
                        //resultshighSortOrder, // not needed!, the current position (temporary different athlete order) is handled differently
                        resultsHighFailedAttempts: 1, // how many fails on this hight
                        resultsHighValid: true, 
                        resultsHighPassed:false // verzichtet (-)
                    },*/
                },
                onPositionMovingEnded(evt){
                    if (evt.oldIndex!=evt.newIndex){
                        // on position change, we have to recalculate the next athlete (and the positionNext array.)
                        this.calculateNextAthlete()
                    }

                    // since this.position is already changed, calculateNextAthlete will not detect any change and will therefore also not realize, that it should send the new changes auxData to the server. Therefore, we do it manually here 
                    this.roomAuxData[this.selectedXSeries].positionNext = this.positionNext;
                    this.roomAuxData[this.selectedXSeries].position = this.position;

                    // send the changed data to the server
                    rCTech.room.updateAuxDataInit(this.roomAuxData);

                },
                saveCurrentResChange(start){
                    /*let el = document.getElementById('resChange' + this.currentResultChange.xResult);
                    //let el = document.getElementById('resChange');
                    if (el==undefined){
                        alert('ERROR: cound not find the html-element of the result change. Should actually never happen. ');
                        return;
                    }*/

                    // if the string is empty, delete the result completely, otherwise, just alter it
                    if (this.currentResultString==''){
                        
                        rCTech.room.deleteResultInit(this.currentResultChange, start)

                        // recalculate the next athlete
                        this.calculateNextAthlete();

                    }else if (this.currentResultString != this.currentResultStringCopy){

                        // get the height element to find out whether it is a jumpoff-height
                        let hEl = this.series[this.selectedSeries].heights.find((el)=>{return el.xHeight==this.currentResultChange.xHeight})
                        if (!hEl){
                            alert('ERROR: could not find the height corresponding to the ')
                        }

                        let raw = this.strToResult(this.currentResultString, false, hEl.jumpoffOrder>0)

                        if (raw){
                            // transfer the changes to the actual result
                            this.currentResultChange.resultsHighPassed = raw.resultsHighPassed;
                            this.currentResultChange.resultsHighValid = raw.resultsHighValid;
                            this.currentResultChange.resultsHighFailedAttempts= raw.resultsHighFailedAttempts;

                            rCTech.room.updateResultInit(this.currentResultChange, start)

                            // recalculate the next athlete
                            this.calculateNextAthlete();
                        }else{
                            alert("<%= __('The entered result is invalid. The previous value is restored.') %>")
                        }
                    }
                    // leave the result change mode:
                    this.currentResultChange = {};
                },
                getNewHeigthsByXSeriesStart(start){
                    // returns an array of objects with the additional heights for the given athlete (i.e. all heights except those where a result already exists)

                    // start with the allHeights array and delete all heights that already have a result
                    let hRed = this.allHeights.slice();
                    let maxHeightInResults = 0;
                    // loop over the present results
                    start.resultshigh.forEach(hEl=>{
                        // get the height for the hEl
                        let h = this.series[this.selectedSeries].heights.find(el=>el.xHeight==hEl.xHeight) 
                        if (!h){
                            alert('ERROR: height reference is broken! Should never happen.');
                            return [];
                        }
                        // get the index of the element in the hRed array
                        let ind = hRed.indexOf(h.height);
                        if (ind>=0){
                            // remove the element
                            hRed.splice(ind,1);
                        }
                        if (maxHeightInResults < h.height){
                            maxHeightInResults = h.height;
                        }
                    })

                    // define which height should be preselected:
                    // usually: find out which height is the next height of the athlete
                    // if the athlete has no result yet: the startheight
                    // if there is no startheught yet: the first element
                    let indNextHeight = -1;

                    if (maxHeightInResults){
                        // has already a result; get the next height
                        //find the maxHeight in the allHeight
                        let i = this.allHeights.indexOf(maxHeightInResults);
                        let nextHeight = this.allHeights[i+1];
                        
                        let nextHeightIndex = hRed.indexOf(nextHeight); // the next index should be selected
                        if (nextHeightIndex>=0){
                            indNextHeight = nextHeightIndex;
                        }
                    } else if (start.startConf) {
                        let i = hRed.indexOf(start.startConf); 
                        if(i>=0){
                            indNextHeight = i;
                        }
                    }
                    // no elmeent was found:
                    if (indNextHeight<0){
                        indNextHeight = 0;
                    }

                    // now process every element in hRed and transform it into the appropriate object
                    for (let i=0; i<hRed.length; i++){
                        hRed[i] = {
                            value: hRed[i],
                            text: hRed[i],
                            next: i==indNextHeight
                        }
                    }

                    // TODO: how to handle the jumpoff? This is anyway difficult as a lot is different (e.g. only one attempt per height)

                    return hRed;
                },
                addResultBlur(start, $event){
                    if (this.resultKeyPressed!=27){
                        this.addResult(start);
                    }
                    this.resultKeyPressed = -1;
                },
                addResult(start){

                    // add a result 
                    let valEl = document.getElementById('newResultValue' + start.xSeriesStart);
                    let heightEl = document.getElementById('newResultHeight' + start.xSeriesStart);

                    if (valEl.value!=''){
                        // first try to parse the entered result string
                        let resParsed = this.strToResult(valEl.value);
                        if (!resParsed){
                            // TODO: what shall be reverted
                            alert("<%= __('The entered result is invalid. Saving is aborted.') %>")
                            return;
                        }

                        // check that the result is also reasonable together with the previous results:
                        // - not more than 2 failed attempts in a row
                        // - athlete was not finished before already
                        // - not nothing
                        if (this.tempRankingData[start.xSeriesStart].finished ){
                            alert("ERROR: the athlete is already finished! Actually you should not even be able to enter a result.");
                            valEl.value = '';
                            return;
                        }

                        if (this.tempRankingData.failedAttemptsSinceLastValid + resParsed.resultsHighFailedAttempts + resParsed.resultsHighPassed + resParsed.resultsHighValid>3){
                            // TODO: 
                            alert("<%= __('The entered result is invalid, as the number of failed attempts since the last valid jump is >3. Saving is aborted.') %>")
                            valEl.value = '';
                            return;
                        }
                        if (resParsed.resultsHighFailedAttempts + resParsed.resultsHighPassed + resParsed.resultsHighValid==0){
                            // TODO: 
                            alert("<%= __('The entered result is invalid, as neither passed, nor valid nor a failed attempt was entered. Saving is aborted.') %>")
                            valEl.value = '';
                            return;
                        }

                        // get the xHeight for the selected height (if it exists)
                        let hEl = this.series[this.selectedSeries].heights.find(el=>el.height == heightEl.value && el.jumpoffOrder==0)
                        if (!hEl){
                            this.addHeight(heightEl.value)
                            hEl = this.series[this.selectedSeries].heights.find(el=>el.height == heightEl.value && el.jumpoffOrder==0)
                        }
                        let res = {
                            xResult: start.xSeriesStart,
                            xHeight: hEl.xHeight,
                            resultsHighFailedAttempts: resParsed.resultsHighFailedAttempts, // how many fails on this hight
                            resultsHighValid: resParsed.resultsHighValid, 
                            resultsHighPassed: resParsed.resultsHighPassed // verzichtet (-) 
                        };
                        start.resultshigh.push(res)

                        // send the change to the server
                        rCTech.room.addResultInit(res, start);

                        // recalculate the next athlete. This will also update the tempRankingData, which is needed below  
                        this.calculateNextAthlete();

                        // reset the field 
                        valEl.value = '';
                        // define the new focus:
                        if (this.tempRankingData[start.xSeriesStart].finished){
                            // focus the next athletes field, where the athletes results
                            // i= index of the current athlete
                            let i = this.sortedStarts1.findIndex(el=>start.xSeriesStart==el.xSeriesStart);
                            for (let j=i+1;j<this.sortedStarts1.length;j++){
                                // check if the athlete is not finished yet
                                if (!this.tempRankingData[this.sortedStarts1[j].xSeriesStart].finished){
                                    document.getElementById('newResultValue'+this.sortedStarts1[j].xSeriesStart).focus();
                                    break;
                                }
                            }
                        }else{
                            // focus the same element again
                            valEl.focus();
                        }
                    }



                // is the height automatically removed from the heights options dropdown? Otherwise make Vue reload in some way.

                },
                changeResult(res){
                    this.currentResultChange=res;

                    // create a copy of the current result-string. If we are not doing it this way, the value of the html-element will instantly be changed back to the original value, before blur actually hits and we can store the changed result. Additionally, it allows not to raise an update event when there was no change.
                    let resStr = this.resultToStr(res);
                    this.currentResultString = resStr;
                    this.currentResultStringCopy = resStr;

                    // set the focus: problem: when the element is still hidden, it cannot get the focus. And Vue will change the hidden status with a slight delay (either just asynchronous or indeed with a delay), thus we also have to implement some delay here:
                    setTimeout(()=>{document.getElementById('resChange' + res.xResult).focus();}, 1) // time in ms (1 ms so far seems to be enough, 3-2020)
                    //document.getElementById('resChange' + res.xResult).focus();
                    //document.getElementById('resChange').focus();
                },
                sortedResults(results){
                    // sort the results by height /to make it look nice

                    let sortingFailed = false;
                    // create an array copy, in order not to sort the original array
                    let resCopy = [...results].sort((resA,resB)=>{
                        // get the height for both results
                        let hA = this.series[this.selectedSeries].heights.find(h=>h.xHeight==resA.xHeight);
                        let hB = this.series[this.selectedSeries].heights.find(h=>h.xHeight==resB.xHeight);
                        if (hA==undefined || hB==undefined){
                            this.logger.log(20, `Could not sort the result-array. Returning the unsorted array.`);
                            sortingFailed = true;
                            return 0;
                        } else {
                            return hA.height-hB.height;
                        }
                    })
                    if (sortingFailed){
                        return results;
                    } else {
                        return resCopy;
                    }
                },
                seriesStatusChanged(){

                    // send the change to the server
                    rCTech.room.updateSeriesInit(this.series[this.selectedSeries]);
                },
                startPeriod(){
                    // current time:
                    let dHere = new Date();
                    // this difference is incorrect by the ping duration. This is considered acceptable. The timeOffset is meant to correct time differences between the server and this client and not the ping. 
                    let dServer = new Date(dHere.valueOf()+this.timeOffset);

                    // since the time we store shwll be the virtual time on the server when the period is started, we have to correct it with the offset this client has to the server:

                    this.roomAuxData[this.selectedXSeries].periodStartTime = dServer;
                    rCTech.room.updateAuxDataInit(this.roomAuxData);

                    // make the time being updated regularly
                    this.timeUpdateInterval = setInterval(this.updateShownTime, 100);
                },
                hidePeriod(){

                    this.stopPeriod(false);
                    
                    if (!this.readOnly){
                        this.roomAuxData[this.selectedXSeries].showAttemptPeriod = false;
                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                },
                stopPeriod(sendChange=true, setNull=true){
                    if (this.timeUpdateInterval){
                        clearInterval(this.timeUpdateInterval);
                        this.timeUpdateInterval = undefined;

                        // do not set to null to keep the time at 0:00
                        if (setNull){
                            this.roomAuxData[this.selectedXSeries].periodStartTime = null;
                        }
                        if (sendChange && !this.readOnly){
                            rCTech.room.updateAuxDataInit(this.roomAuxData);
                        }
                    }
                },
                updateShownTime(){
                    // show the time of the current competitor
                    let aux = this.roomAuxData[this.selectedXSeries];
                    let minutes = 0;
                    let seconds = 0;
                    let remainingTime = 0;
                    if (aux?.periodStartTime){
                        // time is running
                        // first, calculate the remaining time.
                        let dStart = new Date(aux.periodStartTime);
                        let dNow = new Date();

                        // a positive timeOffset means that the server time (what dStart is based on) is ahead of the time on this client.
                        let milliSecondsPassed = dNow.valueOf()-(dStart.valueOf()-this.timeOffset);
                        remainingTime = aux.attemptPeriod-milliSecondsPassed/1000;
                        if (remainingTime<0){
                            if (this.timeUpdateInterval){
                                // do not set periodStartTime to null, to ensure that the time is not hidden. 
                                this.stopPeriod(true, false);
                            };
                            minutes = 0;
                            seconds = 0; 
                        }else {
                            minutes = Math.floor(remainingTime/60);
                            seconds = Math.floor((remainingTime-60*minutes));
                        }
                    } else {
                        // time is stopped and eventually not existing
                        minutes = Math.floor(aux.attemptPeriod/60);
                        seconds = Math.floor((aux.attemptPeriod-60*minutes));
                    }
                    this.shownTime = minutes.toString() + ":" + seconds.toString().padStart(2,0);
                    this.last15 = minutes*60+seconds<=15;

                    return remainingTime > 0;
                    
                },
            },
            watch:{
                selectedSeries: function(newSeries, oldSeries){
                    // since calculate next athlete does not itself lower the mode we reset it here and then call calculateNextAthlete:
                    this.mode = 0;
                    this.calculateNextAthlete();
                },
                contestWatching: {
                    // we cannot directly watch contest, because if the changes were within the object, the oldContestObj would reference the same as newContestObj. However, the contestWatching property is always a new copy and thus new and old should be correct
                    // (The alternative would be to have watchers for each property that might change, e.g. 'contest.status', ...)

                    // this is how we watch changes not only of the property "contest", but of all the properties within it:
                    deep:true,
                    handler: function(newContestObj, oldContestObj){
                        // harmonized over all changes on the contest properties
                        // TODO: problem: if the full contest data is changed (e.g. after the room gets the first data or after full reload), this watch event is raised as well, which is problematic...
                        // send the request to the server. On positive return, nothing will be done. If negative, all changes from that point on will have to be reverted.
                        if (this.propagateChange){
                            rCTech.room.updateContest2Init(newContestObj, oldContestObj);
                            this.propagateChange = false;
                        }
                    }
                },
            },
            computed:{

                
                /* !!! properties for SERIES CREATION and COMPETITION !!! */

                contestWatching: function(){
                    // create a copy of the contest object to make sure that newContestObj and oldContestObj in the contest(Watching)-watcher are truly the old and new object, and not the same. 
                    return JSON.parse(JSON.stringify(this.contest));
                },
                conf: function(){
                    return this.parseConf(this.contest.conf);
                },
                filters: function(){
                    // create a custom filter for everything that filters by name, first name and bib at the same time. (club would be nice, but is not possible with the builtin-filters, since the club would have to be part of the object structure, but only the xClub is, but not the clubs and its name.) 
                    
                    // split the input string by whitespace
                    let filterWords = this.filterAthletes.split(" ");

                    // every word may be part of every of the four columns
                    let filter = {};
                    let i=1;
                    for (let filterWord of filterWords){
                        filter["filter" + i] = {keys:['athleteName', 'athleteForename', 'bib', 'sex, clubName', 'country'], value:filterWord} //
                        i += 1;
                    }
                    return filter;

                },

                seriesAsStartgroups: function(){
                    // "copy" the series and its seriesstartsresults (as startgroup)
                    let seriesAsStartgroups = [];
                    for (let i=0;i<this.series.length; i++){

                        let series = this.series[i];
                        
                        // add the other data of the series, for informational purposes only! A change to those is useless.
                        let seriesCopy = copyObject(series); // seriesstartsresults is actually already added here, but will be deleted again:

                        // get the startgroup for every seriesstartsresult
                        let SSRs = [];
                        series.seriesstartsresults.forEach(ssr=>{
                            // create a copy of the ssr
                            let ssrCopy = copyObject(ssr);
                            // find the startgroup for the respective seriesstartsresult and add it to the list
                            let startgroup = this.startgroups.find(SG=>SG.xStartgroup == ssr.xStartgroup)
                            if (startgroup){
                                ssrCopy.startgroup = startgroup;
                                ssrCopy.ssrOriginal = ssr;
                            } else {
                                console.log('Error: could not find xStartgroup of an assigned athlete. This data inconsistency should not occure. Try to fully reload the auxilary data.')
                            }

                            // reference the original (!) 'parent'; avoids that xSeries has to be defined to be used in "changePosition"
                            ssrCopy.series = seriesCopy;
                            ssrCopy.seriesOriginal = series;

                            SSRs.push(ssrCopy)
                        })
                        
                        seriesCopy.seriesstartsresults= SSRs;
                        seriesCopy.seriesOriginal = series;
                        seriesAsStartgroups.push(seriesCopy);
                    }

                    // sort the series
                    seriesAsStartgroups.sort((a,b)=>{
                        return a.number-b.number;
                    })
                    // sort the seriesstartsresults
                    seriesAsStartgroups.forEach(series=>{
                        series.seriesstartsresults.sort((a,b)=>{
                            return a.position-b.position;
                        })
                    })

                    return seriesAsStartgroups;
                },


                /* !!! properties for SERIES CREATION only !!! */

                // to move around the atheletes e.g. from non-assigned to series we have to work on the startgroups. Create an array with all unassigned startgroups (unassignedAthletes) and one for every series with the same info (seriesAsStartgroups). 

                unassignedAthletes: function(){
                    // create an array of all unassigned athletes, including those with present=false
                    // first copy the full list of startsingroups
                    let unassignedAthletes = this.startgroups.slice(); //map(el=>el.xStartgroup);

                    // remove all entries which are references in a series
                    for (let i=0; i<this.series.length; i++){
                        this.series[i].seriesstartsresults.forEach((el, seriesIndex)=>{
                            let ind = unassignedAthletes.findIndex(el2=> el.xStartgroup==el2.xStartgroup);
                            if (ind<0){
                                console.log('Error: could not find xStartgroup of an assigned athlete. This data inconsistency should not occure. Try to fully reload the auxilary data.')
                            } else {
                                // remove the startgroups
                                unassignedAthletes.splice(ind,1);
                            }
                        })
                    }
                    return unassignedAthletes;
                },
                
                seriesAssignmentOverlay: function(){
                    // show the configuration of the currently selected series assignment algorithm
                    return this.seriesAssignments[this.selectedSeriesAssignment].overlayName;
                },

                /* !!! properties for COMPETITION only !!! */

                selectedXSeries: function(){
                    if (this.series.length>0){
                        return this.series[this.selectedSeries].xSeries;
                    }
                    return undefined;
                },
                auxData: function(){
                    // change the xStartgroup array to an object with objects, where xStartgroup is the key
                    let auxData = {};
                    auxData.xStartgroup = {};
                    this.startgroups.forEach(el=>{
                        auxData.xStartgroup[el.xStartgroup]=el;
                    })
                    return auxData;
                },
                currentAthleteStart: function(){
                    return this.getStartByXSeriesStart(this.position[this.positionNext[0]]);
                },
                nextAthleteStart: function(){
                    if (this.positionNext.length>1){
                        return this.getStartByXSeriesStart(this.position[this.positionNext[1]]);
                    }else{
                        return undefined;
                    }
                },
                sortedStarts1: function(){
                    let i = this.fakeProperty; // just to make sure sortedStarts gets updated on rank changes
                    // TODO
                    //return this.series[this.selectedSeries].seriesstartsresults;

                    // we cannot just sort the seriesstartsresults-array as this would also change the order at several different places (especially the algorithm for 'the next athlete sequence' might not work anymore!)                            

                    // create an array with all array-indexes (0 to length-1) of the seriesstartsresults array; (the initialized elements are empty first and map only uses non-empty fields. Thus we first fill with undefined and then create in indices)
                    let order = Array(this.series[this.selectedSeries].seriesstartsresults.length).fill(undefined).map(function (x, i) { return i; })

                    let compareFn = (a,b)=>{a-b} // fallback
                    if (this.sortValue1 == 1){
                        // default sequence
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            return A.position - B.position
                        }
                    } else if (this.sortValue1 == 2){
                        // sort by rank
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let rA = this.tempRankingData[A.xSeriesStart].rank;
                            let rB = this.tempRankingData[B.xSeriesStart].rank;
                            if (rA==0 && rB==0){
                                // both have no rank yet: sort by default order
                                return A.position - B.position;
                            } else if (rA==0){
                                // A must be lower than B
                                return 1;
                            } else if (rB==0){
                                // B must be lower than A
                                return -1;
                            } else {
                                // sort by rank
                                return rA-rB;
                            }
                        }
                    } else if (this.sortValue1 == 3){
                        // sort by name
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];

                            return (auxA.athleteName + auxA.athleteForename).localeCompare(auxB.athleteName + auxB.athleteForename);
                        }
                    } else if (this.sortValue1 == 4){
                        // sort by bib
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];
                            
                            return auxA.bib - auxB.bib;
                        }
                    }
                    order.sort(compareFn);

                    return order;

                },
                sortedStarts2: function(){
                    let i = this.fakeProperty; // just to make sure sortedStarts gets updated on rank changes

                    // we cannot just sort the seriesstartsresults-array as this would also change the order at several different places (especially the algorithm for 'the next athlete sequence' might not work anymore!)                            

                    // create an array with all array-indexes (0 to length-1) of the seriesstartsresults array; (the initialized elements are empty first and map only uses non-empty fields. Thus we first fill with undefined and then create in indices)
                    let order = Array(this.series[this.selectedSeries].seriesstartsresults.length).fill(undefined).map(function (x, i) { return i; })

                    let compareFn = (a,b)=>{a-b} // fallback
                    if (this.sortValue2 == 1){
                        // default sequence
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            return A.position - B.position
                        }
                    } else if (this.sortValue2 == 2){
                        // sort by rank
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let rA = this.tempRankingData[A.xSeriesStart].rank;
                            let rB = this.tempRankingData[B.xSeriesStart].rank;
                            if (rA==0 && rB==0){
                                // both have no rank yet: sort by default order
                                return A.position - B.position;
                            } else if (rA==0){
                                // A must be lower than B
                                return 1;
                            } else if (rB==0){
                                // B must be lower than A
                                return -1;
                            } else {
                                // sort by rank
                                return rA-rB;
                            }
                        }
                    } else if (this.sortValue2 == 3){
                        // sort by name
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];

                            return (auxA.athleteName + auxA.athleteForename).localeCompare(auxB.athleteName + auxB.athleteForename);
                        }
                    } else if (this.sortValue2 == 4){
                        // sort by bib
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];
                            
                            return auxA.bib - auxB.bib;
                        }
                    }
                    order.sort(compareFn);

                    return order;

                },
                currentJumpoffHeight: function(){
                    // in the jumpoff, we define the current height based on the jumpoffOrder; but we also need to show the height in m
                    let hEl = this.series[this.selectedSeries].heights.find(el=>el.jumpoffOrder==this.currentJumpoffHeightInd)
                    if (hEl){
                        return this.meterStr(hEl.height);
                    } else {
                        return 0;
                    }

                },
                resultGridTemplate: function(){

                    // make sure the resultGridTemplate is updated when the xHeight is exchanged
                    let i = this.fakeProperty;

                    let h = this.series[this.selectedSeries].heights;
                    let s = '[rank] max-content [bib] max-content [athletes] max-content';
                    for (let i=0;i<h.length;i++){
                        s += ' [h' + h[i].xHeight + '] max-content'; /* the label for the line must not be a number, but a string */
                    }
                    s += ' [end]';
                    return s;
                },
                disciplineConfiguration: function(){
                    // get the first discipline with matching baseDiscipline and parse its configuration
                    let d = this.disciplines.find(d=>d.xBaseDiscipline==this.contest.xBaseDiscipline);
                    if (!d){
                        return {heightMax:800, jumpoffHeightVariation:2};
                    } else {
                        let o = JSON.parse(d.configuration);
                        o.heightMax = o.heightMax ?? 800;
                        o.jumpoffHeightVariation = o.jumpoffHeightVariation ?? 2;
                        return o;
                    }
                },
                resultOnCurrentHeight: function(){
                    // get the result of the athlete in the current attempt. This function will only return a non-null value when the currentAthlete has already jumped on the height. This only happens when autoAdvance=false and the writing client has not pressed "advance" yet (i.e. calculateNextAthlete was not yet run) 
                    // returns the result as a string (O, X, -) or False (when no result yet)

                    let x = this.fakeProperty;

                    // first get the xHeight
                    let xHeight = this.series[this.selectedSeries].heights.find(h=>h.height == this.currentHeight)?.xHeight;
                    if (!xHeight===undefined){
                        return false;
                    }
                    // check whether there is already a result for the current athlete on the current height
                    let res = this.currentAthleteStart.resultshigh.find(r=>r.xHeight==xHeight);
                    if (res==undefined){
                        return false;
                    }
                    if (this.attempt == res.resultsHighFailedAttempts){
                        return 'X';
                    }
                    if (res.resultsHighPassed){
                        return '-';
                    }
                    if (res.resultsHighValid){
                        return 'O';
                    }
                    return false;
 
                },

            },
            beforeMount(){
                // work on data before it is showed the first time
                // moved to when the data arrives
/*                this.createAllHeights();
                this.evaluateHeightDeletable();*/
            },
            mounted:function(){
                // initialize all series assignments
                this.seriesAssignments.forEach((SA)=>{
                    SA.initFunc.bind(this)();
                })
                
            },
            components:{
                'draggable': vuedraggable,
                'v-table':VTable,
                'v-th': VTh,
                'v-tr':VTr,
            },
        }

        vueSeriesAdminTech = Vue.createApp(vueAppConfig).mount('#vueSeriesAdminTech')

        // load the room:
        let ms = getMeetingShortname();

        // get the GET-parameter xContest (null if not found)
        let xContest = findGetParameter('xContest')
        
        //xContest = 3; // TODO: delete

        if (xContest!=null && !isNaN(xContest)){
            xContest = Number(xContest)
            // start the roomClientView
            rCTech = new vuContestTech(vueSeriesAdminTech, ms, xContest);
        } else {
            // eventually show a message that there is no  
        }

    }

</script>

<div id="vueSeriesAdminTech">
    <!--
    TODO: initially create the series in an overlay or not: 
        pro: 
            - reduces the number of changes sent over the network
            - the spectators anyway do not need to see it, when it is done.
        contra:
            - we either need separate functions where we still have the single changes separately OR the server must find the changes between the series before and after and then translate this to single changes. This would mean additional programming effort. 
        think about which functions should exist and what they should do and find a simple solution: 
        - addSeriesAndAthletes: This is made only for the initial series definition; add series and set seriesStartsResults where xStartgroup =...; athletes must not have had a previous series assignment!
        - addSeries: simply add a series; do not assign any athletes yet
        - assignAthlete: assign an athlete to a series (it is either a ); automatically delete it from possible prevoious series; always check first that there were no results!
        - resignAthlete: delete seriesStartResult for a certain athelete, i.e. it can be reassigned again later
        - deleteSeries: delete a series and all athletes (=all seriesStartsResult entries for this series); only if there were no results yet
        - changeSeries: change a property of the series (Name, time, ...), but not the athletes of it
        - reorderSeries: might be needed, especially when we swap series and we have a constrain, that every seriesindex shall exist only once -> then we need that both indices are changed at the same time.

    simple: assigning positions 

    difficulties: assignment of equal lanes to multiple persons in 600m/800m
    idea: two step approach: first define the series and the positions, then provide a button/function to automatically create lanes from the positions. This shall be shown in textfields, which can also be manually overriden.
    The hole function should probably be accessible on request, while otherwise lane=position and no textfield for the lane is shown. (show yes/no slider for lane=position)-->
    <h1>{{disciplines.find(d=>d.xBaseDiscipline==contest.xBaseDiscipline)?.name}} {{formatTime(contest.datetimeStart)}} </h1>
    <!-- TODO: put the following together with the table in a collapsable tool.-->
    <label>
        <%= __("Show contest infos") %>
        <input type="checkbox" v-model="showContestInfo">
    </label> <br>
    <div v-if="showContestInfo">
        <div style="display: inline-block; margin: 3px;"><%= __('Appeal time') %>: {{formatTime(contest.datetimeAppeal)}}</div><div style="display: inline-block; margin: 3px;"><%= __('Call time') %>: {{formatTime(contest.datetimeCall)}}</div>
    
        <!--Contest: {{contest.xContest}}<br>-->
        <br>
        <table>
            <th>
                <tr>
                    <td><%= __("Events") %><br><%= __("Category (info)") %></td>
                    <td v-if="developMode">xEventGroup</td>
                    <td><%= __("Eventgroup name") %></td>
                    <td v-if="developMode">xRound</td>
                    <td><%= __("Round name") %></td>
                    <td><%= __("Round order") %></td>
                    <td><%= __("Group name") %></td>
                    <td><%= __("Group order") %></td>
                </tr>
            </th>
            <template v-for="rG in relatedGroups">
                <tr>               
                    <td>
                        <template v-for="(event, eventIndex) in rG.round.eventgroup.events">
                            <br v-if="eventIndex>0">
                            {{getCategory(event.xCategory)}}
                            <div style="display: inline;" v-if="event.info">({{event.info}})</div>
                            <div style="display: inline;" v-if="developMode">{{event.xEvent}}<div>
                            <!-- for throws with different weights in the same contest  -->
                            <!--{{disciplines.find(d=>d.xDiscipline==event.xDiscipline)?.shortname}}-->
                        
                        </template>
                        <!--<table>
                            <template v-for="event in rG.round.eventgroup.events">
                                <tr>
                                    <td>{{getCategory(event.xCategory)}}</td>
                                    <td>{{event.info}}</td>
                                    <td v-if="developMode">{{event.xEvent}}</td>
                                </tr>
                            </template>
                        </table>-->
                    </td>
                    <td v-if="developMode">{{rG.round.eventgroup.xEventGroup}}</td>
                    <td>{{rG.round.eventgroup.name}}</td>
                    <td v-if="developMode">{{rG.xRound}}</td>
                    <td>{{rG.round.name}}</td>
                    <td>{{rG.round.order}}</td>
                    <td>{{rG.name}}</td>
                    <td>{{rG.number}}</td>
                </tr>
            </template>
            
        </table>
    </div>
    

    <%= __("Status") %>: 
    <select class="formCtrl" v-model.number="contest.status" v-on:change="propagateChange=true" :disabled="readOnly">
        <template v-for="status in contestStates">
            <option v-bind:value="status.value">
                {{status.text}}
            </option>
        </template>
    </select>

    <button class="btn" v-on:click="startUpdateConf"><%= __("Contest configuration") %></button>

    <div v-if="contest.status<=39">
        <!-- roll call:  -->
        <h2><%= __("Roll call") %></h2>
        TODO: eventually include paid status!<br>
        <!-- provide a table with all athletes and a select box of their status-->
        <label class="verticalForm" style="display: inline-block">
            <%= __("Filter athletes") %><button type="button" class="information" v-on:click="overlayInfo('<%= __('Filtering') %>:', '<%= __('Filtering is possible by first and last name, club, bib, sex, club name and country. Any word must be present in one of the properties.') %>')"><%= __('i') %></button>: 
            <input v-model="filterAthletes" type="text" size="30">
        </label>
        <button style="display: inline-block;" type="button" v-on:click="filterAthletes=''" class="btn"><%= __("Reset filter") %></button>
        <v-table :data="startgroups" :filters="filters">
            <template #head> <!-- # head is a shorthand for v-slot:head-->
                <thead>
                    <tr>
                        <th><%= __("Present") %></th>
                        <th v-if="showFullDetails">xAthlete</th>
                        <th v-if="showFullDetails">xInscription</th>
                        <th is="vue:v-th" sortkey="bib" defaultsort="asc">Bib</th> <!-- is="vue:v-th is basically bthe same as <v-th   > , but the browser restricts the allowed tag names within tables, thus we need to use this syntax! Otherwise the browser will shift this outside"-->
                        <th is="vue:v-th" sortkey="athleteName"><%= __('Name') %></th>
                        <th is="vue:v-th" sortkey="athleteForename"><%= __('First name') %></th>
                        <th is="vue:v-th" sortkey="birthdate"><%= __('Year') %></th>
                        <th is="vue:v-th" sortkey="sex"><%= __('Sex') %></th>
                        <th is="vue:v-th" sortkey="clubName"><%= __('Club') %></th>
                        <!--<th is="vue:v-th" sortkey="country"><%= __('Country') %></th>-->
                        
                    </tr>
                </thead>
            </template>
            <template v-slot:body="{displayData}"> <!--v-slot:name="variables"-->
                <tbody>
                    <tr v-for="row in displayData" :key="row.xInscription">
                        <td><input type="checkbox" :disabled="readOnly" v-model="row.present" v-on:change="presentChanged(row)"></td>
                        <td v-if="showFullDetails">{{row.xAthlete}}</td>
                        <td v-if="showFullDetails">{{row.xInscription}}</td>
                        <td>{{ row.bib }}</td>
                        <td>{{ row.athleteName }}</td>
                        <td>{{ row.athleteForename }}</td>
                        <td>{{ getYearShort(row.birthdate) }}</td><!--only take the last two digits-->
                        <td>{{ row.sex }}</td>
                        <td>{{ row.clubName }}</td>
                        <!--<td>{{ row.country }}</td>-->
 
                    </tr>
                </tbody>
            </template>

        </v-table>
        <button type="button" class="btn" v-on:click="endRollCallCreateSeries"><%= __("Finish roll call and create series") %></button>
    </div>

    <!-- TODO: create a general view for series assignment, apart of the initial assignment (to be shown when 60<=states<=89 and at least one series exists)  -->
    <div v-if="contest.status>=60 && contest.status<=89 && series.length>0">
        <button type="button" v-on:click="deleteAllSeries()" class="btn btnRed"><%= __("Delete all series") %> (without warning!)</button>
        
    <button class="btn" v-if="series.length==0" v-on:click="showInitialSeriesAssignment()"><%= __("Create Series") %></button>

        <div style="display: grid; grid-template-columns: auto auto; grid-template-areas: 'series athletes'; justify-content: stretch;">
            <div style="grid-area: series;">
                Series: 
                <draggable v-model="seriesAsStartgroups" item-key="number", group="seriesMain" @change="moveSeries">
                    <template #item="{element, index}">
                        <div class="dragelement">
                            <b>Series {{index+1}}</b>
                            <!-- we cannot use el for v-model, since it seems to be a copy of the actual element. However, series[ind] works fine -->
                            <table>
                                <draggable v-model="seriesAsStartgroups[index].seriesstartsresults" item-key="index" group="athleteSeriesAssignment2" @change="changePosition(seriesAsStartgroups[index], $event)" v-bind:id="'s' + (index+1)" tag="tbody">
                                    <template #item="{element, index}">
                                        <tr class="dragelement">
                                            <td>{{element.startgroup.athleteName}}</td>
                                            <td>{{element.startgroup.athleteForename}}</td>
                                            <td>{{element.startgroup.clubName}}</td>
                                            <td>{{formatHeight(element.startgroup.bestPerf)}}</td>
                                            <td>{{formatHeight(element.startgroup.bestPerfLast)}}</td>
                                        </tr>
                                    </template>
                                </draggable>
                            </table>
                        </div>
                    </template>
                </draggable>
            </div>
            <div style="grid-area: athletes;">
                Athletes to assign: 
                <!--Use of v-table makes the things a little bit more complicated: Since v-table (dynamically) creates its copy of the actual data to sort this copied array, we cannot directly insert into this array, but we have to manually override to make the item being dropped in the outer array, i.e. not the array of v-table.-->
                <v-table :data="unassignedAthletes" >
                    <template #head> 
                        <thead>
                            <tr>
                                <th is="vue:v-th" sortkey="present"><%= __('Present') %></th>
                                <th is="vue:v-th" sortkey="athleteName" defaultSort="asc"><%= __('Name') %></th>
                                <th is="vue:v-th" sortkey="athleteForename"><%= __('First name') %></th>
                                <th is="vue:v-th" sortkey="clubName"><%= __('Club') %></th>
                                <th is="vue:v-th" sortkey="bestPerf"><%= __('PB') %></th>
                                <th is="vue:v-th" sortkey="bestPerfLast"><%= __('SB') %></th>
                            </tr>
                        </thead>
                    </template>
                    <template v-slot:body="{displayData}"> <!--v-slot:name="variables"-->
                            <draggable v-model="displayData" item-key="index" group="athleteSeriesAssignment2"  @change="removeSSR"  tag="tbody">
                                <template #item="{element, index}">
                                    <tr class="dragelement">
                                        <td>{{ element.present }}</td>
                                        <td>{{ element.athleteName }}</td>
                                        <td>{{ element.athleteForename }}</td>
                                        <td>{{ element.clubName }}</td>
                                        <td>{{formatHeight(element.bestPerf)}}</td>
                                        <td>{{formatHeight(element.bestPerfLast)}}</td>
                                    </tr>
                                </template>
                            </draggable>   
                    </template>
                </v-table>
            </div>
        </div>

    </div>

    <div v-if="contest.status>=95 && contest.status<=180 && series.length>0">

        <%= __("Series Selection") %>
        <select class="content dropdown" v-model="selectedSeries" v-on:change="selectedSeriesChanged">
            <option v-for="(seriesEl, seriesIndex) in series" v-bind:value="seriesIndex">
                {{seriesEl.number}} <div v-if="seriesEl.name">{{seriesEl.name}}</div> <!--if undefined, the name shall not be shown-->
            </option>
        </select>

        <div id="settings" style="width:100%">
            <!-- TODO: format this -->
            <h2><%= __("Series Settings") %></h2>
            <!--<%= __("Jumpoff") %>
            <div class="onoffswitch">
                <input type="checkbox" v-model="conf.jumpoff" class="onoffswitch-checkbox" id="myonoffswitch" v-on:change="calculateNextAthlete">
                <label class="onoffswitch-label" for="myonoffswitch">
                    <span class="onoffswitch-inner"></span>
                    <span class="onoffswitch-switch"></span>
                </label>
            </div>-->

            <!--<%= __("Contest Status") %>
            <select class="content dropdown" v-model="contest.status" >
                <option v-for="option in contestStates" v-bind:value="option.value">
                    {{option.text}}
                </option>
            </select>-->
            

            <%= __("Series Status") %>
            <select class="content dropdown" v-model="series[selectedSeries].status" v-on:change="seriesStatusChanged" :disabled="readOnly">
                <option v-for="option in seriesStates" v-bind:value="option.value">
                    {{option.text}}
                </option>
            </select><br>
            Auto advance (if true, no clock can be shown):<div class="onoffswitch">
                <input type="checkbox" v-model="autoAdvance" class="onoffswitch-checkbox" id="autoAdvanceSwitch" v-on:change="calculateNextAthlete">
                <label class="onoffswitch-label" for="autoAdvanceSwitch">
                    <span class="onoffswitch-inner"></span>
                    <span class="onoffswitch-switch"></span>
                </label>
            </div>



            <h3><%= __('Heights') %></h3>
            <%= __("Current heights") %> <button class="information" v-on:click="overlayInfo('<%= __('Jumping heights') %>:', '<%= __('The jumping heights are automatically generated (separately for each series) from the height interval (defined per contest) and are added to this list as soon as they are referenced e.g. as a startheight or in a result. Heights outside the intervals can be specified manually as well. As long as the height is not referenced, it can be deleted by clicking on it.') %>')"><%= __('i') %></button>: 
            <div class="d-flex flex-row">
                <template v-for="(heightEl, heightElIndex) in series[selectedSeries].heights">
                    <button v-if="heightEl.deletable" class="btn btnGrey marginS" v-on:click="deleteHeight(heightElIndex)" :disabled="readOnly">
                        <div v-if="heightEl.jumpoffOrder>0">
                            <%= __("J:") %> {{heightEl.height}}
                        </div>
                        <div v-else>
                            {{heightEl.height}}
                        </div>
                    </button>
                    <div class="crumb" v-else>
                        <div v-if="heightEl.jumpoffOrder>0">
                            <%= __("J:") %> {{heightEl.height}}
                        </div>
                        <div v-else>
                            {{heightEl.height}}
                        </div>
                        
                    </div>
                </template>
            </div>
            <div v-if="!readOnly">
                <%= __("Add manual height") %>: 
                <input class="formCtrl" type="text" id="manualHeight" size="3" v-bind:max="disciplineConfiguration.heightMax" min="0" v-on:keyup="addManualHeightEnter">
                <button class="btn btnGrey" v-on:click="addManualHeight()"><%= __("Add") %></button>
            </div>
        </div>
        
        <div id="startHeights" class="container" style="width:100%">
            <!-- startheights should only be changeable until an athlet has a result -->
            <h2><%= __("Startheights") %></h2>
            <table class="table">
                <tr><th class="d-none d-md-block"><%= __("Nbr.") %></th><th><%= __("Name") %></th><th class="d-none d-md-block"><%= __("Club")%></th><th></th></tr>
                <template v-for="(xSeriesStartEl, xSeriesStartElIndex) in series[selectedSeries].seriesstartsresults">
                    <!-- The athletes data is in the auxData! -->
                    <tr>
                        <td class="d-none d-md-block">{{auxData.xStartgroup[xSeriesStartEl.xStartgroup].bib}}</td>
                        <td>{{auxData.xStartgroup[xSeriesStartEl.xStartgroup].athleteForename}} {{auxData.xStartgroup[xSeriesStartEl.xStartgroup].athleteName}}</td>
                        <td class="d-none d-md-block">{{auxData.xStartgroup[xSeriesStartEl.xStartgroup].clubName}}</td>
                        <td>
                            <select class="formCtrl" :id="'startHeightSelection' + xSeriesStartEl.xStartgroup.toString()" onmousedown="if(this.options.length>6){this.size=6;}; " onchange="this.size=0" onblur="if (this.selectedIndex==-1){this.size=0; this.selectedIndex=-1} else {this.size=0;}" v-model.string="xSeriesStartEl.startConf" v-on:change="startHeightChanged(xSeriesStartEl)" :disabled="readOnly"> <!-- I dont want an extremely long dropdown, so we quickly increase the size of the select to make it not a dropdown, but a list, and then reset it: Problem in Chrome: When nothing is selected and blur is raised, changing the size back to 0 makes the first item appear selected, however it is not (no change or input event raised neither). The if in the onblur event is the workaround for that, since it corrects the problem currently 02.2020 -->
                            <template v-for="(height, heightIndex) in allHeights">
                                <option v-bind:value="height">{{height.toString()}}</option>
                            </template>
                        </select></td>
                    </tr>

                </template>
            </table>
        </div>

        <!-- change result mode, eventually including a mode to enter results in the TIC -->

        <!-- competition mode (standard): -->
        <div id="competition" style="margin-right:auto">
            <h2><%= __("Competition") %></h2>
            <div v-if="mode == 0"><%= __("Please define the start heights.") %></div>
            <div v-if="mode == 1" style="display:inline-block"> 
                <div id="currentAth" v-if="position.length>0" class="athlete">
                    <div class="row2">                            
                        <div class="el"><%= __("Current athlete") %>: </div>
                    </div>
                    <div class="row2">
                        <div class="elText">{{auxData.xStartgroup[currentAthleteStart.xStartgroup].bib}}</div>
                        <div class="elText">{{auxData.xStartgroup[currentAthleteStart.xStartgroup].athleteName}} {{auxData.xStartgroup[currentAthleteStart.xStartgroup].athleteForename}}</div>
                        <div class="elText">{{birthdayToXX(auxData.xStartgroup[currentAthleteStart.xStartgroup].birthdate)}}</div>
                        <div class="elText">{{auxData.xStartgroup[currentAthleteStart.xStartgroup].countryCode}}</div>
                        <div class="elText">{{auxData.xStartgroup[currentAthleteStart.xStartgroup].clubName}}</div>
                        <section class="collapsable el2 marginRight" v-if="!readOnly">
                            <div style=" padding: .375rem 0rem; display: inline-block; width:0px;">&nbsp;</div><!--This stupid empty div is just here in order that the fomatting works correcly. Without it, the alignment does not work appropriately when the content is closed. Important as well: do not specify the height of the element, as this would cause probelms as well, but instead have a not-shown 'text' and some padding. It seems like the problem is coming from the vertical-align: baseline;-->
                            <input type="checkbox" id="hiddenInput" name="participationStatusHider"></input><!-- do not show the checkbox; tha label is still clickable -->
                            <label for="hiddenInput" class="marginRight">
                                <%= __("Change participation status") %>  
                            </label>
                            <select class="content dropdown" v-model="currentAthleteStart.resultOverrule" v-on:change="calculateNextAthlete(); updateSSR(currentAthleteStart)">
                                <option v-for="option in participationStates" v-bind:value="option.value">
                                    {{option.text}}
                                </option>
                            </select>
                        </section>
                    </div>
                    
                    <div class="row2">
                        <div class="elText">{{meterStr(currentHeight)}} m</div>
                        <div class="elText">{{attempt}}. <%= __("Attempt") %>: </div>
                        <div class="el2">
                            <!-- 
                                if not result yet: select XO- 
                                if result entered: select "vorlegen/stage/advance/next" -->
                            <div v-if="resultOnCurrentHeight">
                                <template v-if="readOnly">
                                    <!-- add some formatting -->
                                    {{resultOnCurrentHeight}}
                                </template>
                                <template v-else>
                                    <button class="btn" type="button" v-on:click="calculateNextAthlete"><%= __("Advance") %></button> 
                                </template>
                            </div>
                            <div v-else>    
                                <button type="button" class="el" v-on:click="cleared()" v-bind:disabled="readOnly">O</button>
                                <button type="button" class="el" v-on:click="failed()" v-bind:disabled="readOnly">X</button>
                                <button type="button" class="el" v-on:click="passed()" v-bind:disabled="readOnly">-</button>
                            </div>

                            <!-- time period stuff: -->
                            <div v-if="autoAdvance==false">
                                <!-- Note: we use hours as minutes and minutes as seconds -->
                                <input type="time" max="6:00:00" v-model="attemptTimeSetting" v-if="!readOnly">
                                <button type="button" class="btn" v-on:click="setTime" v-if="!readOnly"><%= __("Set") %></button>
                                <div v-if="roomAuxData[selectedXSeries].showAttemptPeriod">
                                    <h3 v-bind:class="{yellowBg: last15}">{{shownTime}}</h3>
                                    <!-- TOOD: add here icons (play, stop) instead of text -->
                                    <button type="button" class="btn" v-on:click="startPeriod" v-if="!readOnly">&#9654;</button>
                                    <button type="button" class="btn" v-on:click="hidePeriod" v-if="!readOnly">&#9209;</button>
                                </div>
                            </div>
                        </div>

                        <input class="el2 formCtrl" placeholder="<%= __('Remarks') %>" type="text" v-model="currentAthleteStart.resultRemark" v-on:blur="updateSSR(currentAthleteStart)"
                        v-bind:disabled="readOnly">
                    </div>

                    <div class="row2 athRes">
                        <div class="elText"><%= __("Rank") %>: {{tempRankingData[currentAthleteStart.xSeriesStart].rank}}</div>
                        <div class="elText"><%= __("Results so far") %>: </div>
                        <template v-for="res in sortedResults(currentAthleteStart.resultshigh)">
                            <div class="elText">
                                {{getHeight(res.xHeight)}}: {{resultToStr(res)}}
                            </div>
                        </template>
                    </div>

                </div>
                <br />
                <div id="nextAth" v-if="positionNext.length>1" class="athlete">
                    <div class="row2">
                        <div class="elText"><%= __("Next athlete") %>: </div>
                    </div>
                    <div class="row2">
                        <div class="elText">{{auxData.xStartgroup[nextAthleteStart.xStartgroup].bib}}</div>
                        <div class="elText">{{auxData.xStartgroup[nextAthleteStart.xStartgroup].athleteName}} {{auxData.xStartgroup[nextAthleteStart.xStartgroup].athleteForename}}</div>
                        <div class="elText">{{birthdayToXX(auxData.xStartgroup[nextAthleteStart.xStartgroup].birthdate)}}</div>
                        <div class="elText Sl_hide">{{auxData.xStartgroup[nextAthleteStart.xStartgroup].countryCode}}</div>
                        <div class="elText Sl_hide">{{auxData.xStartgroup[nextAthleteStart.xStartgroup].clubName}}</div>
                    </div>
                    <div class="row2">
                        <div class="elText">{{attemptNext}}. <%= __("Attempt") %></div>
                        <div class="elText">{{meterStr(currentHeight)}} m</div>
                    </div>

                    <!-- <div><%= __("Rank") %>: {{tempRankingData[nextAthleteStart.xSeriesStart].rank}}</div> -->
                </div>
                <!-- 

                    - in the long run include the timer clock. How can we sync the timer clock over the network without producing too much traffic. 
                -->
            </div>
            <div v-if="mode == 2 && jumpoffHeightRequired ">
                <%= __("Define the next height in the jumpoff") %>: 
                <input class="formCtrl" type="text" id="manualJumpoffHeight" v-model="manualJumpoffHeight" size="3" v-bind:max="disciplineConfiguration.heightMax" min="0" v-on:keyup="addManualJumpoffHeightEnter" :disabled="readOnly">
                <button class="btn btnGrey" v-on:click="addManualJumpoffHeight()" :disabled="readOnly"><%= __("Add") %></button>
            </div>
            <div v-if="mode == 2 && jumpoffHeightRequired == false">
                <!-- Jumpoff: -->
                <%= __("Jumpoff") %>
                <div id="currentAth" v-if="position.length>0" class="athlete">
                    <div class="row2">                            
                        <div class="el"><%= __("Current athlete") %>: </div>
                    </div>
                    <div class="row2" >
                        <div class="elText">{{auxData.xStartgroup[currentAthleteStart.xStartgroup].bib}}</div>
                        <div class="elText">{{auxData.xStartgroup[currentAthleteStart.xStartgroup].athleteName}} {{auxData.xStartgroup[currentAthleteStart.xStartgroup].athleteForename}}</div>
                        <div class="elText">{{birthdayToXX(auxData.xStartgroup[currentAthleteStart.xStartgroup].birthdate)}}</div>
                        <div class="elText">{{auxData.xStartgroup[currentAthleteStart.xStartgroup].countryCode}}</div>
                        <div class="elText">{{auxData.xStartgroup[currentAthleteStart.xStartgroup].clubName}}</div>
                        <section class="collapsable el2 marginRight" v-if="!readOnly">
                            <div style=" padding: .375rem 0rem; display: inline-block; width:0px;">&nbsp;</div><!--This stupid empty div is just here in order that the fomatting works correcly. Without it, the alignment does not work appropriately when the content is closed. Important as well: do not specify the height of the element, as this would cause probelms as well, but instead have a not-shown 'text' and some padding. It seems like the problem is coming from the vertical-align: baseline;-->
                            <input type="checkbox" id="hiddenInput" name="participationStatusHider"></input><!-- do not show the checkbox; tha label is still clickable -->
                            <label for="hiddenInput" class="marginRight">
                                <%= __("Change participation status") %>  
                            </label>
                            <select class="content dropdown" v-model="currentAthleteStart.resultOverrule" v-on:change="calculateNextAthlete(); updateSSR(currentAthleteStart);">
                                <option v-for="option in participationStates" v-bind:value="option.value">
                                    {{option.text}}
                                </option>
                            </select>
                        </section>
                    </div>
                    
                    <div class="row2">
                        <div class="elText">{{currentJumpoffHeight}} m</div>
                        <div class="elText">{{currentJumpoffHeightInd}}<%= __(". jumpoff height") %>: </div>
                        <div class="el2">
                            <button class="el" v-on:click="clearedJumpoff()">O</button>
                            <button class="el" v-on:click="failedJumpoff()">X</button> <!-- athletes must jump (thus only options cleared or failed), or they can retire => change status to retired -->
                        </div>

                        <input class="el2 formCtrl" placeholder="<%= __('Remarks') %>" type="text" v-model="currentAthleteStart.resultRemark" v-on:blur="updateSSR(currentAthleteStart)" v-bind:disabled="readOnly">
                    </div>

                    <div class="row2 athRes">
                        <div class="elText"><%= __("Rank") %>: {{tempRankingData[currentAthleteStart.xSeriesStart].rank}}</div>
                        <div class="elText"><%= __("Results so far") %>: </div>
                        <template v-for="res in currentAthleteStart.resultshigh">
                            <div class="elText">
                                {{getHeight(res.xHeight)}}: {{resultToStr(res)}}
                            </div>
                        </template>
                    </div>

                </div>
                <br />
                <div id="nextAth" v-if="positionNext.length>1" class="athlete" >
                    <div class="row2">
                        <div class="elText"><%= __("Next athlete") %>: </div>
                    </div>
                    <div class="row2">
                        <div class="elText">{{auxData.xStartgroup[nextAthleteStart.xStartgroup].bib}}</div>
                        <div class="elText">{{auxData.xStartgroup[nextAthleteStart.xStartgroup].athleteName}} {{auxData.xStartgroup[nextAthleteStart.xStartgroup].athleteForename}}</div>
                        <div class="elText">{{birthdayToXX(auxData.xStartgroup[nextAthleteStart.xStartgroup].birthdate)}}</div>
                        <div class="elText Sl_hide">{{auxData.xStartgroup[nextAthleteStart.xStartgroup].countryCode}}</div>
                        <div class="elText Sl_hide">{{auxData.xStartgroup[nextAthleteStart.xStartgroup].clubName}}</div>
                    </div>
                    <div class="row2">
                        <div class="elText">{{currentJumpoffHeight}} m</div>
                        <div class="elText">{{currentJumpoffHeightInd}}<%= __(". jumpoff height") %></div>
                    </div>

                    <!-- <div><%= __("Rank") %>: {{tempRankingData[nextAthleteStart.xSeriesStart].rank}}</div> -->
                </div>
            </div>
            <div v-if="mode == 3">
                <%= __("The competition is finished.") %>
            </div>
        </div>
        <div id="orderPosition" style="display:block">
            <h2><%= __("Order of athletes") %></h2>
            <%= __("Drag'n'drop") %> <button class="information" v-on:click="overlayInfo('<%= __('Jumping order of athletes') %>:', '<%= __('The order of athletes jumping on the current height can be (temporary) changed by dragging an athlete from one position to another. The current and next athlete are instantly updated, if needed. As soon as the current height changes, the order is reset to the default order and with the athletes that jump on the new height.') %>')"><%= __('i') %></button>
            <ol>
                <draggable style="display:inline-block;" v-model="position" @end="onPositionMovingEnded" item-key="index" :disabled="readOnly">
                    <template #item="{element, index}">   
                        <li class="item"> 
                            <div class="dragelement">
                                {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.bib}} 
                                {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.athleteName}} {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.athleteForename}}
                            </div>     
                        </li>     
                    </template>
                </draggable>
            </ol>

            Same, but as grid
            <draggable style="display: flex; flex-wrap: wrap; width: 400px; justify-content: center" v-model="position" @end="onPositionMovingEnded" item-key="index" :disabled="readOnly">
                <template #item="{element, index}">   
                    <template v-if="index==position.length-1">
                        <div class="dragelement">
                            {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.bib}} 
                            {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.athleteName}} {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.athleteForename}}
                        </div> 
                        <!--<div style="flex-grow:100"></div><!-- avoid the last element from spanning the whole line -->
                    </template>
                    <template v-else>
                        <div class="dragelement"> <!-- style=" flex-grow:1" -->
                            {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.bib}} 
                            {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.athleteName}} {{auxData.xStartgroup[getStartByXSeriesStart(element).xStartgroup]?.athleteForename}}
                        </div> 
                    </template>    
                </template>
            </draggable>
        </div>
        <div id="resultsView" v-if="mode>0" style="display:block">
            <h2><%= __("View / add / change results") %>:</h2>
            <%= __("Sorting") %>: 
            <select v-model="sortValue1" class="dropdown marginS">
                <option value="1"><%= __("Default sequence") %></option> <!-- means the order on the judge's sheet -->
                <option value="2"><%= __("Rank") %></option>
                <option value="3"><%= __("Name") %></option>
                <option value="4"><%= __("Bib") %></option>
            </select><br />
            <!-- 
                Two different views of the results are possible (while the athlete data in both is +- the same):
                1) Just show a list of the athletes, their rank and the best valid height. In small, show the details of every height. This view is mobile-friendly and columns could be hidden dependent on screen size. 
                2) Show a big table in the style as the judge has it on his paper: one column per height. Gives a wider table than option 1, which is less mobile friendly.
                => so far only option 1 is implemented
            -->
            <div style="display:inline-block" >
                <template v-for="(startIndex, sortIndex) in sortedStarts1">
                    <div class="athlete">
                        <div class="row2">
                            
                            <div class="elText">{{tempRankingData[series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart].rank}}.  </div>
                            <div class="elText">{{auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup].bib}}</div>
                            <div class="elText">{{auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup].athleteName}} {{auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup].athleteForename}}</div>
                            <div class="elText">{{birthdayToXX(auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup].birthdate)}}</div>
                            <div class="elText Sl_hide">{{auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup].countryCode}}</div>
                            <div class="elText Sl_hide">{{auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup].clubName}}</div>
                        </div>
                        <div class="row2">
                            <div class="elText"><%= __("Valid height") %>: {{(tempRankingData[series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart].lastValidHeight/100).toFixed(2)}} m</div>
                            <template v-for="res in sortedResults(series[selectedSeries].seriesstartsresults[startIndex].resultshigh)"> 
                                <div class="el2" v-bind:class="{hidden: res==currentResultChange}">
                                    <button class="btn btnGrey" v-on:click="changeResult(res)" v-bind:class="{validHeight: tempRankingData[series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart].lastValidHeight==getHeight(res.xHeight)}" :disabled="readOnly">{{getHeight(res.xHeight)}}: {{resultToStr(res)}}</button>
                                </div>
                                <div class="el2" v-bind:class="{hidden: res!=currentResultChange}">
                                    <input class="formCtrl" type="text" size=3 maxlength=3 name="result" v-bind:id="'resChange' + res.xResult" v-model="currentResultString" v-on:blur="saveCurrentResChange(series[selectedSeries].seriesstartsresults[startIndex])" :disabled="readOnly">
                                </div>
                            </template>
                            
                            <div class="elText"><%= __("# failed attempts") %>: {{tempRankingData[series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart].totalFailedAttempts}}</div>
                        </div>
                        
                        <div class="row2" v-if="readOnly==false">
                            <!-- provide here the possibility to add a result (as it would be useful in TIC mode): -->
                            <div v-if="!tempRankingData[series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart].finished">
                                <div class="elText" style="display:inline-block"><%= __('Add result') %>: </div>
                                <!-- dropdown with heights that were not jumped yet by this athlete; the next higher height is preselected -->
                                <select class="dropdown" name="" v-bind:id="'newResultHeight' + series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart">
                                    <option v-for="hEl in getNewHeigthsByXSeriesStart(series[selectedSeries].seriesstartsresults[startIndex])" v-bind:value="hEl.value" v-bind:selected="hEl.next">
                                        {{hEl.text}}
                                    </option>
                                </select>
                                <input class="formCtrl" size="3" maxlength="3" type="text" name="newResult" v-bind:id="'newResultValue' + series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart" v-on:blur="addResultBlur(series[selectedSeries].seriesstartsresults[startIndex], $event)" v-on:keydown="resultKeyPressed=$event.which || $event.keyCode">
                            </div>
                            <div class="marginLeft">
                                <input class="formCtrl" placeholder="<%= __('Remarks') %>" type="text" v-model="series[selectedSeries].seriesstartsresults[startIndex].resultRemark" :disabled="readOnly" v-on:blur="updateSSR(series[selectedSeries].seriesstartsresults[startIndex])">
                            </div>

                            <section class="el2 collapsable marginLeft marginRight">
                                <div style=" padding: .375rem 0rem; display: inline-block; width:0px;">&nbsp;</div><!--This stupid empty div is just here in order that the fomatting works correctly. Without it, the alignment does not work appropriately when the content is closed. Important as well: do not specify the height of the element, as this would cause probelms as well, but instead have a not-shown 'text' and some padding. It seems like the problem is coming from the vertical-align: baseline;-->
                                <input type="checkbox" v-bind:id="'hiddenInput' + series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart" name="participationStatusHider" ></input><!-- do not show the radio button; tha label is still clickable -->
                                <label v-bind:for="'hiddenInput' + series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart">
                                    <%= __("Change participation status") %>    
                                </label>
                                <!-- TODO: participation should be changed only after confirmation or in a usually hidden menu (e.g. click on "change status" to show the dropdown) -->
                                <select class="content dropdown marginLeft" v-model="series[selectedSeries].seriesstartsresults[startIndex].resultOverrule" v-on:change="calculateNextAthlete(); updateSSR(series[selectedSeries].seriesstartsresults[startIndex])">
                                    <option v-for="option in participationStates" v-bind:value="option.value">
                                        {{option.text}}
                                    </option>
                                </select>
                            </section>
                        </div>
                    </div>
                    <br />
                </template>
            </div>
        </div>
        <h2><%= __("Results (table view)") %>:</h2>
        <%= __("Sorting") %>: 
        <select v-model="sortValue2" class="dropdown marginS">
            <option value="1"><%= __("Default sequence") %></option> <!-- means the order on the judge's sheet -->
            <option value="2"><%= __("Rank") %></option>
            <option value="3"><%= __("Name") %></option>
            <option value="4"><%= __("Bib") %></option>
        </select>
        <div id="resultsView2" v-if="mode>0" style="display:grid; column-gap: 0px; justify-items: center;" v-bind:style="{'grid-template-columns': resultGridTemplate}"> <!-- max-content means, that the column is maximum as wide as the contents require, i.e. there is no filling with empty space when there would be additional space to use; min-content means that the column is at least as wide as required by an element (i.e. the longest word that cannot be wrapped). grid-auto-columns: min-content;  -->
            <!-- table view of the results with a grid layout -->
            <!-- show all the heights; the column is given by height in cm + 100 -->

            <!-- eventually we can also use Vue to create named lines and use those to order the items; woudl probably be faster! 
            grid-template-columns: [rank] auto [] auto [names] auto [200] auto [220] auto [240] auto [end]   eventually auto should be max-content..?-->

            <template v-for="h in series[selectedSeries].heights">
                <div v-bind:style="{'grid-column':'h'+h.xHeight}" style="grid-row:1; padding: 0.375rem 0.375rem" v-if="h.jumpoffOrder>0"><%= __("J:") %> {{h.height}}</div>
                <div v-bind:style="{'grid-column':'h'+h.xHeight}" style="grid-row:1; padding: 0.375rem 0.375rem" v-else>{{h.height}}</div>
            </template>
            <template v-for="(startIndex, sortIndex) in sortedStarts2">
                
                <div class="name"  v-bind:style="{'grid-row': sortIndex+2}"> <!--style="justify-self: start; grid-column: athletes"-->
                    {{auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup].athleteName}} {{auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup].athleteForename}}
                </div>
                <div class="bib" v-bind:style="{'grid-row': sortIndex+2}"> <!--style="justify-self: start; grid-column: bib"-->
                    {{auxData.xStartgroup[series[selectedSeries].seriesstartsresults[startIndex].xStartgroup]?.bib}}
                </div>
                <div class="rank" v-bind:style="{'grid-row': sortIndex+2}"> <!--style="justify-self: start; grid-column: rank"-->
                    {{tempRankingData[series[selectedSeries].seriesstartsresults[startIndex].xSeriesStart].rank}}. 
                </div>
                <template v-for="hRes in series[selectedSeries].seriesstartsresults[startIndex].resultshigh">
                    <div class="res" v-bind:style="{'grid-row': sortIndex+2, 'grid-column': 'h'+hRes.xHeight}">
                        {{resultToStr(hRes)}}
                    </div>
                </template>
            </template>
        </div>
    </div>

    <!-- Overlay for the initial series assignment: -->
    <div class="overlay" v-bind:class="{shown: overlay2}">
        <div class="overlayContainerWide">
            <form>
                <button type="button" class="btn" v-on:click="addEmptySeriesInitial()"><%= __("Manually add one series") %></button>
                <button type="button" class="btn" v-on:click="overlay='automaticSeriesAssignment'"><%= __("Automatic series assignment") %></button>

                <div style="display: grid; grid-template-columns: auto auto; grid-template-areas: 'series athletes'; justify-content: stretch;">
                    <div style="grid-area: series;">
                        Series: 
                        <draggable v-model="seriesObj" item-key="number", group="series" @end="seriesChanged">
                            <template #item="{element, index}">
                                <div class="dragelement">
                                    Series {{index+1}}
                                    <!-- we cannot use el for v-model, since it seems to be a copy of the actual element. However, series[ind] works fine -->
                                    <table>
                                        <draggable v-model="seriesObj[index].startsingroup" item-key="index" group="athleteSeriesAssignment" @end="dragEnded" v-bind:id="'s' + (index+1)" tag="tbody">
                                            <template #item="{element, index}">
                                                <tr class="dragelement">
                                                    <td>{{element.athleteName}}</td>
                                                    <td>{{element.athleteForename}}</td>
                                                    <td>{{element.clubName}}</td>
                                                    <td>{{formatHeight(element.bestPerf)}}</td>
                                                    <td>{{formatHeight(element.bestPerfLast)}}</td>
                                                </tr>
                                            </template>
                                        </draggable>
                                    </table>
                                </div>
                            </template>
                        </draggable>
                    </div>
                    <div style="grid-area: athletes;">
                        Athletes to assign:
                        <!--Use of v-table makes the things a little bit more complicated: Since v-table (dynamically) creates its copy of the actual data to sort this copied array, we cannot directly insert into this array, but we have to manually override to make the item being dropped in the outer array, i.e. not the array of v-table.-->
                        <v-table :data="unassignedAthletesCreate" >
                            <template #head> 
                                <thead>
                                    <tr>
                                        <th is="vue:v-th" sortkey="athleteName"><%= __('Name') %></th>
                                        <th is="vue:v-th" sortkey="athleteForename"><%= __('First name') %></th>
                                        <th is="vue:v-th" sortkey="clubName"><%= __('Club') %></th>
                                        <th is="vue:v-th" sortkey="bestPerf"><%= __('PB') %></th>
                                        <th is="vue:v-th" sortkey="bestPerfLast"><%= __('SB') %></th>
                                    </tr>
                                </thead>
                            </template>
                            <template v-slot:body="{displayData}"> <!--v-slot:name="variables"-->
                                    <draggable v-model="displayData" item-key="index" group="athleteSeriesAssignment"  @change="unassignedAthleteChanged"  tag="tbody">
                                        <template #item="{element, index}">
                                            <tr>
                                                <td>{{ element.athleteName }}</td>
                                                <td>{{ element.athleteForename }}</td>
                                                <td>{{ element.clubName }}</td>
                                                <td>{{formatHeight(element.bestPerf)}}</td>
                                                <td>{{formatHeight(element.bestPerfLast)}}</td>
                                            </tr>
                                        </template>
                                    </draggable>   
                            </template>
                        </v-table>
                    </div>
                </div>
                <button type="button" class="btn btnRed" v-on:click="overlay2 = undefined"><%= __("close") %></button>
                <button type="button" class="btn btnGreen" ref="saveInitSeries" v-on:click="saveInitSeries"><%= __("Save") %></button>
            </form>
        </div>
    </div>

    <div class="overlay"  v-bind:class="{shown: overlay}">
        <div class="overlayContainer">
            <div id="confTechHigh" v-if="overlay=='config'">
                <form>
                    <div class="verticalForm">
                        <h3><%= __("Contest configuration") %>: </h3>
                        <!-- <label>
                            <%= __("Category") %>: 
                            <select v-model.number= "newXCategory">
                                <option v-for="cat in categories" v-bind:value="cat.xCategory">{{cat.shortname}}</option>
                            </select>
                        </label> -->
                        <%= __("Jumpoff") %>
                        <div class="onoffswitch">
                            <input type="checkbox" v-model="confForMod.jumpoff" class="onoffswitch-checkbox" id="myonoffswitch2" v-on:change="calculateNextAthlete" :disabled="readOnly">
                            <!-- the label part is model independent, but th id/for must match-->
                            <label class="onoffswitch-label" for="myonoffswitch2">
                                <span class="onoffswitch-inner"></span>
                                <span class="onoffswitch-switch"></span>
                            </label>
                        </div>
                        <!--<label>
                            <%= __("Jumpoff") %>: 
                            <input v-model="confForMod.jumpoff"  type="checkbox" :disabled="readOnly">
                        </label>-->
                        <!--<%= __("Define jumping height intervals") %>: -->
                        <table class="table">
                            <tr><th><%= __("Interval begin") %></th><th><%= __("Interval") %></th><th></th></tr>
                            <template v-for="(heightEl, heightElIndex) in confForMod.heightIncreases">
                                <!-- show regular height-->
                                <tr v-if="heightElIndex != updateHeightIncrease">
                                    <td>{{heightEl.heightIncreaseStartheight}}</td>
                                    <td>{{heightEl.heightIncrease}}</td>
                                    <td ><button type="button" class="btn btnGrey marginRight" v-on:click=" startUpdatingHeightIncrease(heightElIndex)" :disabled="readOnly" v-bind:class="{disabled: readOnly}"><%= __("Change") %></button><button type="button" class="btn btnRed" v-on:click=" deleteHeightIncrease(heightElIndex)" :disabled="readOnly" v-bind:class="{disabled: readOnly}"><%= __("Delete") %></button></td>
                                </tr>
                                <!-- height during modification-->
                                <tr v-if="heightElIndex == updateHeightIncrease">
                                    <td><input class="formCtrl" placeholder="<%= __('Begin') %>" type="text" v-model.number="heightEl.heightIncreaseStartheight" size=3></td>
                                    <td><input class="formCtrl" placeholder="<%= __('Interval') %>" type="text" v-model.number="heightEl.heightIncrease" size=2></td>
                                    <td ><button type="button" class="btn btnGreen marginRight" v-on:click=" saveUpdateHeightIncrease()"><%= __("Save") %></button><button type="button" class="btn  btnGrey" v-on:click=" abortUpdateHeightIncrease(heightElIndex); "><%= __("Abort") %></button></td>
                                </tr>
                            </template>
                            <!-- add height interval:-->
                            <tr class="table-info" v-if="!readOnly">
                                <td><input class="formCtrl" placeholder="<%= __('Begin') %>" type="text" id="heightIncreaseStartheight" size=3 v-model="newHeightIncreaseStart"></td>
                                <td><input class="formCtrl" placeholder="<%= __('Interval') %>" type="text" id="heightIncrease" size=2 v-model="newInterval"></td>
                                <td><button type="button" class="btn btnGrey" v-on:click=" addHeightIncrease()"><%= __("Add") %></button></td>
                            </tr>
                            
                        </table>
            
                        <button type="submit" class="btn btnGreen" v-on:click="saveUpdateConf" :disabled="readOnly">
                            <%= __("Save") %>
                        </button>
                        <button type="button" class="btn btnRed" v-on:click="abortUpdateConf"><%= __("Abort") %></button>
                    </div>
                </form>
            </div>

            <div v-if="overlay=='automaticSeriesAssignment'">
                <form>
                    <!-- if there are multiple assignment algorithms, show a dropdown to select-->
                    <div v-if="seriesAssignments.length>1">
                        <%= __("Series assignment") %>: <!-- for track it is called heat --> 
                        <!-- if there are multiple series assignment algorithms, show a dropdown to choose from -->
                        <select class="formCtrl" v-model.number="selectedSeriesAssignment">
                            <template v-for="(SA, id) in seriesAssignments">
                                <option v-bind:value="id">{{SA.name}}</option>
                            </template>
                        </select>
                    </div>
                    <!-- include teh different series assignment configuration wizards -->
                    <% seriesAssignments.forEach((SA)=>{ %>
                        <%- include(SA, {type:"html"}) %>
                    <% }); %>
                    <button type="button" class="btn btnRed" v-on:click="overlay=undefined"><%= __("Abort") %></button>
                    <button type="submit" class="btn btnGreen" v-on:click="createSeriesAutomatically()"><%= __("(Re-)create series") %></button>
                </form>
            </div>

            <!-- insert here all series assignment settings -->


        </div>
    </div>

    <div id="overlay" v-on:click="infoVisible=false" v-bind:class="{shown: infoVisible}">
        <!-- overlay used for displaying general information -->
        <div id="overlayContainer">
            <div id="overlayTitle"><b>{{infoTitle}}</b></div>
            <div id="overlayContent">{{infoContent}}</div>
        </div>
    </div>

    
</div>