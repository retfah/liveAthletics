
<script src="/static/vuContestTechHigh.js"></script>
<script>

    /**
     * Series creation for track:
     * - provide an option for swapping lanes (two atheltes change their lanes.) With draggable this can be done as shown here:https://stackoverflow.com/questions/63433028/vue-draggable-how-to-only-replace-item-chosen-to-prevent-shifting-all-other-it
     * - provide the possibility that pressing Ctrl and or Shift change the behavior between "insert element and automatically move all others" (draggable default), "swap lanes" and "add to same lane"
     **/

    // connect to the room (defined by te ID in the URL/http-GET-param)
    // class vuContestTest is imported above

    var rCTech;
    var rSites;
    var vueSeriesAdminTech; 

    class vuSites extends roomClientVue{
        
        constructor(vue, meetingShortname){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super('sites@' + meetingShortname, false, true, '/static/rSitesClient.js', 'rSitesClient', '')
    
            // needed to call things in the vue class
            this.vue = vue;
        }
    
        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }
    
        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            this.vue.sites = this.room.data.sites; // this will actually store a proxy of the data!
        }
        
        dataArrived(){
            // raised as soon as the room has its data stored for the first time
            this.vue.sites = this.room.data.sites;
    
        }
    }

    function startSeriesAdminTechRead(){
        // no writing right
        startSeriesAdminTech(false);
    }

    function startSeriesAdminTech(writing=true){

        /**
         * IMPORTANT NOTE: 
         * 1.) this room shall also work offline, i.e. all changes are written to a stack on the client which will be synchronized as soon as possible. However, this also needs that the changes are directly applied on the client, instead of applying them not before the answer of the server in "online-only" pages.
         * 2) If a change cannot be processed on the server, it has to be reverted on the client! This makes it necessary that the addToStack function is called with everything needed to perform a rollback of the change. This basically needs that the init-function in the room gets the new and old data. 
         * 3) Unfortunately, basic html events such as "onchange" do not provide the old and new value, but only the new. The best function we can use instead is a vue-watcher on the property. However, this has the problem that it is not only called when a change is done through the veu-app, but also if the data is changed from the room (because both raise the Proxy...). If we simply would watch for data changes and always send a change request to the server on change, we might end in an infinite loop, where client A changes something, B gets the change and modifies its data, the B's vue-watcher is raised, send the change to the server, client A gets it and there the watcher is raised again and so on...
         * 4) To ommit this problem, the best solution I have found is to have a special proeprty (here: propagateChange), which is set to true in an onchange event, hopefully raised before the watcher, and only if this is set to true, the change is sent to the server. The property then of course must be reset instantly.
         **/

        // TODO: eventually move this into vue

        let vueAppConfig = {
            data(){
                return {

                    developMode:false,
                    //showContestInfo: false,
                    show:'none', // will automatically show most reasonable thing at startup
                    overlay: undefined, // either undefined or 'createSeries' or 'config'
                    overlay2: undefined, // createSeries or undefined
                    // there will be no waiting page, but a limit to one client and this will be the first offline working page.
                    burgerChecked: false, // burger menu activated

                    onSeriesChangeCalcNextAth: true,

                    // show a clock on some screens; 
                    // start an interval to update the time in "mounted", if the time is odd, show the ":" between minutes and hours 
                    timeHours:'00',
                    timeMinutes:'00',
                    timeSeconds:'00',
                    timeOdd: false,
                    timeInterval: null, // the function to stop the interval

                    // the data is split into three parts, to be able to reuse the seriesAdmin parts
                    // TODO: also split computed properties, watchers and methods!

                    /* !!! data for SERIES CREATION and COMPETITION !!! */
                    categories:[],
                    meeting:{},     // informational only
                    disciplines:[], // informational only, to be able to show the name of the discipline and get some conf-data about the discipline, such as the max-reasonable height used to create the limit until where the heights shall be created
                    // TODO

                    //activateLate: false, // thing that cannot be drawn at startup, e.g. because they rely 
                    readOnly: false, // whether we can do changes or not (have a writingTicket or not)
                    
                    // info overlay
                    infoTitle: '',
                    infoContent:'',
                    infoVisible:false,

                    // yesNo overlay
                    yesNoVisible:false,
                    yesNoText: '',
                    yesNoTitle: '',
                    yesNoFunction:()=>{},

                    contest:{ // to be overridden as soon as the room-data arrives
                        status: 10,
                    },
                    startgroups: [],
                    relatedGroups: [],
                    // IMPORTANT: the contest data must be equivalent to the data in techHigh (which should be the case since this was based on the database structure)

                    // the names and id's of series and contest states:
                    // Note: the comment before the ejs-include only affects the first row of the included file; (thats why it still works)
                    // also gets seriesStates and participationStatesTech
                    //<%- include('contestStates.ejs') %>

                    numSeries:0,
                    //unassignedAthletes:[100,101, 102, 103],
                    unassignedAthletesCreate:[], // the array is manually populated when the initial series assignment is shown

                    series:[],
                    seriesObj:[], //{1:[15,16], 2:[17,18]},
                    sites : [],

                    /* !!! data for SERIES CREATION ONLY !!! */

                    propagateChange: false, // if the most recent change on the data (registered and monitored via "watchers") must be propagated to the server or not. (Not is typically the case when the changes comes from the server or any other change on the data done in the room but not in the data)

                    updateHeightIncrease: -1, // show change-line for height increases
                    heightIncreaseBeforeUpdate: {}, // resetting to previous values on height increase change
                    confForMod: {}, // the conf-object that is modified during conf changes. Recreated everytime conf-change is opened. At the end, the changes are either stored back to to the JSON in contest.conf (which then is applied to the computed property conf) or we just do nothing. 
                    newHeightIncreaseStart: undefined,
                    newInterval: undefined,

                    // series assignments (the different strategies that can be applied)
                    seriesAssignmentsAll: [
                    //includes<% seriesAssignments.forEach((SA)=>{ %>
                        // next include:<%- include(SA, {type:"js"}) %>,
                    //<% }); %>
                    ],
                    seriesAssignmentConfiguration:{}, // object will be populated by init functions of the respective functions
                    selectedSeriesAssignment: 0, // by default choose the first series assignment strategy

                    filterAthletes:'',
                    showFullDetails: false, // TODO: true for debugging only

                    /* !!! data for COMPETITION only !!! */
                    
                    xHeightTemp: -1, // temporary xHeight, until the height could be written to the DB and we get the actual index, we use this. Auto-increment into negative. When the correct key arrives, we must not only change the key in xHeight, but also in every result!  
                    xResultTemp: -1, // temporary xResult (needed for identical element id's; it is not referenced somewhere)
                    updateHeightIncrease: -1, // show change-line for height increases
                    heightIncreaseBeforeUpdate: {}, // resetting to previous values on height increase change

                    selectedSeries: 0, // which series we are working on. 
                    selectedSeriesLazy: 0, // which series we were working on before
                    //allHeights:[], // contains all already fixed and all predicted heights; computed property as of 2022-06
                    mode: 0, // 0: before all startHeights are set, 1=competition running (or is ready to be started), 2=jumpoff, 3=finished
                    currentHeight2: -1,  // in cm
                    currentJumpoffHeightInd2: -1, // during jumpoff, store here the current index in the jumpoff order
                    jumpoffHeightRequired: false, // true if a new height should be defined by the user
                    bestAtEachJumpoffHeight: [],
                    manualJumpoffHeight:0, // used to set the default next jumpoff height, before we actually see the input element
                    position:[], // array with the xStartgroup of all athletes starting on the current height, defining the order in the copetition; changed by the drag and drop part; in the jumpoff, it contains all athletes that still participate in the jumpoff, independent whether they aready jumped on the current height
                    positionNext: [], // the first element contains the index in the position array of the first athlete to come, the second element the second, and so on; during the main competition, positionNext has the same length as position; in the jumpoff, it can be smaller, since it only contains the athletes that will still jump on the current jumpoff-height, while position also contains the athletes that already jumped on the current height
                    tempRankingData: { // all data needed for ranking and for gettign the current athlete
                        //xSeriesStart
                        /*12:{
                            totalFailedAttempts: 0, // until and with the last valid hight
                            failedAttemptsSinceLastValid: 0, // after 3, the person is out of the competition. 
                            failedAttemptsOnLastValid: 0,
                            lastValidHeight: 0,
                            nextJumpingHeight: 0, // is this really needed? lastValidHeight should be enough..?
                            rank: 0, // (temporary, ) locally calculated rank. 
                        },
                        13:{

                        }*/
                    },
                    maxLastValidHeight: 0, // store which was the heighest, last valid height; required in the jumpoff
                    attempt2: 0, // in normal mode==1: 1 to 3; in jumpoff used to announce the i-th jumpoff height
                    attemptNext2: 0, // 1 to 3; for the next athlete (not the current). It is easier to store this value than to (re)calculate it for drawing.
                    
                    currentResultChange: {}, // the result that we are currently changing in the results view 1
                    currentResultString:'',
                    currentResultStringCopy:'',
                    resultKeyPressed: -1, // the key that was pressed last inside a addResult-input. If this is the esc-key, the blur event will not be evaluated. 
                    sortValue1: 1, // default: default order
                    sortValue2: 2, // default by rank
                    fakeProperty:0, // just needed to make sure that the sortedStart's are updated when the ranks change. (Start Vue's updating process)
                    temporaryDeactivation: false, // just to deactivate parts of the html form being rendered temporarily
                    timeOffset: 0,
                    roomAuxData:{
                        // uses xSeries to reference objects storing the following information:
                        // positionNext:[],
                        // position:[],
                        // attemptPeriod: 60, // s
                        // periodStartTime: undefined, // date-string of the server time when the attempt period started
                        // showAttemptPeriod: false,
                        // currentHeight
                        // currentJumpoffHeightInd
                        // attempt
                        // attemptNext 
                    },
                    autoAdvance: false,
                    attemptTime: "1:00", // TODO: aventually as time instead of string
                    attemptTimeSetting: "01:00",
                    shownTime: "0:00", // shall be string
                    timeUpdateInterval: undefined,
                    last15: false, // last 15 s
                    //currentResultRegistered: false,
                }
            },
            methods:{

                /* !!! methods for both SERIES creation and COMPETITION !!! */

                statusChanged(){
                    // check whether the current "show" property is meaningful; if not, automatically set a meaningful property
                    const matchStatusShow = [
                        {from: 0, to:39, shows:['rollCall', 'contestInfo']},
                        {from: 60, to:89, shows:['series', 'contestInfo']},
                        {from: 95, to:180, shows:['startheights', 'competition', 'order', 'resMod', 'resShow', 'settings', 'contestInfo']},
                    ]; 
                    const range = matchStatusShow.find(el=>el.from<=this.contest.status && el.to>=this.contest.status);
                    // check if the current selected show makes sense
                    if (range && range.shows.indexOf(this.show)==-1){
                        this.showAuto();
                    }
                },
                showAuto(){
                    // automatically show the most meaningful page (and results sorting) when the selected status is changed
                    if (this.contest.status<=39){
                        this.show='rollCall';
                    } else if (this.contest.status<=89 && this.contest.status>=60){
                        this.show = 'series';
                    } else if (this.contest.status<=180 && this.contest.status>=95){
                        // if there are all starheights defined, go to competition; otherwise to the startheights
                        if (this.mode==0){
                            this.show = 'startheights';
                        } else {
                            this.show = 'competition';
                            this.sortValue2 = 2;
                        }
                    } else if (this.contest.status>180){
                        this.show = 'resShow';
                        this.sortValue2 = 2;
                    }
                },

                statusBackgroundColor(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.backgroundColor;
                    }
                    return '#333333';
                },
                colorHexMultiplier(color, f){
                    // split the hex code into the three parts and multiply it with f
                    let R = Math.min(255,Math.round(f*parseInt(color.slice(1,3),16)));
                    let G = Math.min(255,Math.round(f*parseInt(color.slice(3,5),16)));
                    let B = Math.min(255,Math.round(f*parseInt(color.slice(5,7),16)));
                    return '#' + R.toString(16).padStart(2,0) + G.toString(16).padStart(2,0) + B.toString(16).padStart(2,0);
                },
                statusBackgroundColorHover(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return this.colorHexMultiplier(s.backgroundColor)
                        // split the hex code into the three parts and multiply it with 0.8
                        /*let f = 0.8;
                        let R = Math.round(f*parseInt(s.backgroundColor.slice(1,3),16));
                        let G = Math.round(f*parseInt(s.backgroundColor.slice(3,5),16));
                        let B = Math.round(f*parseInt(s.backgroundColor.slice(5,7),16));
                        return '#' + R.toString(16).padStart(2,0) + G.toString(16).padStart(2,0) + B.toString(16).padStart(2,0);*/
                    }
                    return '#111111';
                },
                statusTextColor(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.textColor;
                    }
                    return status;
                },
                statusText(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.text;
                    }
                    return status;
                },


                selectedSeriesChanged(){

                    let u = new URL(window.location.href)
                    u.searchParams.set('xSeries', this.series[this.selectedSeries].xSeries);
                    // this would reload the page
                    // window.location.href = u.href;
                    // this way only the path in the tab should be changed without any reload. 
                    window.history.replaceState(window.history.state, "", u.href)
                    
                },

                /**
                 * returns the index and the object itself of the first object where the property prop is equal to value 
                 * @param {array of objects} arr 
                 * @param {string} prop 
                 * @param {*} val 
                 * @return {array} [index, the object]
                 */
                findObjInArrayByProp(arr, prop, val){
                    for (let i=0; i<arr.length;i++){
                        if (arr[i][prop] == val){
                            return [i, arr[i]];
                        }
                    }
                    return [-1, {}];
                },
                autoManageAuxData(autoSaveToServer=true){

                    // this should all be done now (2022-06) in the room! It is wrong to do this in the view!

                    /*// based on the available series, automatically create (with default values) and delete the auxData per series.
                    // returns true if something has changed (so far 2022-06 not needed)

                    let changed = false;

                    // first make sure, that all currently available auxData have their respective series; otherwise delete them
                    for (let xSeries in this.roomAuxData){
                        let series = this.series.find(s=>s.xSeries==xSeries);
                        if (!series){
                            delete this.roomAuxData[xSeries];
                            changed=true;
                        }
                    }

                    // then check that all available series have also an entry in auxData
                    for (let series of this.series){
                        if (!(series.xSeries in this.roomAuxData)){
                            this.roomAuxData[series.xSeries] = {
                                positionNext:[],
                                position:[],
                                attemptPeriod: 60, // s; mainly related to the next athlete
                                periodStartTime: null, // date-string of the server time when the attempt period started
                                showAttemptPeriod: false, 
                                currentHeight: -1,
                                currentJumpoffHeightInd: -1,
                                attempt: 0,
                                attemptNext: 0,
                            };
                            changed = true;
                        }
                    }
                    
                    if (changed && autoSaveToServer && !this.readOnly){
                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                    return changed;*/
                },
                overlayInfo(title, content){
                    this.infoTitle = title;
                    this.infoContent = content;
                    this.infoVisible = true;
                },
                startUpdatingHeightIncrease(heightIncreaseIndex){
                    this.updateHeightIncrease = heightIncreaseIndex;
                    this.heightIncreaseBeforeUpdate = JSON.parse(JSON.stringify(this.confForMod.heightIncreases[heightIncreaseIndex]));
                },
                deleteHeightIncrease(index){
                    this.confForMod.heightIncreases.splice(index,1);
                    //this.createAllHeights();
                },
                saveUpdateHeightIncrease(){
                    this.updateHeightIncrease = -1;
                    this.sortHeightIncrease();
                    //this.createAllHeights();
                },
                abortUpdateHeightIncrease(index){
                    this.confForMod.heightIncreases[index] = this.heightIncreaseBeforeUpdate; // TODO: change this! It does not work, as it will remove the observers! TODO: check if this is still the case in Vue3!
                    this.updateHeightIncrease = -1;
                },
                addHeightIncrease(){
                    // check the values
                    let his = parseInt(this.newHeightIncreaseStart);
                    let hi = parseInt(this.newInterval);
                    if (isNaN(his) || isNaN(hi) || his<100 || hi<1){
                        this.infoContent = "<%= __('The entered values are not valid. Please note that both values must be entered in cm.') %>";
                        this.infoTitle = "<%= __('Invalid entry') %>";
                        this.infoVisible = true;
                        this.newHeightIncreaseStart = '';
                        this.newInterval = '';
                        return;
                    }

                    this.confForMod.heightIncreases.push({
                        heightIncreaseStartheight: his,
                        heightIncrease: hi
                    })
                    this.sortHeightIncrease();
                    //this.createAllHeights();
                    // reset the create field
                    this.newHeightIncreaseStart = undefined;
                    this.newInterval = undefined;
                },
                sortHeightIncrease(){
                    this.confForMod.heightIncreases.sort((el1, el2)=>{
                        return el1.heightIncreaseStartheight-el2.heightIncreaseStartheight;
                    });
                },
                sortSeries(){
                    //this.series.sort((s1, s2)=>s1.number-s2.number);
                },

                /* !!! methods for SERIES creation only !!! */


                dragEnded(evt){
                    // TODO implement here all the logic to derive the changes on athletes (in the version where the changes are propagated live.)
                    console.log(`from ${evt.from.id} to ${evt.to.id}`);
                },
                unassignedAthleteChanged(evt){
                    // override the default behavior (add/remove to/from 'displayData' within v-table, which does not work) and add/remove the element instead to/from 'unassignedAthletesCreate'
                    console.log('drag changed');
                    if ('removed' in evt){
                        // remove the element from 'unassignedAthletesCreate'
                        var i = this.unassignedAthletesCreate.indexOf(evt.removed.element);
                        if (i!=-1){
                            // should always come here; remove the element
                            this.unassignedAthletesCreate.splice(i,1);
                        }

                    } else if ('added' in evt){
                        // add the element to 'unassignedAthletesCreate'
                        this.unassignedAthletesCreate.push(evt.added.element)
                    }
                },
                seriesChanged(evt){
                    // TODO: implement reordering of series here
                    let test
                },
                seriesStateChanged(evt){
                    // not needed for series assignment
                },
                presentChanged(affectedRow){
                    // the present status of an athlete was changed. Hand over the request to the room. 
                    rCTech.room.updatePresentStateInit(affectedRow);
                },
                startUpdateConf(){
                    this.confForMod = this.parseConf(this.contest.conf);
                    this.overlay = 'config';
                },
                abortUpdateConf(){
                    this.overlay = undefined;
                },
                saveUpdateConf(){
                    this.overlay = undefined;
                    this.propagateChange = true; // store the change to server!
                    this.contest.conf = JSON.stringify(this.confForMod);
                    this.createAllHeights();
                },

                parseConf(jason){
                    // a valid JSON must contain {} or []; an empty string, as it might occur in the DB as a default, is not valid!
                    let conf;
                    try{
                        conf = JSON.parse(jason);
                    }catch(ex){
                        conf = {};
                    }
                    // make sure conf has an array called heightIncreases
                    if (!('heightIncreases' in conf)){
                        conf.heightIncreases = [];
                    }
                    return conf;
                },
                getCategory(xCategory, property='shortname'){
                    let cat = this.categories.find(c=>c.xCategory==xCategory)
                    if (cat){
                        return  cat[property]
                    } else {
                        return '';
                    }
                },
                getYearShort: function(dateString){
                    let d = new Date(dateString);
                    return d.getFullYear().toString().slice(-2);
                },
                endRollCallCreateSeries(){
                    this.propagateChange = true;
                    this.contest.status = 70;
                    this.show="series";
                    if(this.series.length==0){
                        this.showInitialSeriesAssignment();
                    }
                },
                formatHeight(heightInDB){
                    if (heightInDB){
                        return (heightInDB/100).toString() + " m";
                    }

                    return "";
                },
                formatTime(time, dateIfNeeded=true, secondsIfNeeded=true){
                    // return a formatted time value.
                    // if dateFrom=dateTo, only return the time; otherwise include the portion of date needed.
                    // if seconds are given, include them
                    let s = '';
                    let d = new Date(time);
                    if (dateIfNeeded && this.meeting.dateFrom != this.meeting.dateTo){
                        s += (d.getMonth()+1).toString().padStart(2,0);
                        s += "." + d.getDate().toString().padStart(2,0) + ' ';
                    }
                    s += `${d.getHours()}`.padStart(2, '0');
                    s += ":" + `${d.getMinutes()}`.padStart(2,'0');
                    if (secondsIfNeeded && d.getSeconds() != 0){
                        s += ':' + `${d.getSeconds()}`.padStart(2,'0');
                    }

                    return s;

                },
                showInitialSeriesAssignment: function(){
                    // create a list of all unassigned athletes for the initial series assignment. This is a separate list from the unassignedAthletes for the base configuration
                    this.resetInitialSeriesAssignment()
                    
                    this.overlay2 = 'createSeries';
                },
                addEmptySeriesInitial: function(){
                    // add an empty series to the seriesObj used in the inital series configuration tool
                    this.seriesObj.push({
                        number:this.seriesObj.length+1, 
                        xSite: null, 
                        status: 10, 
                        name:'', 
                        startsingroup:[],
                        datetime: this.contest.datetimeStart,
                    });
                },
                resetInitialSeriesAssignment: function(){
                    // recreate the set of unassigned athletes (=all startingroup where present=true): 
                    this.unassignedAthletesCreate = this.startgroups.filter(el=>el.present);

                    // delete all current series:
                    this.seriesObj = [];
                },
                createSeriesAutomatically: function(){
                    // first, reset current series
                    this.resetInitialSeriesAssignment();

                    // use selected algorithm to do automatic assignment
                    this.seriesAssignments[this.selectedSeriesAssignment].assignFunc.bind(this)()

                    // hide the overlay
                    this.overlay=undefined;
                    
                    // activate the ok button
                    this.$refs["saveInitSeries"].focus();
                },
                saveInitSeries: function(){
                    // save the initial series assignment
                    
                    // TODO: manually populate the actual series object; as soon as the change is processed on the server, the IDs will be replaced here with the actual IDs. 
                    // DIFFICULTY: Assume a client without connection, a series is (locally) generated, then it is deleted again. As soon as we have connection, the changes are sent to the server. However, the answer for the series creation cannot be processed completely, because the series was deleted meanwhile in the local data. HOW CAN THIS PROBLEM BE SOLVED?:
                    // IDEA 1: fail-safe programming. If an object does not exist anymore, simply do not care and just continue. This only works when we do not try to know, what element must be updated on data arrival via e.g. the series number, when we have a unique identifier, e.g. a temporary ID or we have function where the objects are referenced (not the position in the array or the array itself!)
                    
                    // The series structure should look like this
                    // series : all series objects
                    // series[0].heights : the heights jumped in this series
                    // series[0].seriesstartsresults : all athletes in this series
                    // series[0].seriesstartsresults[0].resultshigh : the results of the athletes

                    // do all the data managament in the room and not within vue!
                    rCTech.room.initialSeriesCreationInit(this.seriesObj);

                    this.overlay2 = undefined;

                    return false; // avoid reload of the page

                },
                deleteSeries(xSeries){
                    rCTech.room.deleteSeriesInit(xSeries);
                    this.yesNoVisible = false;
                    //this.showTimeUpdate();
                },
                initDeleteSeries(series){
                    this.yesNoTitle = '<%= __("Delete series") %>';
                    this.yesNoText = `<%= __("Do you want to delete series ${series.number}?") %>`;
                    this.yesNoFunction = ()=>{
                        this.deleteSeries(series.xSeries);
                    }
                    this.yesNoVisible = true;
                },
                addSeries: function(){
                    // add an empty series
                    let xSite = null
                    if (this.defaultSite){
                        xSite = this.defaultSite.xSite;
                    }
                    // add an empty series
                    rCTech.room.addSeriesInit(xSite, this.contest.datetimeStart);
                },
                deleteAllSeriesInit(){
                    // show warning
                    this.yesNoVisible = true,
                    this.yesNoText = '<%= __("Delete all series") %>';
                    this.yesNoTitle = `<%= __("Do you really want to delete all series? This can't be undone.") %>`;
                    this.yesNoFunction = this.deleteAllSeries;
                    
                },
                deleteAllSeries(){
                    this.yesNoVisible=false;
                    // the room functiuon will also change the local data
                    rCTech.room.deleteAllSeriesInit();
                },
                moveSeries: function(evt){
                    // called, when series are reordered
                    // no differentiation needed between moved/added/removed, since only move is possible; 

                    // Note: evt.moved.element is NOT the series-element in data.series, since we work on a copy seriesAsStartgroups
                    rCTech.room.moveSeriesInit(evt.moved.oldIndex, evt.moved.newIndex)

                },
                removeSSR: function(evt){
                    if ("added" in evt){
                        rCTech.room.deleteSSR(evt.added.element.seriesOriginal, evt.added.element.ssrOriginal)
                    }
                    // nothing to do when removed or moved; removed is handled in the add event of the series and moving within the unassignedAthletes is useless, since it is done via the sortable table.
                },
                changePosition: function(series, evt){
                    // this function is responsible for:
                    // - moving athletes within series
                    // - moving athletes beyond series
                    // - newly assign athletes to a series
                    // --> unassign athgletes is handled in "removeSSR"! 

                    // if an athlete is moved from one series to another, the function is called in both series, once with "removed" and once with "added" as the argument; if it is within the same series, then with "moved"
                    // evt .element .newIndex .oldIndex

                    if ("removed" in evt){
                        // if we do the work in added, we  do not need to do anything in removed, since the data will already be gone.
                        // the opposite way around is not possible, since it would not be known where to move the element to.
                    } else if ("added" in evt){

                        // differentiate whether the element is a seriesstartsresult or an xStartgroup (i.e. unassignedAthlete)
                        if ("athleteName" in evt.added.element){
                            // previously was an unassigned athlete
                            // create seriesstartsresults
                            rCTech.room.addSSR(series.seriesOriginal, evt.added.element.xStartgroup, evt.added.newIndex);
                        } else {
                            // athlete moved from one series to another; data is a seriesstartsresults entry
                            // hand over all needed references to the original, referenced objects. Make sure the room stays independent from the copied series structure within 
                            // let the room do the rest
                            rCTech.room.changePositionInit(evt.added.element.ssrOriginal, evt.added.element.seriesOriginal, series.seriesOriginal, evt.added.newIndex);
                        }


                    } else if ("moved" in evt){
                        // hand over all needed references to the original, referenced objects. Make sure the room stays independent from the copied series structure within 
                        // let the room do the rest
                        rCTech.room.changePositionInit(evt.moved.element.ssrOriginal, evt.moved.element.seriesOriginal, series.seriesOriginal, evt.moved.newIndex);
                    }
                    
                },

                /* !!! methods for COMPETITION only !!! */

                transferAuxData(){
                    // manually transfer some of the aux properties (position and positionNext are transferred in calculateNextAthlete)
                    // this is needed when the positionNext and position do not change (when a change arrives on reading clients), because normally those properties are transferred there
                    /*this.currentHeight2 = this.roomAuxDataSelected.currentHeight;
                    this.currentJumpoffHeightInd2 = this.roomAuxDataSelected.currentJumpoffHeightInd;
                    this.attempt2 = this.roomAuxDataSelected.attempt;
                    this.attemptNext2 = this.roomAuxDataSelected.attemptNext;*/

                },

                setTime(){
                    // set the time for the attempt period and show it

                    // split the time between hours (here: minutes) and minutes (here: seconds)
                    let t = this.attemptTimeSetting.split(':');
                    let minutes = Number(t[0])
                    let seconds = Number(t[1])
                    if (isNaN(minutes) || isNaN(seconds)){
                        alert('Time is not valid')
                    } else {
                        this.roomAuxDataSelected.attemptPeriod = minutes*60+seconds;

                        this.roomAuxDataSelected.showAttemptPeriod = true;
                        this.roomAuxDataSelected.periodStartTime = null;

                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                    this.updateShownTime();

                },
                birthdayToXX(bd){
                // convert the birthday to a two letter year code
                    return bd.substr(2,2);
                },
                getStartByXSeriesStart(xSeriesStart){
                    //return this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart == xSeriesStart)
                    // TODO: revert this, since it is only for debugging
                    let x = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart == xSeriesStart)
                    if (!x){
                        //alert('could not find the athlete!');
                        // return some empty properties; because there is a short moment where the change of the series is only "halfway" processed, e.g. the value in the model is already changed, but the "calculateNextAthlete" is not yet called

                        // TODO: this is NOT a solution, since the returned object is also used to reference xStartgroup, which will fail with this default, non.existing value 
                        return {
                            xSeriesStart: xSeriesStart,
                            xStartgroup: -1,
                            xSeries: -1,
                            position: -1,
                            resultOverrule: 0,
                            resultRemark:'',
                            qualification: 0,
                            startConf: '',
                            resultshigh:[],
                        }

                    }
                    return x; 
                },
                meterStr(cm){
                    // translate cm to m-string with two decimal points; without unit!
                    let m = cm/100; 
                    return m.toFixed(2);
                },
                evaluateHeightDeletable(){
                    // heights cannot be deleted when there are already results for this height or when it is a startheight of an athlete (the latter might actually be neglected, when we want to accept that the startheight points to something that does not exist anymore. However, we would have to rethink the startheight-selection-dropdown)

                    if (this.mode>0){
                        let series = this.series[this.selectedSeries];

                        // store a list of all heights which are in use
                        let usedHeights = [];

                        // the currentHeight (regular and jumpoff) shall not be deleted!
                        if (this.currentHeight>0){
                            let hEl = series.heights.find((h)=>h.height==this.currentHeight && h.jumpoffOrder==0)
                            usedHeights.push(hEl.xHeight);
                        }
                        if (this.currentJumpoffHeight>0){
                            let hEl = series.heights.find((h)=>h.height==this.currentJumpoffHeight && h.jumpoffOrder==this.currentJumpoffHeightInd)
                            usedHeights.push(hEl.xHeight);
                        }

                        // loop over every result of all athletes and create a long array with heights
                        series.seriesstartsresults.forEach((start)=>{
                            start?.resultshigh?.forEach((heightEl)=>{
                                usedHeights.push(heightEl.xHeight);
                                /*
                                // find the height element
                                let hInd = series.heights.findIndex((h)=>heightEl.xHeight==h.xHeight)
                                if (hInd==-1){
                                    alert('Something went terribly wrong! Please reload the page. (A result references a height that does not exist.)');
                                }
                                deletable[hInd]=false;*/
                            })
                        })

                        // loop over all startheights and add these heights too
                        series.seriesstartsresults.forEach((start)=>{
                            if (start.startConf){
                                let hEl = series.heights.find((h)=>h.height==start.startConf && h.jumpoffOrder==0)
                                usedHeights.push(hEl.xHeight);
                            }
                        })

                        // store the 'deletable' state to the height
                        series.heights.forEach((hEl)=>{
                            let ind = usedHeights.indexOf(hEl.xHeight);
                            hEl.deletable = ind==-1;
                        })
                    }

                },
                sortAthletes(seriesIndex){
                    /* this must be the only sort function run on the seriesstartsresults! They need to keep this order all the time. */
                    this.series[seriesIndex].seriesstartsresults.sort((el1, el2)=>{
                        return el1.position-el2.position;
                    })
                },
                sortAthletesAllSeries(){
                    for (i=0;i<this.series.length;i++){
                        this.sortAthletes(i);
                    }
                },
                
                createAllHeights(){
                    // create a list of al heights, i.e. the heights that already exist in the DB, the heights according to the increases and manual heights. This list is used e.g. as a dropdon to select the start height 

                    // TODO: must be called when the series was changed!
                    /*if (this.series.length>0){
                        // combine the already done heights with the heights specified in the heightIncreases
                        this.allHeights = this.sortedHeights.map((el)=>{return el.height}); // use "map" or analog here
                        // the index of the first heights must equal the index of the respective height in the series.heights array!!!

                        // add the future heights according to the current heightIncreases up to 6.5m in PV and up to 2.6m in HJ
                        
                        let maxHeight = 0;
                        this.conf.heightIncreases.forEach((el,ind)=>{
                            if (ind < this.conf.heightIncreases.length-1){
                                maxHeight = this.conf.heightIncreases[ind+1].heightIncreaseStartheight;
                            } else {
                                // get the correct value from a configuration (eventually also from baseDiscipline) 
                                maxHeight = this.disciplineConfiguration.heightMax;
                            }
                            for (let height=el.heightIncreaseStartheight;height<=maxHeight;height+=el.heightIncrease){
                                // not very efficient, but efficient enough
                                if (!this.allHeights.some(el=>{return el==height})){
                                    lastHeight = height;
                                    this.allHeights.push(height);
                                }
                            }
                        })
                        this.allHeights.sort((el1, el2)=>{return el1-el2})
                        // alert('heights done')
                    }*/
                },
                addHeight(height){
                    // this function can add a new height at any place in the array. If the height already exists, nothing is done. 
                    // The function will always check if the order of elements is correct and sort it if necessary

                    // make sure height is a number
                    height = Number(height);
                    if (isNaN(height)){
                        alert("ERROR2: the height is not a number!");
                        return;
                    }

                    // DO NOT USE THIS FUNCTION IN THE JUMPOFF!!
                    if (this.mode>1){
                        alert('Jumpoff is running. Do not use "addHeight" in jumpoff!');
                        return false;
                    }

                    let heights = this.sortedHeights;
                    // check if the height already exists
                    let heightExists = heights.some(el=>{if (el.jumpoffOrder==0 && el.height==height){return true}else{return false}})

                    if (!heightExists){
                        // add the height
                        let newHeight = {
                            xHeight: this.xHeightTemp--, // get the xHeight and then decrease it by one
                            xSeries: this.series[this.selectedSeries].xSeries, 
                            jumpoffOrder: 0,
                            height: height
                        };
                        
                        // do not actually add the height to the local data here, but through the room

                        // let the room add the height on the server
                        rCTech.room.addHeightInit(this.series[this.selectedSeries], newHeight)

                        this.sortHeightsAddOrder()
                        return true;
                    }else{
                        return false
                    }
                },
                sortHeightsAddOrder(){

                    /*
                    if (this.mode>0){
                        let heights = this.sortedHeights;

                        // sort the array
                        heights.sort((el1, el2)=>{
                            // sort: 1st: jumpoff order, 2nd, height
                            if (el1.jumpoffOrder==el2.jumpoffOrder) {
                                return el1.height-el2.height
                            } else {
                                return el1.jumpoffOrder - el2.jumpoffOrder;
                            }
                        })

                        // redefine the heightOrder
                        // is not used and not a real property of the DB 
                                              
                    }*/


                },
                addManualHeightEnter(e){
                    // when the enter key is pressed to add a new height
                    if (e.keyCode===13){
                        this.addManualHeight();
                    }
                },
                addManualJumpoffHeightEnter(e){
                    // when the enter key is pressed to add a new height
                    if (e.keyCode===13){
                        this.addManualJumpoffHeight();
                    }
                },
                addManualHeight(){
                    // TODO: check the inputted value and transform it to cm
                    let val = document.getElementById('manualHeight').value;

                    let ret;
                    if (this.mode==2){
                        ret = this.addHeightJumpoff(val);
                    } else {
                        ret = this.addHeight(val);
                    }

                    if(ret){
                        // success
                        document.getElementById('manualHeight').value = "";
                        this.createAllHeights();
                        this.evaluateHeightDeletable();
                    }else{
                        // failure (e.g. as the height exists already)
                        alert("<%= __('Height could not be added, e.g. because it exists already.') %>");
                    }

                    // we must now recalculate who is the next athlete. 
                    // Note: due to the watcher on series, either tempRangingData or calculateNextAthlete will anyway be called; however, we must make sure that calculateNextAthlete is called always
                    this.onSeriesChangeCalcNextAth = true;
                    //this.calculateNextAthlete();
                    
                },
                addManualJumpoffHeight(){
                    // TODO: check the inputted value and transform it to cm
                    //let val = document.getElementById('manualJumpoffHeight').value;
                    let val = this.manualJumpoffHeight;

                    let ret;
                    if (this.mode==2){
                        ret = this.addHeightJumpoff(val);

                        if(ret){
                            // success
                            this.manualJumpoffHeight = 0;
                            this.createAllHeights();
                            this.evaluateHeightDeletable();
                            this.jumpoffHeightRequired = false;
                        }else{
                            // failure (e.g. as the height exists already)
                            alert("<%= __('Height could not be added.') %>");
                        }

                        // we must now recalculate who is the next athlete. 
                        // Note: due to the watcher on series, either tempRangingData or calculateNextAthlete will anyway be called; however, we must make sure that calculateNextAthlete is called always
                        this.onSeriesChangeCalcNextAth = true;
                        //this.calculateNextAthlete();
                    } 
                    
                },
                addHeightJumpoff(height){

                    height = Number(height)
                    if (isNaN(height)){
                        alert("ERROR1: the height is not a number!");
                        return;
                    }

                    // ONLY USE THIS FUNCITON IN JUMPOFF
                    if (this.mode<2){
                        alert('This function is only to be used during the jumpoff');
                        return false;
                    }

                    let newHeight = {
                        xHeight: this.xHeightTemp--,
                        xSeries: this.selectedSeries, 
                        jumpoffOrder: this.bestAtEachJumpoffHeight.length + 1,
                        height: height
                    }

                    // do not actually add the height to the local data here, but through the room

                    // let the room add the height on the server
                    rCTech.room.addHeightInit(this.series[this.selectedSeries], newHeight)

                    this.sortHeightsAddOrder();
                    return true;

                },
                deleteHeight(index){

                    // get the height
                    let height = this.sortedHeights[index];

                    rCTech.room.deleteHeightInit(height);

                    this.createAllHeights();
                    if (this.mode==2){
                        // in jumpoff, if we delete the next height, the menu showing "create next height" must return --> will appear when the next athletes were calculated
                        this.currentJumpoffHeightInd = 0;
                    }

                    // Note: due to the watcher on series, either tempRangingData or calculateNextAthlete will anyway be called; however, we must make sure that calculateNextAthlete is called always
                    this.onSeriesChangeCalcNextAth = true;
                    //this.calculateNextAthlete(); 
                },
                replaceXResult(xSeriesStart, oldKey, newKey){
                    alert('TODO')

                    // replace the old key by the new key
                    // TODO

                    // if the result is currently changed, we need to change the key of the input element there, as it will be invalid afterwards otherwise
                    let el = document.getElementById('resChange' + oldKey)
                    if (el){
                        el.id = 'resChange' + newKey;
                    }
                },
                startHeightChanged(xSeriesStartEl){
                    // if the chosen height is not yet fixed (i.e. in the heights array of the series), add it to the heights

                    this.addHeight(xSeriesStartEl.startConf); // will check if it is new automatically

                    this.evaluateHeightDeletable();

                    // send the change to the server
                    rCTech.room.updateSSRInit(xSeriesStartEl);


                    // check if the competition can start already
                    this.onSeriesChangeCalcNextAth=true;
                    //this.calculateNextAthlete();
                },
                updateSSR(ssr){
                    // send the change to the server
                    rCTech.room.updateSSRInit(ssr);

                },
                allStartHeightsDefined(){
                    if (this.series.length==0){
                        return false;
                    }
                    let allDefined = this.series[this.selectedSeries].seriesstartsresults.every(el=>{
                        if (el.startConf){
                            return true;
                        }else {
                            this.mode = 0;
                            return false;
                        }
                    })

                    return allDefined;

                },
                calculateTemporaryRankingData(){
                    // calculate all data needed for ranking and to find out, who is next
                    // this is done independently of the current mode

                    /*                             12:{
                        totalFailedAttempts: 0, // until and with the last valid hight
                        failedAttemptsSinceLastValid: 0, // after 3, the person is out of the competition. 
                        failedAttemptsOnLastValid: 0,
                        lastValidHeight: 0,
                        lastFinishedHeight:,
                        firstUnfinishedHeight:,
                    },*/

                                                    /*{
                            xResult:1,
                            xHeight: 1, // the link to the height!
                            //resultshighSortOrder, // not needed!, the current position (temporary different athlete order) is handled differently
                            resultsHighFailedAttempts: 1, // how many fails on this hight
                            resultsHighValid: true, 
                            resultsHighPassed:false // verzichtet (-)
                        },*/

                    // maybe we need to sort the results first...

                    // TODO: cleanup the jumpoff; some variable were introduced, which are not used anymore.

                    // jumpoff statistics for ranking: 
                    let maxNumJumpoffAttempts = 0;
                    this.bestAtEachJumpoffHeight = []; // [0,0,1] --> at the first two jumpoff heights, the best athlet has failed (i.e. all have failed), at5 the third height at least one athlete has passed the bar. This is (probably) needed for the ranking

                    // go through every result of every athlete; assumes that the results are sorted
                    this.series[this.selectedSeries].seriesstartsresults.forEach((start)=>{

                        /*if (start.resultOverrule>0){
                            // i.e. when DNS, retired, DQ, ...
                            // TODO: is this needed?
                        }else{*/

                        let totalFailedAttempts = 0;
                        let failedAttemptsSinceLastValid = 0;
                        let failedAttemptsOnLastValid = 0;
                        let lastValidHeight = 0;

                        let lastFinishedHeight = undefined; // in cm, finished = valid or passed
                        let firstUnfinishedHeight = undefined; // in cm

                        // jumpoff
                        let numFailedJumpoffAttempts = 0; // probably only the array jumpoffResults is needed
                        let numValidJumpoffAttempts = 0; // probably only the array jumpoffResults is needed
                        let jumpoffResults = []; // valid=true, failed=false

                        // if resultOverrule is >0 (i.e. DNS, DQ, retired) then the athlete is 'finished'
                        let finished = start.resultOverrule>0;
                        start.resultshigh.forEach((heightResult)=>{
                            // find out whether it is a regular height (i.e. not jumpoff)
                            let heightEl = this.sortedHeights.find((el)=>{return el.xHeight == heightResult.xHeight});
                            //let heightEl = this.sortedHeights[hIndex];
                            if (!heightEl){
                                alert('Fatal error: Result for a non-existing height appeared. Should never happen!');
                                return;
                            }
                            // normal and jumpoff results must be handled separately 
                            if (heightEl.jumpoffOrder==0){    
                                // normal
                                if (heightResult.resultsHighValid){
                                    if (lastValidHeight<heightEl.height){
                                        lastValidHeight = heightEl.height;
                                        failedAttemptsOnLastValid = heightResult.resultsHighFailedAttempts;
                                    }
                                    failedAttemptsSinceLastValid = 0;
                                }else{
                                    failedAttemptsSinceLastValid += heightResult.resultsHighFailedAttempts;

                                    if (failedAttemptsSinceLastValid >= 3){
                                        finished = true;
                                    }                                                 
                                }
                                // do NOT count failed attempts when it is after the last valid height;
                                // this cannot be included in the if below, since it would then count XX- X with 2 failed attempts, which is wrong.
                                if (lastValidHeight>=heightEl.height){
                                    totalFailedAttempts += heightResult.resultsHighFailedAttempts;
                                }
                                if (heightResult.resultsHighValid || heightResult.resultsHighPassed){
                                    if (lastFinishedHeight){
                                        lastFinishedHeight = Math.max(heightEl.height, lastFinishedHeight);
                                    } else {
                                        lastFinishedHeight = heightEl.height;
                                    }
                                } else {
                                    if (!firstUnfinishedHeight){
                                        firstUnfinishedHeight = heightEl.height;
                                    } else {
                                        firstUnfinishedHeight = Math.min(heightEl.height, firstUnfinishedHeight); // the elements may be out of order!
                                    }
                                }
                                
                            }else{
                                // jumpoff
                                if (heightResult.resultsHighValid){
                                    numValidJumpoffAttempts += 1;
                                    jumpoffResults[heightEl.jumpoffOrder-1] = true;
                                } else {
                                    numFailedJumpoffAttempts += 1;
                                    jumpoffResults[heightEl.jumpoffOrder-1] = false;
                                }
                                maxNumJumpoffAttempts = Math.max(maxNumJumpoffAttempts, numValidJumpoffAttempts+numFailedJumpoffAttempts);
                                
                            }
                        })
                        
                        this.tempRankingData[start.xSeriesStart] = {
                            totalFailedAttempts: totalFailedAttempts, // until and with the last valid hight
                            failedAttemptsSinceLastValid: failedAttemptsSinceLastValid, // after 3, the person is out of the competition. 
                            failedAttemptsOnLastValid: failedAttemptsOnLastValid,
                            lastValidHeight: lastValidHeight,
                            //nextJumpingHeight: 0, // TODO?
                            finished: finished,
                            lastFinishedHeight: lastFinishedHeight,
                            firstUnfinishedHeight: firstUnfinishedHeight,
                            numFailedJumpoffAttempts: numFailedJumpoffAttempts,
                            numValidJumpoffAttempts: numValidJumpoffAttempts,
                            jumpoffResults: jumpoffResults,
                            resultOverrule: start.resultOverrule, // just needed for jumpoff
                            jumpoffFailedAtI: 10000, // do not change this value, or change it as well in 'calculateNextAthlete'
                        }
                        
                        if (lastValidHeight>this.maxLastValidHeight){
                            this.maxLastValidHeight = lastValidHeight;
                        }

                    })

                    // -----------
                    // additional analysis for jumpoff:
                    // calculate the best result on every jumpoff height
                    Object.values(this.tempRankingData).forEach((tempRankData)=>{
                        if (tempRankData.jumpoffResults.length>0){
                            tempRankData.jumpoffResults.forEach((valid, i)=>{
                                if (this.bestAtEachJumpoffHeight[i]==undefined){
                                    // no best result yet defined, so take this result as a start
                                    this.bestAtEachJumpoffHeight[i]=valid;
                                }else{
                                    // best result already defined; can only get 'better' (from failed to valid)
                                    if (valid){
                                        this.bestAtEachJumpoffHeight[i]=valid;
                                    }
                                }
                            })
                        }
                    })

                    // calculate when the athletes have failed in the jumpoff and/or what would be his next height
                    Object.values(this.tempRankingData).forEach((tempRankData)=>{
                        tempRankData.outOfJumpoff = false; // TODO: this probably does not work like this... lets see how it works in ranking. (The value is also set for athletes that are not in the jumpoff; however, it will be the same for all those athletes and thus doesnt matter)
                        if (tempRankData.jumpoffResults.length>0){
                            // compare every heigh with the best result at this height
                            for (let i=0; i<tempRankData.jumpoffResults.length;i++){
                                if (!tempRankData.jumpoffResults[i] && this.bestAtEachJumpoffHeight[i]){
                                    tempRankData.jumpoffFailedAtI = i;
                                    tempRankData.outOfJumpoff = true;
                                }
                            }
                        } 
                        if (!tempRankData.outOfJumpoff) {
                            if (tempRankData.resultOverrule==1){
                                // athlete has retired --> "failed" at his last height +1
                                tempRankData.jumpoffFailedAtI = tempRankData.jumpoffResults.length;
                            }
                            // write as if they failed on the next height --> new: shall remain at 10000!
                            //tempRankData.jumpoffFailedAtI = this.bestAtEachJumpoffHeight.length+1;
                        }
                    })
                    //-------------

                    // the actual ranking:
                    
                    // create an array-copy of the starts
                    let starts = this.series[this.selectedSeries].seriesstartsresults.slice();

                    // sort this array:
                    starts.sort((s1, s2)=>{
                        if (Math.max(s1.resultOverrule,1) !=  Math.max(s2.resultOverrule,1)){ // regular (0) and retired (1) must be treated the same
                            return s1.resultOverrule - s2.resultOverrule; // this should meansingfully sort also within resultOverrule
                        }
                        // both result overrules are the same or both <2
                        if (s1.resultOverrule <2){
                            // usual result: 
                            let r1 = this.tempRankingData[s1.xSeriesStart];
                            let r2 = this.tempRankingData[s2.xSeriesStart];

                            // 1) lastValidHeight
                            if (r1.lastValidHeight != r2.lastValidHeight){
                                return r2.lastValidHeight - r1.lastValidHeight; // the lower the more to the right.
                            }

                            // 2) failed attempts on last valid height
                            if (r1.failedAttemptsOnLastValid != r2.failedAttemptsOnLastValid){
                                return r1.failedAttemptsOnLastValid - r2.failedAttemptsOnLastValid; // the lower the more to the left
                            }

                            // 3) failed attempts in total
                            if (r1.totalFailedAttempts != r2.totalFailedAttempts){
                                return r1.totalFailedAttempts - r2.totalFailedAttempts; // the lower the more to the left
                            }

                            // jumpoff:

                            // 4) failed later in jumpoff
                            if (r1.jumpoffFailedAtI != r2.jumpoffFailedAtI){
                                return r2.jumpoffFailedAtI - r1.jumpoffFailedAtI; // the heigher the better
                            }

                            // 5) it is also deemed 'failure' when an athlete retired after the last height. Thus if both have failed at the same height, but one is finally called retired, he actually left before and thus is ranked worse
                            if (r1.resultOverrule != r2.resultOverrule){
                                return r1.resultOverrule - r2.resultOverrule;
                            }

                        } 

                        // equal results
                        return 0;

                    })

                    // current rank during rank assignment
                    let rank=1;
                    // from the sorted array, derive the ranking
                    for (let i=0; i<starts.length;i++){
                        if (starts[i].resultOverrule<2){
                            let r2 = this.tempRankingData[starts[i].xSeriesStart];
                            if (i>0){
                                let r1 = this.tempRankingData[starts[i-1].xSeriesStart];
                                // check if the element equals the last
                                let equal = (r1.lastValidHeight == r2.lastValidHeight && r1.failedAttemptsOnLastValid == r2.failedAttemptsOnLastValid && r1.totalFailedAttempts == r2.totalFailedAttempts && r2.jumpoffFailedAtI == r1.jumpoffFailedAtI && r1.resultOverrule == r2.resultOverrule); 
                                if (!equal){
                                    rank = i+1;
                                }
                            }
                            // assign a rank only if there is a valid height
                            if (r2.lastValidHeight){
                                this.tempRankingData[starts[i].xSeriesStart].rank = rank;
                            }else{
                                this.tempRankingData[starts[i].xSeriesStart].rank = 0;
                            }
                            
                        } else {
                            this.tempRankingData[starts[i].xSeriesStart].rank = 0; // TODO: eventually, no rank is something undefined instead of 0 or we use rank as a string and tranlate the overrule-code here to DQ, DNS, DNF, ...
                        }
                        
                    }



                },
                calculateNextAthlete(){

                    // Jumpoff: 
                    /*
                    - the jupoff does not necessary take place --> is defined in the jumpoff-variable
                    - ranking in jumpoff: retired athletes are last, in the order of their retiring (i.e. 3 athletes in jumpoff, one retires at the beginning (--> rank 3), the second retires after three more heights (--> second rank) while tha last would continue (--> rank 1))
                    - attention: it is possible that all athletes retire at the same time at any time in the competition. Then all are ranked first. 
                    - the ranking should only be done after a height is jumped by all athletes in the jumpoff (in order to avoid that eventually one person is temporary ranked second, if he still has the chance to be in competition afterwards!)
                    - ranking the following way: (1) more valid is better; (2) more failed is better (i.e. the athlete retired later; only used when >2 athletes in jumpoff)
                    Note: if all athletes want to withdraw, the last withdrawel has to be made in the change-result section; until then, the remaining person is declared the winner.
                    */

                    //this.currentResultRegistered = false;

                    let series = this.series[this.selectedSeries];

                    // if the selectedSeries changes, we must reset position and positionNext to make sure the algorithm trying to alter the position array as little as possible when athletes are added or removed works as it should. 
                    if (this.selectedSeries != this.selectedSeriesLazy) {
                        this.position = [];
                        this.positionNext = [];
                    }

                    // if the series is empty or no series exists yet (or the pre-"selected" series does not exist), do not start the subsequent calculation!
                    if (!series || series.seriesstartsresults.length==0){
                        this.mode=0;
                        return
                    }

                    // check if all startheights are given
                    if (this.allStartHeightsDefined()){

                        // TODO: eventually we should determine the mode automatically as well..? This would also imply changes in calculateTemporaryRankingData

                        // change the mode to competition running, if it was at 'define startheigts' before. (This check is needed since otherwise it would leave jumpoff!) 
                        if (this.mode==0){
                            this.mode=1;
                        }

                        // the currentHeight is calculated automatically:

                        // find the lowest height, where an athlete is in competition (min(nextJumpingHeight)) (neither retired nor DQ nor DNS...) or get the next height after the last valid height of an athlete. 

                        this.calculateTemporaryRankingData();

                        // for athletes that are not yet in competition (no results), get the startheight; for athletes that are in competition, use the lower of lastFinistedHeight+next and firstUnfinished
                        let lowestUnfinished = 1000; // here we can also include the startheight of athletes that were not in competition yet
                        let lowestFinishedDefault = 1000;
                        let lowestFinished = lowestFinishedDefault; // to calculate the next height after this

                        // calculate some Jumpoff-stuff within the same loop
                        let numJumpoffParticipants = 0;
                        let nextJumpoffHeightInd = 1000; // the index in the jumpoffResults-Array represnting the jumping height th next athlete is doing. It is not necessarily the next coming height, e.g. when a few athletes already jumped on that height, while at least one has not.

                        let mainCompetitionFinished = true;
                        series.seriesstartsresults.forEach(start=>{

                            let tmp = this.tempRankingData[start.xSeriesStart];
                            if (!tmp.finished){

                                mainCompetitionFinished = false;

                                // athlete is still in competition
                                if (start.resultshigh.length){
                                    if (tmp.firstUnfinishedHeight){ // might be undefined, when there is no unfinished height
                                        lowestUnfinished = Math.min(lowestUnfinished, tmp.firstUnfinishedHeight);    
                                    }
                                    if (tmp.lastFinishedHeight){ // undefined when there is no finished height yet
                                        // at least one height is finished for this athlete
                                        lowestFinished = Math.min(lowestFinished, tmp.lastFinishedHeight);
                                    }
                                    
                                } else {
                                    // no result yet; use the startheight
                                    lowestUnfinished = Math.min(lowestUnfinished, start.startConf);
                                }
                            }
                            if(tmp.finished && tmp.rank==1) {
                                // finished, and rank 1 --> currently part of the jumpoff
                                numJumpoffParticipants += 1;

                                // get the next height in the jumpoff:
                                if (nextJumpoffHeightInd>tmp.jumpoffResults.length && tmp.jumpoffFailedAtI==10000){
                                    nextJumpoffHeightInd=tmp.jumpoffResults.length+1;
                                }
                            }
                            if (tmp.jumpoffResults.length>0){
                                // if an older jumpoffResult is deleted (which should NOT be done!), it would create a hole (<empty>) in the jumpoffResults --> in that case, the currentJumpoffHeight would be the first empty element in the array!
                                let firstUndef = tmp.jumpoffResults.findIndex(val=>val==undefined);
                                if (firstUndef>=0 && nextJumpoffHeightInd>firstUndef){
                                    nextJumpoffHeightInd = firstUndef;
                                    console.log('There was a jumpoff-height missing. This should not happen, since parts of the code might not work as expected in that case.')
                                    // then we might also have to add this person to the count of the number of participants in the jumpoff:
                                    if (!(tmp.finished && tmp.rank==1)){
                                        numJumpoffParticipants++;
                                    }
                                }
                            }


                        })

                        // when the competition is over, stop here (the rest is not needed and would not work appropriately)
                        if (mainCompetitionFinished){
                            if (numJumpoffParticipants>1 && this.conf.jumpoff){
                                this.mode = 2;
                            } else {
                                this.mode = 3;
                                this.positionNext = [];
                                this.position = [];
                                return; // dont need to continue when the competition is over
                            }
                        } else {
                            this.mode = 1;
                        }

                        if (this.mode==1){

                            let newCurrentHeight;
                            if (lowestFinished == lowestFinishedDefault){
                                // nothing finished yet, thus always lowestUnfinished is governing
                                newCurrentHeight = lowestUnfinished;
                            } else {
                                // the current height is the minimum of: lowestUnfinishedHeight and the next height after the lowestFinishedHeight
                                let i = this.allHeights.indexOf(lowestFinished);
                                let lowestNextHeight = this.allHeights[i+1];
                                
                                newCurrentHeight = Math.min(lowestNextHeight,lowestUnfinished)
                            }

                            // get/create the height-element (it is actually not needed later)
                            let hEl = series.heights.find(h=>h.height==newCurrentHeight && h.jumpoffOrder==0);
                            
                            if (!hEl){
                                if (!this.readOnly){
                                    // create the height, as it does not exist yet
                                    this.addHeight(newCurrentHeight);
                                    hEl = series.heights.find(h=>h.height==newCurrentHeight && h.jumpoffOrder==0);
                                } else {
                                    // cannot continue for teh moment, since the heigght is not available and we cannot create it. The server will soon send the new height and we can continue past here.
                                    return;
                                }
                            }

                            // calculate the new position and positionNext arrays; however, do NOT directly store them to this, but do this copy at the end, based on whether this client is writing or not!
                            let position=[], positionNext=[];
                            if (newCurrentHeight != this.currentHeight2){
                                // the currentHeight has changed! We must a.o. recreate the positions array
                                this.currentHeight2 = newCurrentHeight;

                                // if the currentHeight changes:
                                // 2022-03: I think the following paragraph is wrong. I indeed implemented an algorithm to find the bast position and add the athlete there!
                                // OLD: 
                                // as it is hardly possible to transfer the different order in 'positions' compared to the default given in sSeriesStart, the position is always resetted to the default. 
                                // WHY is is hardly possible: The positions array always stores, who is still in competition on the current height (i.e. not overall). That means at the end, it will finally only contain the very last athlete, as all the others either failed 3 times or have a valid result already. Now we could think of not removing the elements from the array when the athlete do not jump on this height anymore, which would make transferring the changed order much simpler. However, if the user wants to change the order on the current height e.g. in the second attempt, then it would be strange if also athletes would appear that have passed already in the first attempt.

                                // position gives the current (during this height) order of athletes; create this array from scratch:

                                // find out what athletes are starting on this height: not finished, startheight <= currentHeight, has not finished this height yet
                                // first add all starts to the following array, before creating the final position array (TODO: or should we keep the array with the full data? I'm a bit worried because of the observers bound to the object for Vue...)
                                let starts = [];
                                series.seriesstartsresults.forEach(el=>{
                                    if (el.startConf <= this.currentHeight2 && !this.tempRankingData[el.xSeriesStart].finished && (this.tempRankingData[el.xSeriesStart].lastFinishedHeight === undefined || this.tempRankingData[el.xSeriesStart].lastFinishedHeight < this.currentHeight2)){
                                        starts.push(el);
                                    }
                                })

                                // sort the starts
                                starts.sort((a,b)=>{
                                    return a.position-b.position
                                })

                                // derive the position array
                                position = []; 
                                starts.forEach(el=>position.push(el.xSeriesStart));
                            } else {
                                // update the position array, without recreating it from default in order not to lose the current changes to it. 
                                // check for every athlete that should jump on the current height whether he is in the position array or not; finally delete all those entries that are not jumping (anymore)
                                let posCopy = this.position.slice(); 
                                position = this.position.slice();

                                series.seriesstartsresults.forEach(el=>{
                                    if (el.startConf <= this.currentHeight2 && !this.tempRankingData[el.xSeriesStart].finished && (this.tempRankingData[el.xSeriesStart].lastFinishedHeight === undefined || this.tempRankingData[el.xSeriesStart].lastFinishedHeight < this.currentHeight2)){
                                        
                                        let ind = this.position.findIndex(el2=>el2==el.xSeriesStart)
                                        if (ind == -1){
                                            // start must be added on the best position!
                                            // first create an array with the default positions of the athletes in the current positions-list
                                            let positionDefault = Array(this.position.length);
                                            for (let i=0;i<this.position.length;i++){
                                                let start = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart==this.position[i])
                                                if (!start){
                                                    alert('Error: Something went terribly wrong.');
                                                }
                                                positionDefault[i] = start.position;
                                            }

                                            // go through the possible positions (number of positions: position.length+1)
                                            // best position is where most of the athletes would be correctly before and after according to the position default
                                            let minSortedWrong = this.position.length+10;
                                            let minSortedWrongIndex = -1;
                                            for (let i=0; i<=this.position.length;i++){
                                                let sortedWrong = 0;
                                                // before:
                                                for (let j=0;j<i;j++){
                                                    if (positionDefault[j]>el.position){
                                                        sortedWrong++;
                                                    }
                                                }
                                                // after: 
                                                for (let j=i;j<this.position.length; j++){
                                                    if (positionDefault[j]<el.position){
                                                        sortedWrong++;
                                                    }
                                                }
                                                if (sortedWrong<minSortedWrong){
                                                    minSortedWrong = sortedWrong;
                                                    minSortedWrongIndex = i;
                                                }
                                            }

                                            // add the element at the best position
                                            position.splice(minSortedWrongIndex,0,el.xSeriesStart);

                                        } else {
                                            // remove from posCopy
                                            let ind = posCopy.indexOf(el.xSeriesStart);
                                            if (ind==-1){
                                                alert('Error: Should not happen...');
                                            }else{
                                                posCopy.splice(ind,1);
                                            }
                                        }
                                    }
                                })

                                // delete all elements in position that are still in posCopy
                                posCopy.forEach(el=>{
                                    let ind = position.indexOf(el);
                                    position.splice(ind,1);
                                })
                                // done.

                            }


                            // find out which athlete is the next
                            // 1. find out the minimum number of failed attempts
                            let minFailedAttempts = 10;
                            let minFailedAttemptsCount = 0; // how many times this number of attempts appeared
                            position.forEach(xSeriesStart=>{
                                // get the corresponding start
                                let start = series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart);

                                // get the correspnding height result (if there is one! --> otherwise minFailedAttempts is zero!)
                                let hAth = start.resultshigh.find((el)=>{
                                    h = series.heights.find(hEl=>el.xHeight==hEl.xHeight); // if everything is correct, must always find an element
                                    if (h===undefined){
                                        alert('ERROR: Should never be here. Could not find the corresponding height for a given xHeight.');
                                        throw('ERROR: Should never be here. Could not find the corresponding height for a given xHeight.');
                                        
                                    }
                                    return h.height==this.currentHeight2;
                                })
                                if (hAth===undefined){
                                    if (minFailedAttempts==0){
                                        minFailedAttemptsCount++;
                                    }else{
                                        minFailedAttempts=0;
                                        minFailedAttemptsCount=1;
                                    }
                                }else{
                                    if (minFailedAttempts>hAth.resultsHighFailedAttempts){ 
                                        minFailedAttempts=hAth.resultsHighFailedAttempts;
                                        minFailedAttemptsCount=1;
                                        
                                    }else if(minFailedAttempts == hAth.resultsHighFailedAttempts){
                                        minFailedAttemptsCount++;
                                    }
                                }

                            })
                            // now we know what attempt we are in (--> minFailedAttempts+1)
                            this.attempt2 = minFailedAttempts+1;
                            this.attemptNext2 = minFailedAttemptsCount>1 ? minFailedAttempts+1 : minFailedAttempts+2;

                            // now, create the order of the next athletes (positionNext):

                            
                            // OLD:                             
                            //if ((!this.readOnly) || positionNext.length==0){
                            // NEW: 
                            if (true){
                                // get the first athlete where minFailedAttempts == hEl.resultsHighFailedAttempts
                                let currentAthlete = -1;
                                // reinitialize the positionNext array
                                positionNext = Array(position.length);
                                let n = 0;
                                for (let a = minFailedAttempts; a<3; a++){
                                    for (let i=0;i<position.length;i++){
                                        // check for every athlete in the order of the position array, if failed attempt == a; then he starts as n'th athlete from now.
                                        let xSeriesStart = position[i];

                                        // get the corresponding start
                                        let start = series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart);
                                        // get the correspnding height result (if there is one! --> otherwise minFailedAttempts is zero!)
                                        let hAth = start.resultshigh.find((el)=>{
                                            h = series.heights.find(hEl=>el.xHeight==hEl.xHeight); 
                                            return h.height==this.currentHeight2;
                                        })
                                        if (hAth==undefined){
                                            if (minFailedAttempts != 0){
                                                alert ("Error: Should never get here!");
                                            } else {
                                                // if hAth is undefined, then the athlete has no result yet on this height, i.e. his resultsHighFailedAttempts=0
                                                if (a==0){
                                                    positionNext[n] = i;
                                                    n++;
                                                }
                                            }
                                        }else {
                                            if (hAth.resultsHighFailedAttempts==a){
                                                positionNext[n] = i
                                                n++;
                                            }
                                        }
                                    }
                                }
                                if (n != position.length){
                                    alert('Error: something went wrong in this loop.. :-(( The order of next athletes might be wrong.')
                                } 
                            } 

                            //
                            if (this.readOnly){
                                // we actually do not use the position and positionNext data that we just have created, but we use the data that was given via the aux data. But we compare the length of the array in order to detect problems (which should never happen.)
                                if (position.length != this.roomAuxData[series.xSeries].position.length || positionNext.length != this.roomAuxData[series.xSeries].positionNext.length){
                                    console.log('Note: the number of athletes jumping on the current height was calculated differently by this browser than given by the data from the server. This may regulary hapen when the result has already arrived on reading clients, but not the new aus data. If this happens in other constellations, please report the constellation, where this happened, to the developers.')
                                }
                                this.positionNext = this.roomAuxData[series.xSeries].positionNext.slice(); // we use slice to create a copy!
                                this.position = this.roomAuxData[series.xSeries].position;

                                //this next part should not be needed anymore
                                /*this.currentHeight2 = this.roomAuxData[series.xSeries].currentHeight;
                                this.currentJumpoffHeightInd2 = this.roomAuxData[series.xSeries].currentJumpoffHeightInd;
                                this.attempt2 = this.roomAuxData[series.xSeries].attempt;
                                this.attemptNext2 = this.roomAuxData[series.xSeries].attemptNext;*/

                            } else {
                                // writing client. Set position and positionNext. If they have changed, send the changes to the server.
                                if (JSON.stringify(this.position) != JSON.stringify(position) || JSON.stringify(this.positionNext) != JSON.stringify(positionNext) || this.roomAuxData[series.xSeries].currentHeight != this.currentHeight2 || this.roomAuxData[series.xSeries].currentJumpoffHeightInd != this.currentJumpoffHeightInd2 || this.roomAuxData[series.xSeries].attempt != this.attempt2 || this.roomAuxData[series.xSeries].attemptNext != this.attemptNext2) {
                                    this.autoManageAuxData(false);
                                    this.roomAuxData[series.xSeries].positionNext = positionNext;
                                    this.roomAuxData[series.xSeries].position = position;

                                    // additionally propagate the following properties to all clients (this is especially needed when the site is reloaded after the result is entered, but before it is advanced to the next athlete. Then, the current height and attempt would reference to the next height, while the position arrays still reference the last jump on the previous height, as intended.)
                                    this.roomAuxData[series.xSeries].currentHeight = this.currentHeight2;
                                    this.roomAuxData[series.xSeries].currentJumpoffHeightInd = this.currentJumpoffHeightInd2;
                                    this.roomAuxData[series.xSeries].attempt = this.attempt2;
                                    this.roomAuxData[series.xSeries].attemptNext = this.attemptNext2;

                                    // send the changed data to the server
                                    rCTech.room.updateAuxDataInit(this.roomAuxData);
                                }
                                this.position = position;
                                this.positionNext = positionNext;
                            }

                            
                        } else if (this.mode==2){
                            // in jumpoff mode.

                            // Important: Regarding the position and positionNext arrays, the whole jumpoff is handled as "one height", i.e. the positions array is reduced when somebody did his jump. Instead, the positionNext array gets modified. (In other words: the different jumpoff heights are equivalend to the attempts in the regular competition.)

                            // a new jumpoff height is requried when there is no jumpoff height with jumpoffOrder==nextJumpoffHeightInd
                            this.jumpoffHeightRequired = false; // needed such that adding the next jumpoff height in the heights-menu works as well 
                            if (series.heights.findIndex(h=>h.jumpoffOrder==nextJumpoffHeightInd)==-1){
                                this.jumpoffHeightRequired = true;

                                // suggest the next height for the jumpoff
                                // check whether the new height already exists or let the user define the next jumpoff height!
                                let lastJumpoffIndex = 0;
                                let lastJumpoffHeight = 0;
                                for(let i=0;i<series.heights.length;i++){
                                    let el = series.heights[i];
                                    if (lastJumpoffIndex<el.jumpoffOrder){
                                        lastJumpoffHeight = el.height;
                                        lastJumpoffIndex = el.jumpoffOrder;
                                    }
                                }
                                
                                // create the new height
                                let val = 0; 
                                if (nextJumpoffHeightInd==1){
                                    // the first jumpoffHeight if the first height after the height where all jumpoff-paritcipants have succeeded

                                    // find the smallest height after the maxlastValidHeight
                                    val = 10000;
                                    series.heights.forEach((el,ind)=>{
                                        if (el.height>this.maxLastValidHeight && el.height<val){
                                            val = el.height;
                                        }
                                    })

                                } else {
                                    if (this.bestAtEachJumpoffHeight[this.bestAtEachJumpoffHeight.length-1]){
                                        // TODO: get the jumpoffHeightVariation via baseDiscipline
                                        // increase the last jumpoffHeight by this.jumpoffHeightVariation (i.e. 2cm for HJ and 5cm fo PV)
                                        val = lastJumpoffHeight + this.disciplineConfiguration.jumpoffHeightVariation;
                                    }else {
                                        // decrease the last jumpoffHeight by this.jumpoffHeightVariation (i.e. 2cm for HJ and 5cm fo PV)
                                        val = lastJumpoffHeight - this.disciplineConfiguration.jumpoffHeightVariation;
                                    }
                                }
                                // predefine the next height and let the user confirm teh height
                                this.manualJumpoffHeight = val;
                                
                            }

                            // formerly, nextJumpoffHeight was really the next jumpoffHeight. However, it is used as the currentJumpoffHeight now.
                            this.currentJumpoffHeightInd2 = nextJumpoffHeightInd;
                            // try to take over the positions from the previous height. This only works, when there are the same or fewer athletes.

                            // get all athletes that are still in the jumpoff (including those that jumped already on the current height!), i.e. all athletes where jumpoffFailedAtI>currentJumpoffHeightInd
                            
                            let recreatePos = false;
                            let starts = []; // only used in case of additional athletes, which may only happen after changes in past results
                            Object.entries(this.tempRankingData).forEach(([xSeriesStart, el])=>{

                                if (el.jumpoffFailedAtI>this.currentJumpoffHeightInd2 && el.rank==1){//(el.jumpoffResults.length==nextJumpoffHeightInd || el.jumpoffResults[nextJumpoffHeightInd]==undefined){
                                    starts.push(series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart));
                                    if(this.position.indexOf(parseInt(xSeriesStart))==-1){
                                        // if would have to add, we will recreate the positions array  afterwards
                                        recreatePos = true;
                                    }
                                }
                            })

                            // work on local copies of position and positionNext and finally detect possible changes
                            let position = this.position.slice();
                            let positionNext = this.positionNext.slice();
                            if (recreatePos){
                                // sort the starts
                                starts.sort((a,b)=>{
                                    return a.position-b.position;
                                })

                                // derive the position array
                                position = []; 
                                starts.forEach(el=>position.push(el.xSeriesStart));

                                /* positionNext = Array(position.length);
                                for (let i=0;i<positionNext.length;i++){
                                    positionNext[i] = i;
                                } */

                            } else {
                                // delete positions that do not start on this height:
                                let i = position.length;
                                while (i--){
                                    let xSeriesStart = position[i];
                                    if (this.tempRankingData[xSeriesStart].jumpoffFailedAtI<=this.currentJumpoffHeightInd2){//(this.tempRankingData[xSeriesStart].jumpoffResults.length != nextJumpoffHeightInd && this.tempRankingData[xSeriesStart].jumpoffResults[nextJumpoffHeightInd]!=undefined){
                                        position.splice(i,1);
                                    }
                                }
                            }

                            // OLD (pre 2022-03 = pre position/positionNext work as they should and non-autoAdvance works):
                            //if ((!this.readOnly) || positionNext.length==0) {
                            // NEW: 
                            if (true){
                                // define the order of athletes on the current height (positionNext)
                                // loop over the position array and check which athletes will still jump on the current height
                                positionNext = [];
                                for (let i=0; i<position.length; i++){
                                    let xSeriesStart = position[i];
                                    if(this.tempRankingData[xSeriesStart].jumpoffResults[this.currentJumpoffHeightInd2-1]==undefined){
                                        positionNext.push(i);
                                    }
                                }
                            }

                            if (this.readOnly){
                                // we actually do not use the position and positionNext data that we just have created, but we use the data that was given via the aux data. But we compare the length of the array in order to detect problems (which should never happen.)
                                if (position.length != this.roomAuxData[series.xSeries].position.length || positionNext.length != this.roomAuxData[series.xSeries].positionNext.length){
                                    console.log('Note: the number of athletes jumping on the current height was calculated differently by this browser than given by the data from the server. This may regulary hapen when the result has already arrived on reading clients, but not the new aus data. If this happens in other constellations, please report the constellation, where this happened, to the developers.')
                                }
                                this.positionNext = this.roomAuxData[series.xSeries].positionNext.slice(); // we use slice to create a copy!
                                this.position = this.roomAuxData[series.xSeries].position;

                                // should not be needed anymore
                                /*this.currentHeight2 = this.roomAuxData[series.xSeries].currentHeight;
                                this.currentJumpoffHeightInd2 = this.roomAuxData[series.xSeries].currentJumpoffHeightInd;
                                this.attempt = this.roomAuxData[series.xSeries].attempt;
                                this.attemptNext2 = this.roomAuxData[series.xSeries].attemptNext;*/

                            } else {
                                // writing client. Set position and positionNext. If they have changed, send the changes to the server.
                                if (JSON.stringify(this.position) != JSON.stringify(position) || JSON.stringify(this.positionNext) != JSON.stringify(positionNext) || this.roomAuxData[series.xSeries].currentHeight != this.currentHeight2 || this.roomAuxData[series.xSeries].currentJumpoffHeightInd != this.currentJumpoffHeightInd2 || this.roomAuxData[series.xSeries].attempt != this.attempt2 || this.roomAuxData[series.xSeries].attemptNext != this.attemptNext2) {
                                    this.autoManageAuxData(false);
                                    this.roomAuxData[series.xSeries].positionNext = positionNext;
                                    this.roomAuxData[series.xSeries].position = position;

                                    // additionally propagate the following properties to all clients (this is especially needed when the site is reloaded after the result is entered, but before it is advanced to the next athlete. Then, the current height and attempt would reference to the next height, while the position arrays still reference the last jump on the previous height, as intended.)
                                    this.roomAuxData[series.xSeries].currentHeight = this.currentHeight2;
                                    this.roomAuxData[series.xSeries].currentJumpoffHeightInd = this.currentJumpoffHeightInd2;
                                    this.roomAuxData[series.xSeries].attempt = this.attempt2;
                                    this.roomAuxData[series.xSeries].attemptNext = this.attemptNext2;

                                    // send the changed data to the server
                                    rCTech.room.updateAuxDataInit(this.roomAuxData);
                                }
                                this.position = position;
                                this.positionNext = positionNext;
                            }
                        }


                        // make sure the ordering is updated (needed at least when the ordering is set to ranking)
                        this.fakeProperty++;

                    } else {
                        // show: not all athletes have a startheight
                        this.mode = 0;
                        this.position = [];
                        this.positionNext = [];
                    }

                    // since calculateNextAthlete is called whenever something has changed, we can also start updating height-deleable.status from here 
                    this.evaluateHeightDeletable()
                },
                addResultToCurrent(res){
                    // res must be either passed, failed or cleared
                    // find the seriesStart of the current athlete and the result for the current height. If this result does not exist yet, it will automatically be generated. 
                    // if sendChangeToServer

                    let series = this.series[this.selectedSeries];

                    let start = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart==this.position[this.positionNext[0]])
                    if (!start){
                        alert('Error: Could not find athlete, which should never happen.')
                        return undefined;
                    }

                    // find the xHeight of the current height
                    let hEl = series.heights.find(h=>h.height==this.currentHeight && h.jumpoffOrder==0);
                    // find the height-result-element
                    let h = start.resultshigh.find(el=>el.xHeight==hEl.xHeight)
                    let isNew = false;
                    if (!h){
                        isNew = true;
                        h = {
                            xResult: start.xSeriesStart,  // this is actually the xSeriesStart
                            xHeight: hEl.xHeight,
                            resultsHighFailedAttempts: 0, // how many fails on this hight
                            resultsHighValid: false, 
                            resultsHighPassed:false // verzichtet (-)
                        };
                        start.resultshigh.push(h);
                    }
                    
                    // add the actual result:
                    if (res=='passed'){
                        h.resultsHighPassed = true;
                    } else if (res=='cleared'){
                        h.resultsHighValid = true;
                    } else if (res=="failed"){
                        h.resultsHighFailedAttempts += 1;
                    }

                    // send change:
                    if (isNew){
                        rCTech.room.addResultInit(h, start);
                    } else {
                        rCTech.room.updateResultInit(h, start);
                    }

                },
                failed(){
                    // current athlete failed: 
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('failed');
                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        // calculateNextAthlete will be called by series watcher
                        //this.calculateNextAthlete();
                    }else{
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();
                },
                cleared(){
                    // current athlete cleared the height
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('cleared');

                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        // calculateNextAthlete will be called by series watcher
                        //this.calculateNextAthlete();
                    } else {
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();
                },
                passed(){
                    // current athlete passes this height
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('passed');

                    // remove the athlete from the position array
                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        // calculateNextAthlete will be called by series watcher
                        //this.calculateNextAthlete();
                    }else{
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();
                },
                clearedJumpoff(){
                    let xSeriesStart = this.position[this.positionNext[0]];
                    let jumpoffOrder = this.currentJumpoffHeightInd;
                    this.setJumpoffResult(xSeriesStart, jumpoffOrder, true)
                },
                failedJumpoff(){
                    let xSeriesStart = this.position[this.positionNext[0]];
                    let jumpoffOrder = this.currentJumpoffHeightInd;
                    this.setJumpoffResult(xSeriesStart, jumpoffOrder, false)
                },
                setJumpoffResult(xSeriesStart, jumpoffOrder, cleared){
                    // define the jumpoffResult at a certain jumpoff height of the given athlete (xSeriesStart)

                    // get the athlete
                    let series = this.series[this.selectedSeries];

                    let start = series.seriesstartsresults.find((el)=>{return el.xSeriesStart == xSeriesStart;});
                    if (!start){
                        alert("ERROR: could not find the athlete. Should never happen...");
                        return;
                    }

                    // get the height element
                    let hEl = series.heights.find(h=>h.jumpoffOrder==jumpoffOrder);
                    if (!hEl){
                        alert("ERROR: could not find the height entry. Should never happen...");
                        return;
                    }

                    let resEl = start.resultshigh.find(el=>el.xHeight==hEl.xHeight);
                    if (!resEl){
                        // add the result element
                        resEl = {
                                xResult: start.xSeriesStart, // this is actually the xSeriesStart
                                xHeight: hEl.xHeight,
                                resultsHighFailedAttempts: 0, // how many fails on this hight
                                resultsHighValid: false, 
                                resultsHighPassed:false // verzichtet (-)
                            };
                        start.resultshigh.push(resEl);
                    }
                    if (cleared){
                        resEl.resultsHighValid = true;
                        resEl.resultsHighFailedAttempts = 0;
                    }else{
                        resEl.resultsHighValid = false;
                        resEl.resultsHighFailedAttempts = 1;
                    }

                    // send change:
                    rCTech.room.addResultInit(resEl, start);

                    // calculateNextAthlete will be called by series watcher
                    this.onSeriesChangeCalcNextAth = true;
                    //this.calculateNextAthlete();

                },
                //{{getHeight(res.xHeight)}}: {{resToStr(res)}}
                getHeight(xHeight, postText=' m'){
                    // get the height formatted as a string (2.10m) for the given xHeight
                    let h = this.sortedHeights.find(el=>el.xHeight==xHeight);
                    if (h){
                        let hCalc = (h.height/100).toFixed(2);
                        // add a J in front of the height when it is a jumpoff height
                        if (h.jumpoffOrder>0){
                            return '<%= __("J:") %>' + hCalc + postText;
                        } else {
                            return hCalc + postText;
                        }
                    }else {
                        return 'Error';
                    }
                },
                resultToStr(res){
                    let resStr = 'X'.repeat(res.resultsHighFailedAttempts);
                    if (res.resultsHighValid){
                        resStr += 'O';
                    }else if (res.resultsHighPassed){
                        resStr += '-'
                    }
                    return resStr;
                    },
                strToResult(resStr, showAlert=false, jumpoff=false){
                    resStr = resStr.toUpperCase();
                    failedCount = 0;
                    valid = false;
                    passed = false;
                    for (let i=0;i<resStr.length;i++){
                        let c = resStr.charAt(i);
                        if (c=='X'){
                            failedCount++
                        } else if (c=='O'){
                            valid = true;
                        } else if (c=='0'){
                            valid = true;
                        } else if (c=='-'){
                            passed = true;
                        } else {
                            if (showAlert){
                                alert(c + " " + "<%= __(' is not a valid character. It is ignored.') %>")
                            }
                        }
                    }

                    // do some checks:
                    // at max one:
                    if (!jumpoff){
                        // normal
                        if (valid + passed + (failedCount==3) > 1){
                            return false;
                        }
                        if (failedCount>3){
                            return false;
                        }
                    }else{
                        // jumpoff
                        if (valid + passed + failedCount > 1){
                            return false;
                        }
                    }

                    return {
                        resultsHighFailedAttempts: failedCount, // how many fails on this hight
                            resultsHighValid: valid, 
                            resultsHighPassed: passed
                    }

                    /*{
                        xResult:1,
                        xHeight: 1, // the link to the height!
                        //resultshighSortOrder, // not needed!, the current position (temporary different athlete order) is handled differently
                        resultsHighFailedAttempts: 1, // how many fails on this hight
                        resultsHighValid: true, 
                        resultsHighPassed:false // verzichtet (-)
                    },*/
                },
                resetPositions(){
                    // reset to positions to default order

                    // first check if the positions are really not the default ones
                    if (JSON.stringify(this.position) != JSON.stringify(this.defaultPosition)){
                        this.position = this.defaultPosition;
                        this.calculateNextAthlete();

                        // since this.position is already changed, calculateNextAthlete will not detect any change and will therefore also not realize, that it should send the new changes auxData to the server. Therefore, we do it manually here 
                        this.roomAuxDataSelected.positionNext = this.positionNext;
                        this.roomAuxDataSelected.position = this.position;

                        // send the changed data to the server
                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                    
                },
                onPositionMovingEnded(evt){
                    if (evt.oldIndex!=evt.newIndex){
                        // on position change, we have to recalculate the next athlete (and the positionNext array.)
                        // calculateNextAthlete will likely not be called, since the position change does nto change anything in the series and also teh change in the auxData is only done in calculateNextAthlete, and not before
                        this.calculateNextAthlete();
                    }

                    // since this.position is already changed, calculateNextAthlete will not detect any change and will therefore also not realize, that it should send the new changes auxData to the server. Therefore, we do it manually here 
                    this.roomAuxDataSelected.positionNext = this.positionNext;
                    this.roomAuxDataSelected.position = this.position;

                    // send the changed data to the server
                    rCTech.room.updateAuxDataInit(this.roomAuxData);

                },
                saveCurrentResChange(start){
                    /*let el = document.getElementById('resChange' + this.currentResultChange.xResult);
                    //let el = document.getElementById('resChange');
                    if (el==undefined){
                        alert('ERROR: cound not find the html-element of the result change. Should actually never happen. ');
                        return;
                    }*/

                    // if the string is empty, delete the result completely, otherwise, just alter it
                    if (this.currentResultString==''){
                        
                        rCTech.room.deleteResultInit(this.currentResultChange, start)

                        // recalculate the next athlete
                        // calculateNextAthlete will be called by series watcher
                        this.onSeriesChangeCalcNextAth = true;
                        //this.calculateNextAthlete();

                    }else if (this.currentResultString != this.currentResultStringCopy){

                        // get the height element to find out whether it is a jumpoff-height
                        let hEl = this.sortedHeights.find((el)=>{return el.xHeight==this.currentResultChange.xHeight})
                        if (!hEl){
                            alert('ERROR: could not find the height corresponding to the ')
                        }

                        let raw = this.strToResult(this.currentResultString, false, hEl.jumpoffOrder>0)

                        if (raw){
                            // transfer the changes to the actual result
                            this.currentResultChange.resultsHighPassed = raw.resultsHighPassed;
                            this.currentResultChange.resultsHighValid = raw.resultsHighValid;
                            this.currentResultChange.resultsHighFailedAttempts= raw.resultsHighFailedAttempts;

                            rCTech.room.updateResultInit(this.currentResultChange, start)

                            // recalculate the next athlete
                            // calculateNextAthlete will be called by series watcher
                            this.onSeriesChangeCalcNextAth = true;
                            //this.calculateNextAthlete();
                        }else{
                            alert("<%= __('The entered result is invalid. The previous value is restored.') %>")
                        }
                    }
                    // leave the result change mode:
                    this.currentResultChange = {};
                },
                getNewHeigthsByXSeriesStart(start){
                    // returns an array of objects with the additional heights for the given athlete (i.e. all heights except those where a result already exists)

                    // start with the allHeights array and delete all heights that already have a result
                    let hRed = this.allHeights.slice();
                    let maxHeightInResults = 0;
                    // loop over the present results
                    start.resultshigh.forEach(hEl=>{
                        // get the height for the hEl
                        let h = this.sortedHeights.find(el=>el.xHeight==hEl.xHeight) 
                        if (!h){
                            alert('ERROR: height reference is broken! Should never happen.');
                            return [];
                        }
                        // get the index of the element in the hRed array
                        let ind = hRed.indexOf(h.height);
                        if (ind>=0){
                            // remove the element
                            hRed.splice(ind,1);
                        }
                        if (maxHeightInResults < h.height){
                            maxHeightInResults = h.height;
                        }
                    })

                    // define which height should be preselected:
                    // usually: find out which height is the next height of the athlete
                    // if the athlete has no result yet: the startheight
                    // if there is no startheught yet: the first element
                    let indNextHeight = -1;

                    if (maxHeightInResults){
                        // has already a result; get the next height
                        //find the maxHeight in the allHeight
                        let i = this.allHeights.indexOf(maxHeightInResults);
                        let nextHeight = this.allHeights[i+1];
                        
                        let nextHeightIndex = hRed.indexOf(nextHeight); // the next index should be selected
                        if (nextHeightIndex>=0){
                            indNextHeight = nextHeightIndex;
                        }
                    } else if (start.startConf) {
                        let i = hRed.indexOf(start.startConf); 
                        if(i>=0){
                            indNextHeight = i;
                        }
                    }
                    // no elmeent was found:
                    if (indNextHeight<0){
                        indNextHeight = 0;
                    }

                    // now process every element in hRed and transform it into the appropriate object
                    for (let i=0; i<hRed.length; i++){
                        hRed[i] = {
                            value: hRed[i],
                            text: hRed[i],
                            next: i==indNextHeight
                        }
                    }

                    return hRed;
                },
                addResultBlur(start, $event){
                    if (this.resultKeyPressed!=27){
                        this.addResult(start);
                    }
                    this.resultKeyPressed = -1;
                },
                addResult(start){

                    // add a result 
                    let valEl = document.getElementById('newResultValue' + start.xSeriesStart);
                    let heightEl = document.getElementById('newResultHeight' + start.xSeriesStart);

                    if (valEl.value!=''){
                        // first try to parse the entered result string
                        let resParsed = this.strToResult(valEl.value);
                        if (!resParsed){
                            // TODO: what shall be reverted
                            alert("<%= __('The entered result is invalid. Saving is aborted.') %>")
                            return;
                        }

                        // check that the result is also reasonable together with the previous results:
                        // - not more than 2 failed attempts in a row
                        // - athlete was not finished before already
                        // - not nothing
                        if (this.tempRankingData[start.xSeriesStart].finished ){
                            alert("ERROR: the athlete is already finished! Actually you should not even be able to enter a result.");
                            valEl.value = '';
                            return;
                        }

                        if (this.tempRankingData.failedAttemptsSinceLastValid + resParsed.resultsHighFailedAttempts + resParsed.resultsHighPassed + resParsed.resultsHighValid>3){
                            // TODO: 
                            alert("<%= __('The entered result is invalid, as the number of failed attempts since the last valid jump is >3. Saving is aborted.') %>")
                            valEl.value = '';
                            return;
                        }
                        if (resParsed.resultsHighFailedAttempts + resParsed.resultsHighPassed + resParsed.resultsHighValid==0){
                            // TODO: 
                            alert("<%= __('The entered result is invalid, as neither passed, nor valid nor a failed attempt was entered. Saving is aborted.') %>")
                            valEl.value = '';
                            return;
                        }

                        // get the xHeight for the selected height (if it exists)
                        let hEl = this.sortedHeights.find(el=>el.height == heightEl.value && el.jumpoffOrder==0)
                        if (!hEl){
                            this.addHeight(heightEl.value)
                            hEl = this.sortedHeights.find(el=>el.height == heightEl.value && el.jumpoffOrder==0)
                        }
                        let res = {
                            xResult: start.xSeriesStart,
                            xHeight: hEl.xHeight,
                            resultsHighFailedAttempts: resParsed.resultsHighFailedAttempts, // how many fails on this hight
                            resultsHighValid: resParsed.resultsHighValid, 
                            resultsHighPassed: resParsed.resultsHighPassed // verzichtet (-) 
                        };
                        start.resultshigh.push(res)

                        // send the change to the server
                        rCTech.room.addResultInit(res, start);

                        // recalculate the next athlete. This will also update the tempRankingData, which is needed below  
                        // TODO: will calculateNextAthlete be called already when here?
                        // calculateNextAthlete will be called by series watcher
                        this.onSeriesChangeCalcNextAth = true;
                        //this.calculateNextAthlete();

                        // reset the field 
                        valEl.value = '';
                        // define the new focus:
                        if (this.tempRankingData[start.xSeriesStart].finished){
                            // focus the next athletes field, where the athletes results
                            // i= index of the current athlete
                            let i = this.sortedStarts1.findIndex(el=>start.xSeriesStart==el.xSeriesStart);
                            for (let j=i+1;j<this.sortedStarts1.length;j++){
                                // check if the athlete is not finished yet
                                if (!this.tempRankingData[this.sortedStarts1[j].xSeriesStart].finished){
                                    document.getElementById('newResultValue'+this.sortedStarts1[j].xSeriesStart).focus();
                                    break;
                                }
                            }
                        }else{
                            // focus the same element again
                            valEl.focus();
                        }
                    }



                // is the height automatically removed from the heights options dropdown? Otherwise make Vue reload in some way.

                },
                changeResult(res){
                    this.currentResultChange=res;

                    // create a copy of the current result-string. If we are not doing it this way, the value of the html-element will instantly be changed back to the original value, before blur actually hits and we can store the changed result. Additionally, it allows not to raise an update event when there was no change.
                    let resStr = this.resultToStr(res);
                    this.currentResultString = resStr;
                    this.currentResultStringCopy = resStr;

                    // set the focus: problem: when the element is still hidden, it cannot get the focus. And Vue will change the hidden status with a slight delay (either just asynchronous or indeed with a delay), thus we also have to implement some delay here:
                    setTimeout(()=>{document.getElementById('resChange' + res.xResult).focus();}, 1) // time in ms (1 ms so far seems to be enough, 3-2020)
                    //document.getElementById('resChange' + res.xResult).focus();
                    //document.getElementById('resChange').focus();
                },
                sortedResults(results){
                    // sort the results by height /to make it look nice

                    let sortingFailed = false;
                    // create an array copy, in order not to sort the original array
                    let resCopy = [...results].sort((resA,resB)=>{
                        // get the height for both results
                        let hA = this.sortedHeights.find(h=>h.xHeight==resA.xHeight);
                        let hB = this.sortedHeights.find(h=>h.xHeight==resB.xHeight);
                        if (hA==undefined || hB==undefined){
                            this.logger.log(20, `Could not sort the result-array. Returning the unsorted array.`);
                            sortingFailed = true;
                            return 0;
                        } else {
                            return hA.height-hB.height;
                        }
                    })
                    if (sortingFailed){
                        return results;
                    } else {
                        return resCopy;
                    }
                },
                seriesStatusChanged(series, evt){

                    // send the change to the server
                    rCTech.room.updateSeriesInit(series, 'status', parseInt(evt.target.value));
                
                },
                startPeriod(){
                    // current time:
                    let dHere = new Date();
                    // this difference is incorrect by the ping duration. This is considered acceptable. The timeOffset is meant to correct time differences between the server and this client and not the ping. 
                    let dServer = new Date(dHere.valueOf()+this.timeOffset);

                    // since the time we store shwll be the virtual time on the server when the period is started, we have to correct it with the offset this client has to the server:

                    this.roomAuxDataSelected.periodStartTime = dServer;
                    rCTech.room.updateAuxDataInit(this.roomAuxData);

                    // make the time being updated regularly
                    this.timeUpdateInterval = setInterval(this.updateShownTime, 100);
                },
                hidePeriod(){

                    this.stopPeriod(false);
                    
                    if (!this.readOnly){
                        this.roomAuxDataSelected.showAttemptPeriod = false;
                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                },
                stopPeriod(sendChange=true, setNull=true){
                    if (this.timeUpdateInterval){
                        clearInterval(this.timeUpdateInterval);
                        this.timeUpdateInterval = undefined;

                        // do not set to null to keep the time at 0:00
                        if (setNull){
                            this.roomAuxDataSelected.periodStartTime = null;
                        }
                        if (sendChange && !this.readOnly){
                            rCTech.room.updateAuxDataInit(this.roomAuxData);
                        }
                    }
                },
                updateShownTime(){
                    // show the time of the current competitor
                    let aux = this.roomAuxDataSelected;
                    let minutes = 0;
                    let seconds = 0;
                    let remainingTime = 0;
                    if (aux?.periodStartTime){
                        // time is running
                        // first, calculate the remaining time.
                        let dStart = new Date(aux.periodStartTime);
                        let dNow = new Date();

                        // a positive timeOffset means that the server time (what dStart is based on) is ahead of the time on this client.
                        let milliSecondsPassed = dNow.valueOf()-(dStart.valueOf()-this.timeOffset);
                        remainingTime = aux.attemptPeriod-milliSecondsPassed/1000;
                        if (remainingTime<0){
                            if (this.timeUpdateInterval){
                                // do not set periodStartTime to null, to ensure that the time is not hidden. 
                                this.stopPeriod(true, false);
                            };
                            minutes = 0;
                            seconds = 0; 
                        }else {
                            minutes = Math.floor(remainingTime/60);
                            seconds = Math.floor((remainingTime-60*minutes));
                        }
                    } else {
                        // time is stopped and eventually not existing
                        if (aux?.attemptPeriod){
                            minutes = Math.floor(aux.attemptPeriod/60);
                            seconds = Math.floor((aux.attemptPeriod-60*minutes));
                        } else {
                            minutes = 0;
                            seconds = 0;
                        }
                    }
                    this.shownTime = minutes.toString() + ":" + seconds.toString().padStart(2,0);
                    this.last15 = minutes*60+seconds<=15;

                    return remainingTime > 0;
                    
                },
                // show the correct time; additionally, we have to start the interval for updating the time, if the timer was started on the server and is not started yet here
                // 2022-06: moved here from vuContestTech; called in watchers
                timeManager(){
                    let timeRunning = this.updateShownTime();
                    if (timeRunning && this.timeUpdateInterval===undefined && this.selectedXSeries && this.roomAuxDataSelected.periodStartTime){
                        // start the timer
                        this.timeUpdateInterval = setInterval(this.updateShownTime, 100);
                    }
                },
                fitName(elementId, startgroup, pretext=""){

                    // in some cases, it seems that positionNext.length>1 is not false yet, but nextAthleteStart is already undefined; in that case just return ''
                    /*if (!startgroup){
                        return '';
                    }*/

                    // try to fit firstname and name in a html element
                    // returns the best possible name
                    let el = document.getElementById(elementId);

                    // if the mode was just changed from 0 to 1, the element might not be shown yet. In that case, simply show the last name 
                    if (!el){
                        return startgroup.athleteName;
                    }

                    // store the overflow-style, then set it to hidden
                    let overflowBefore = el.style.overflow;
                    let innerTextBefore = el.innerText;
                    if ( !overflowBefore || overflowBefore === "visible" ){
                        el.style.overflow = "hidden";
                    }

                    // first try firstname / lastname
                    el.innerText = `${pretext}${startgroup.athleteForename} ${startgroup.athleteName}`;
                    if (el.clientWidth >= el.scrollWidth){
                        el.style.overflow = overflowBefore;
                        //el.innerText = innerTextBefore;
                        return el.innerText;
                    }

                    // fn. / lastname
                    el.innerText = `${pretext}${startgroup.athleteForename[0]}. ${startgroup.athleteName}`;
                    if (el.clientWidth >= el.scrollWidth){
                        el.style.overflow = overflowBefore;
                        //el.innerText = innerTextBefore;
                        return el.innerText;
                    }

                    el.style.overflow = overflowBefore;
                    //el.innerText = innerTextBefore;

                    // if both did nto fit, return just the lastname
                    return `${pretext}${startgroup.athleteName}`
                },
                rankLocalizer(rank, lang='en'){
                    // return the rank as a localized string, e.g. 
                    // en: 1st, 2nd, 3rd, 4th, ...
                    // de: 1., 2., 3., ...
                    // rank is always based on the number or empty (if no rank)
                    if (rank==0){
                        // there is no rank 0! print no rank when 0
                        return '';
                    }
                    if (lang=='de'){
                        return `${rank}.`
                    }else {
                        // english is the default
                        if (rank==1){
                            return '1st';
                        }else if (rank==2){
                            return '2nd';
                        } else if (rank==3){
                            return '3rd';
                        } else {
                            return `${rank}th`;
                        }
                    }
                },
                // resultLOcalizer: create the result string for the given result (inlcuding the resultOverrule)
                // the result is 
                // - empty until there is a first cleared height
                // - the last valid height
                // - NM_: no valid height, and three failed attempts
                // - DISQ
                // - DNS
                resultLocalizer(ssr, lang="en"){

                    const tempRankingData = this.tempRankingData[ssr.xSeriesStart];

                    const rank = tempRankingData.rank;
                    const finished = tempRankingData.finished;
                    const resultOverrule = ssr.resultOverrule;

                    // DISQ, DNS
                    if (resultOverrule>1){
                        return this.participationStatesTech.find(el=>el.value==resultOverrule)?.abbreviation;
                    }

                    // retired
                    if (resultOverrule==1){
                        // if the athlete had a result then show the last height together with the abbreviaiton for retired
                        if (tempRankingData.lastValidHeight>0){
                            return this.meterStr(tempRankingData.lastValidHeight) + " m, " + this.participationStatesTech.find(el=>el.value==resultOverrule)?.abbreviation;
                        } else {
                            return this.participationStatesTech.find(el=>el.value==resultOverrule)?.abbreviation;
                        }
                    }

                    // regular:
                    if (tempRankingData.lastValidHeight>0){
                        return this.meterStr(tempRankingData.lastValidHeight) + ' m';
                    } else {
                        if (finished){
                            // no valid result
                            return '<%= __("NM") %>';
                        } else {
                            // no result yet
                            return '';
                        }
                    }

                },
                getLastResults(numRes=2){
                    // get the specified number of results 
                },
                saveDateUtc(series, evt){
                    series.datetime = new Date(evt.srcElement.value).toISOString();
                },
                formatInputDate(date){
                    // date can be of type date or a datestring
                    // create a string that javascript accepts for input.value (unfortunately there is no automatic translation between javascript date and the format that input accepts...!)
                    let s = "";
                    let d = new Date(date); // doesnt change anything is date is already a date
                    s += d.getFullYear();
                    s += "-" + (d.getMonth()+1).toString().padStart(2,0);
                    s += "-" + d.getDate().toString().padStart(2,0);
                    s += "T" + d.getHours().toString().padStart(2,0);
                    s += ":" + d.getMinutes().toString().padStart(2,0);
                    return s;
                },
                siteChanged(series, evt){
                    // called e.g. when the time or the site was changed
                    if (evt.target.value===null || evt.target.value=='null'){
                        rCTech.room.updateSeriesInit(series, 'xSite', null);
                    } else {
                        rCTech.room.updateSeriesInit(series, 'xSite', parseInt(evt.target.value));
                    }
                },
                dateChanged(series, evt){
                    rCTech.room.updateSeriesInit(series, 'datetime', (new Date(evt.target.value).toISOString()));
                },
            },
            watch:{
                mode: function(newMode,oldMode){ 
                    if (newMode>0 && oldMode==0){
                        this.sortValue1 = 1; // keep the default order!
                        this.sortValue2 = 2;
                    } else if(newMode==0 && oldMode>0){
                        this.sortValue1 = 1;
                        this.sortValue2 = 1;
                    }
                },
                series: {
                    handler:function(seriesNew, seriesOld){
                        // if the series-data is handed over initially, try to get the selected xSeries from the url get parameter.
                        if (seriesOld.length == 0){

                            // get the selected series from the GET parameter
                            let u = new URL(window.location.href);
                            if (u.searchParams.has('xSeries')){
                                let xSeries = Number(u.searchParams.get('xSeries'))

                                // get the index of the respective series
                                let ind = this.series.findIndex(s=>s.xSeries==xSeries);
                                if (ind>=0){
                                    this.selectedSeries = ind;
                                }
                            }


                        }

                        if (seriesNew == seriesOld){
                            // change was within the series, typically by "onChange" in the room or local changes
                            
                            // Do NOT call calculateNextAthlete when: 
                            // - the client is writing, then the necessary changes were already applied
                            // - the client is reading only and the positionsNext did not change
                            // - actually no series are available
                            let positionNextChanged = false;
                            if (this.series.length>0){
                                if (this.selectedXSeries){
                                    if (JSON.stringify(this.positionNext) != JSON.stringify(this.roomAuxData[this.selectedXSeries]?.positionNext)){
                                        positionNextChanged = true;
                                    }
                                }
                                // if another function requries to call calculateNextAthlete (which also calls calculateTempRankingData), it will set onSeriesChangeCalcNextAth=true and we force calculateNextAthlete.
                                // TODO: not sure if the autoAdvance condition is needed
                                if ( (!this.onSeriesChangeCalcNextAth) && ((!this.readOnly) && (!this.autoAdvance)) && (  positionNextChanged==false)){
                                    this.calculateTemporaryRankingData();
                                } else {
                                    this.calculateNextAthlete();
                                }

                            }

                        } else {
                            // here typically "afterFullReload" or "dataArrived" in room
                            this.calculateNextAthlete();
                        }

                        if (seriesOld.length == 0){
                            // no series before; this of course also occurs when the series are initially defined, but this should still be fine
                            // this must be done AFTER calculateNextAthlete!
                            this.showAuto();
                        }

                        this.onSeriesChangeCalcNextAth = false;

                    },
                    deep:true, // this will increase the computational load, I know... but I see no other solution
                },
                'roomAuxDataSelected.periodStartTime': function(newTime, oldTime){
                    this.timeManager();
                },
                'roomAuxDataSelected.attemptPeriod': function(newTime, oldTime){
                    this.timeManager();
                },
                'roomAuxDataSelected.showAttemptPeriod': function(newTime, oldTime){
                    this.timeManager();
                },
                'roomAuxDataSelected.positionNext': {
                    // note: since it reacts to changes to any of the properties, it will be executed as many time as there are items in positionNext. (To avoid this we had to not alter the items within positionNext, but to exchange the object. However, propertyTransfer by default changes all properties one after the other and does on purpose not exchange full arrays and objects)
                    handler: function(newPos, oldPos){
                        // must call calculateNextAthlete to make this.positionNext being the same as provided by the aux Data
                        this.calculateNextAthlete();
                    },
                    deep:true,
                },
                selectedXSeries: function(newXSeries, oldXSeries){
                    this.timeManager();
                },
                selectedSeries: {
                    handler: function(newSeries, oldSeries){
                        // when we change the selectedSeries, we must reset position and positionNext to avoid problems in calculateNextAthlete; however, since this watcher is not always called before other watchers and computed properties (even if we set immediate=true !), we need an alternative to realize that positions should be resetted: selectedSeriesLazy: if calculateNextAthlete detects that selectedSeries != selectedSeriesLazy, then it will reset position and positionNext itself
                        this.position = [];
                        this.positionNext = [];
                        this.selectedSeriesLazy = newSeries;

                        // since calculate next athlete does not itself lower the mode we reset it here and then call calculateNextAthlete:
                        this.mode = 0;
                        this.calculateNextAthlete();
                    },
                },
                contestWatching: {
                    // we cannot directly watch contest, because if the changes were within the object, the oldContestObj would reference the same as newContestObj. However, the contestWatching property is always a new copy and thus new and old should be correct
                    // (The alternative would be to have watchers for each property that might change, e.g. 'contest.status', ...)

                    // this is how we watch changes not only of the property "contest", but of all the properties within it:
                    deep:true,
                    handler: function(newContestObj, oldContestObj){
                        // harmonized over all changes on the contest properties
                        // TODO: problem: if the full contest data is changed (e.g. after the room gets the first data or after full reload), this watch event is raised as well, which is problematic...
                        // send the request to the server. On positive return, nothing will be done. If negative, all changes from that point on will have to be reverted.
                        if (this.propagateChange){
                            rCTech.room.updateContest2Init(newContestObj, oldContestObj);
                            this.propagateChange = false;
                        }
                    }
                },
            },
            computed:{

                
                /* !!! properties for SERIES CREATION and COMPETITION !!! */
                maxDateTime: function(){
                    return `${this.meeting.dateTo.slice(0,10)}T23:59`;
                },
                minDateTime: function(){
                    return `${this.meeting.dateFrom.slice(0,10)}T00:00`;
                },
                defaultSite: function(){
                    return this.sites.find(s=>{
                        if (s.type != 1) return false
                        if (s.seriesonsite){
                            if (s.seriesonsite.find(sos=>sos.xBaseDiscipline == this.contest.xBaseDiscipline)){
                                return true;
                            }
                        }
                        return false;
                    });
                },
                defaultSiteConf: function(){
                    if (this.defaultSite){
                        try{
                            const conf = JSON.parse(this.defaultSite.conf);
                            return conf;
                        }catch(ex){
                            logger.log(10, 'The site configuration object is not a valid JSON.')
                        }
                    }
                },

                // transfer some of the aux properties form the writing room, if this room is a readOnly room (position and positionNext are transferred in calculateNextAthlete)
                    // this is needed when the positionNext and position do not change (when a change arrives on reading clients), because normally those properties are transferred there
                currentHeight: function(){
                    if (this.readOnly){
                        return this.roomAuxDataSelected.currentHeight;
                    } else {
                        return this.currentHeight2; // locally calculated
                    }
                },
                currentJumpoffHeightInd: function(){
                    if (this.readOnly){
                        return this.roomAuxDataSelected.currentJumpoffHeightInd;
                    } else {
                        return this.currentJumpoffHeightInd2;// locally calculated
                    }
                },
                attempt(){
                    if (this.readOnly){
                        return this.roomAuxDataSelected.attempt;
                    } else {
                        return this.attempt2; // locally calculated
                    }
                },
                attemptNext: function(){
                    if (this.readOnly){
                        return this.roomAuxDataSelected.attemptNext;
                    } else {
                        return this.attemptNext2; // locally calculated
                    }
                },
                roomAuxDataSelected: function(){
                    return this.roomAuxData[this.selectedXSeries];
                },
                sortedHeights: function(){

                    // must also work with mode=0

                    //if (this.mode>0){
                    if (this.series[this.selectedSeries]){

                        // create a copy of the heights in the currently slected series
                        let heights = this.series[this.selectedSeries].heights.slice();

                        //sort the array
                        heights.sort((el1, el2)=>{
                            // sort: 1st: jumpoff order, 2nd, height
                            if (el1.jumpoffOrder==el2.jumpoffOrder) {
                                return el1.height-el2.height
                            } else {
                                return el1.jumpoffOrder - el2.jumpoffOrder;
                            }
                        })

                        // redefine the heightOrder
                        // is not used and not a real property of the DB 
                        /*let i=1;
                        heights.forEach(el=>{
                            // check if the height order must be changed and if yes, report to the server.

                            el.heightOrder = i;
                            i += 1;
                        })*/
                        
                        return heights;

                    }else return [];
                },

                usedHeights: function(){
                    // formerly the information about whether a height can be dleeted was stored to the height itself, which is not very smart and also used a function to be called whenever this could have changed. Instead use a computed property for that.
                    
                    if (this.mode>0){

                        let series = this.series[this.selectedSeries];

                        // store a list of all heights which are in use (xHeight is stored)
                        let usedHeights = [];

                        // the currentHeight (regular and jumpoff) shall not be deleted; why not?
                        /*if (this.currentHeight>0){
                            let hEl = series.heights.find((h)=>h.height==this.currentHeight && h.jumpoffOrder==0)
                            usedHeights.push(hEl.xHeight);
                        }
                        if (this.currentJumpoffHeight>0){
                            let hEl = series.heights.find((h)=>h.height==this.currentJumpoffHeight && h.jumpoffOrder==this.currentJumpoffHeightInd)
                            usedHeights.push(hEl.xHeight);
                        }*/

                        // loop over every result of all athletes and create a long array with heights
                        series.seriesstartsresults.forEach((start)=>{
                            start?.resultshigh?.forEach((heightEl)=>{
                                usedHeights.push(heightEl.xHeight);
                            })
                        })

                        // loop over all startheights and add these heights too
                        series.seriesstartsresults.forEach((start)=>{
                            if (start.startConf){
                                let hEl = series.heights.find((h)=>h.height==start.startConf && h.jumpoffOrder==0)
                                usedHeights.push(hEl.xHeight);
                            }
                        })

                        // filter duplicates and return:
                        return usedHeights.filter((item, index) => usedHeights.indexOf(item) === index);
                    } else return [];
                    
                },

                allHeights: function(){

                    if (this.series.length>0){
                        // combine the already done heights with the heights specified in the heightIncreases
                        let allHeights = this.sortedHeights.map((el)=>{return el.height}); // use "map" or analog here
                        // the index of the first heights must equal the index of the respective height in the series.heights array!!!

                        // add the future heights according to the current heightIncreases up to 6.5m in PV and up to 2.6m in HJ
                        /*let ind = allHeights.length;
                        let lastHeight = 0;
                        if (ind>0){
                            lastHeight = allHeights[ind-1];
                        }*/
                        
                        let maxHeight = 0;
                        this.conf.heightIncreases.forEach((el,ind)=>{
                            if (ind < this.conf.heightIncreases.length-1){
                                maxHeight = this.conf.heightIncreases[ind+1].heightIncreaseStartheight;
                            } else {
                                // get the correct value from a configuration (eventually also from baseDiscipline) 
                                maxHeight = this.disciplineConfiguration.heightMax;
                            }
                            for (let height=el.heightIncreaseStartheight;height<=maxHeight;height+=el.heightIncrease){
                                // not very efficient, but efficient enough
                                if (!allHeights.some(el=>{return el==height})){
                                    lastHeight = height;
                                    allHeights.push(height);
                                }
                            }
                        })
                        allHeights.sort((el1, el2)=>{return el1-el2})
                        // alert('heights done')

                        return allHeights
                    }
                },

                urlFieldMonitor: function(){
                    // the url of the field monitor for the selected series
                    return window.location.origin + '/' + getLanguage() + "/" + getMeetingShortname() + `/techHighBoard?xContest=${findGetParameter('xContest')}&xSeries=${this.selectedXSeries}`;
                },

                contestWatching: function(){
                    // create a copy of the contest object to make sure that newContestObj and oldContestObj in the contest(Watching)-watcher are truly the old and new object, and not the same. 
                    return JSON.parse(JSON.stringify(this.contest));
                },
                conf: function(){
                    return this.parseConf(this.contest.conf);
                },
                filters: function(){
                    // create a custom filter for everything that filters by name, first name and bib at the same time. (club would be nice, but is not possible with the builtin-filters, since the club would have to be part of the object structure, but only the xClub is, but not the clubs and its name.) 
                    
                    // split the input string by whitespace
                    let filterWords = this.filterAthletes.split(" ");

                    // every word may be part of every of the four columns
                    let filter = {};
                    let i=1;
                    for (let filterWord of filterWords){
                        filter["filter" + i] = {keys:['athleteName', 'athleteForename', 'bib', 'sex, clubName', 'country'], value:filterWord} //
                        i += 1;
                    }
                    return filter;

                },

                seriesAsStartgroups: function(){
                    // "copy" the series and its seriesstartsresults (as startgroup)
                    let seriesAsStartgroups = [];
                    for (let i=0;i<this.series.length; i++){

                        let series = this.series[i];
                        
                        // add the other data of the series, for informational purposes only! A change to those is useless.
                        // do NOT use copyObject here, since it would destroy the reactivity. Use propertyTransfer instead.
                        let seriesCopy = {};
                        propertyTransfer(this.series[i], seriesCopy); // seriesstartsresults is actually already added here, but will be deleted again:

                        // get the startgroup for every seriesstartsresult
                        let SSRs = [];
                        series.seriesstartsresults.forEach(ssr=>{
                            // create a copy of the ssr
                            let ssrCopy = copyObject(ssr);
                            // find the startgroup for the respective seriesstartsresult and add it to the list
                            let startgroup = this.startgroups.find(SG=>SG.xStartgroup == ssr.xStartgroup)
                            if (startgroup){
                                ssrCopy.startgroup = startgroup;
                                ssrCopy.ssrOriginal = ssr;
                            } else {
                                console.log('Error: could not find xStartgroup of an assigned athlete. This data inconsistency should not occure. Try to fully reload the auxilary data.')
                            }

                            // reference the original (!) 'parent'; avoids that xSeries has to be defined to be used in "changePosition"
                            ssrCopy.series = seriesCopy;
                            ssrCopy.seriesOriginal = series;

                            SSRs.push(ssrCopy)
                        })
                        
                        seriesCopy.seriesstartsresults= SSRs;
                        seriesCopy.seriesOriginal = series;
                        seriesAsStartgroups.push(seriesCopy);
                    }

                    // sort the series
                    seriesAsStartgroups.sort((a,b)=>{
                        return a.number-b.number;
                    })
                    // sort the seriesstartsresults
                    seriesAsStartgroups.forEach(series=>{
                        series.seriesstartsresults.sort((a,b)=>{
                            return a.position-b.position;
                        })
                    })

                    return seriesAsStartgroups;
                },


                /* !!! properties for SERIES CREATION only !!! */

                seriesAssignments: function(){
                    // filter all series assignments to show only track (ytype==3) assignements
                    return this.seriesAssignmentsAll.filter(sa=>sa.baseDisciplineTypes.indexOf(1)>=0);
                },

                defaultPosition: function(){
                    // returns an array with the default position array; this is needed to reset the array and to know if the order currently is changed or not
                    const ssrs = this.series[this.selectedSeries].seriesstartsresults;
                    let posCopy = this.position.slice();
                    posCopy.sort((xSSR1,xSSR2)=>{
                        const SSR1 = ssrs.find(s=>s.xSeriesStart==xSSR1);
                        const SSR2 = ssrs.find(s=>s.xSeriesStart==xSSR2);
                        return SSR1.position - SSR2.position
                    })
                    return posCopy;
                },

                // to move around the atheletes e.g. from non-assigned to series we have to work on the startgroups. Create an array with all unassigned startgroups (unassignedAthletes) and one for every series with the same info (seriesAsStartgroups). 

                unassignedAthletes: function(){
                    // create an array of all unassigned athletes, including those with present=false
                    // first copy the full list of startsingroups
                    let unassignedAthletes = this.startgroups.slice(); //map(el=>el.xStartgroup);

                    // remove all entries which are references in a series
                    for (let i=0; i<this.series.length; i++){
                        this.series[i].seriesstartsresults.forEach((el, seriesIndex)=>{
                            let ind = unassignedAthletes.findIndex(el2=> el.xStartgroup==el2.xStartgroup);
                            if (ind<0){
                                console.log('Error: could not find xStartgroup of an assigned athlete. This data inconsistency should not occure. Try to fully reload the auxilary data.')
                            } else {
                                // remove the startgroups
                                unassignedAthletes.splice(ind,1);
                            }
                        })
                    }
                    return unassignedAthletes;
                },
                
                seriesAssignmentOverlay: function(){
                    // show the configuration of the currently selected series assignment algorithm
                    return this.seriesAssignments[this.selectedSeriesAssignment].overlayName;
                },

                /* !!! properties for COMPETITION only !!! */

                selectedXSeries: function(){
                    if (this.series.length>0){
                        return this.series[this.selectedSeries].xSeries;
                    }
                    return undefined;
                },
                auxData: function(){
                    // change the xStartgroup array to an object with objects, where xStartgroup is the key
                    let auxData = {};
                    auxData.xStartgroup = {};
                    this.startgroups.forEach(el=>{
                        auxData.xStartgroup[el.xStartgroup]=el;
                    })
                    return auxData;
                },
                currentAthleteStart: function(){
                    return this.getStartByXSeriesStart(this.position[this.positionNext[0]]);
                },
                nextAthleteStart: function(){
                    if (this.positionNext.length>1){
                        return this.getStartByXSeriesStart(this.position[this.positionNext[1]]);
                    }else{
                        return undefined;
                    }
                },
                sortedStarts1: function(){
                    let i = this.fakeProperty; // just to make sure sortedStarts gets updated on rank changes
                    // TODO
                    //return this.series[this.selectedSeries].seriesstartsresults;

                    // we cannot just sort the seriesstartsresults-array as this would also change the order at several different places (especially the algorithm for 'the next athlete sequence' might not work anymore!)                            

                    // create an array with all array-indexes (0 to length-1) of the seriesstartsresults array; (the initialized elements are empty first and map only uses non-empty fields. Thus we first fill with undefined and then create in indices)
                    let order = Array(this.series[this.selectedSeries].seriesstartsresults.length).fill(undefined).map(function (x, i) { return i; })

                    let compareFn = (a,b)=>{a-b} // fallback
                    if (this.sortValue1 == 1){
                        // default sequence
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            return A.position - B.position
                        }
                    } else if (this.sortValue1 == 2){
                        // sort by rank
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let rA = this.tempRankingData[A.xSeriesStart].rank;
                            let rB = this.tempRankingData[B.xSeriesStart].rank;
                            if (rA==0 && rB==0){
                                // both have no rank (yet):
                                // the order should be: in competition without valid height < retired NM < regular NM < DNS < DQ < not started yet
                                const assignVal = function(X, rX){
                                    if (X.resultOverrule==0 && !rX.finished){
                                        // differentiate with result and without result
                                        if (rX.failedAttemptsSinceLastValid>0){
                                            // already has a result
                                            return 0
                                        } else {
                                            // no result yet; at the very end
                                            return 10
                                        }
                                    }
                                    if (X.resultOverrule==1){
                                        // retired, NM
                                        return 2;
                                    }
                                    if (X.resultOverrule==0 && rX.finished){
                                        // regular NM
                                        return 4;
                                    }
                                    if (X.resultOverrule==5){
                                        // DNS
                                        return 6;
                                    }
                                    if (X.resultOverrule==6){
                                        // DQ
                                        return 8;
                                    }
                                    // should never arrive here
                                    alert('should not be here');
                                    return 100;
                                }
                                const Aval = assignVal(A, this.tempRankingData[A.xSeriesStart]);
                                const Bval = assignVal(B, this.tempRankingData[B.xSeriesStart]);
                                 
                                return Aval - Bval;
                            } else if (rA==0){
                                // A must be lower than B
                                return 1;
                            } else if (rB==0){
                                // B must be lower than A
                                return -1;
                            } else {
                                // sort by rank
                                return rA-rB;
                            }
                        }
                    } else if (this.sortValue1 == 3){
                        // sort by name
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];

                            return (auxA.athleteName + auxA.athleteForename).localeCompare(auxB.athleteName + auxB.athleteForename);
                        }
                    } else if (this.sortValue1 == 4){
                        // sort by bib
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];
                            
                            return auxA.bib - auxB.bib;
                        }
                    }
                    order.sort(compareFn);

                    return order;

                },
                sortedStarts2: function(){
                    let i = this.fakeProperty; // just to make sure sortedStarts gets updated on rank changes

                    // we cannot just sort the seriesstartsresults-array as this would also change the order at several different places (especially the algorithm for 'the next athlete sequence' might not work anymore!)                            

                    // create an array with all array-indexes (0 to length-1) of the seriesstartsresults array; (the initialized elements are empty first and map only uses non-empty fields. Thus we first fill with undefined and then create in indices)
                    let order = Array(this.series[this.selectedSeries].seriesstartsresults.length).fill(undefined).map(function (x, i) { return i; })

                    let compareFn = (a,b)=>{a-b} // fallback
                    if (this.sortValue2 == 1){
                        // default sequence
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            return A.position - B.position
                        }
                    } else if (this.sortValue2 == 2){
                        // sort by rank
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let rA = this.tempRankingData[A.xSeriesStart].rank;
                            let rB = this.tempRankingData[B.xSeriesStart].rank;
                            if (rA==0 && rB==0){
                                // both have no rank (yet):
                                // the order should be: in competition without valid height < retired NM < regular NM < DNS < DQ < not started yet
                                const assignVal = function(X, rX){
                                    if (X.resultOverrule==0 && !rX.finished){
                                        // differentiate with result and without result
                                        if (rX.failedAttemptsSinceLastValid>0){
                                            // already has a result
                                            return 0
                                        } else {
                                            // no result yet; at the very end
                                            return 10
                                        }
                                    }
                                    if (X.resultOverrule==1){
                                        // retired, NM
                                        return 2;
                                    }
                                    if (X.resultOverrule==0 && rX.finished){
                                        // regular NM
                                        return 4;
                                    }
                                    if (X.resultOverrule==5){
                                        // DNS
                                        return 6;
                                    }
                                    if (X.resultOverrule==6){
                                        // DQ
                                        return 8;
                                    }
                                    // should never arrive here
                                    alert('should not be here');
                                    return 100;
                                }
                                const Aval = assignVal(A, this.tempRankingData[A.xSeriesStart]);
                                const Bval = assignVal(B, this.tempRankingData[B.xSeriesStart]);
                                 
                                return Aval - Bval;
                            } else if (rA==0){
                                // A must be lower than B
                                return 1;
                            } else if (rB==0){
                                // B must be lower than A
                                return -1;
                            } else {
                                // sort by rank
                                return rA-rB;
                            }
                        }
                    } else if (this.sortValue2 == 3){
                        // sort by name
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];

                            return (auxA.athleteName + auxA.athleteForename).localeCompare(auxB.athleteName + auxB.athleteForename);
                        }
                    } else if (this.sortValue2 == 4){
                        // sort by bib
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];
                            
                            return auxA.bib - auxB.bib;
                        }
                    }
                    order.sort(compareFn);

                    return order;

                },
                currentJumpoffHeight: function(){
                    // in the jumpoff, we define the current height based on the jumpoffOrder; but we also need to show the height in m
                    let hEl = this.sortedHeights.find(el=>el.jumpoffOrder==this.currentJumpoffHeightInd)
                    if (hEl){
                        return this.meterStr(hEl.height);
                    } else {
                        return 0;
                    }

                },
                resultGridTemplate: function(){

                    // make sure the resultGridTemplate is updated when the xHeight is exchanged
                    let i = this.fakeProperty;

                    let h = this.sortedHeights;
                    let s = '[rank] max-content [bib] max-content [athletes] max-content [result] max-content';
                    for (let i=0;i<h.length;i++){
                        s += ' [h' + h[i].xHeight + '] max-content'; /* the label for the line must not be a number, but a string */
                    }
                    s += ' [end]';
                    return s;
                },
                disciplineConfiguration: function(){
                    // get the first discipline with matching baseDiscipline and parse its configuration
                    let d = this.disciplines.find(d=>d.xBaseDiscipline==this.contest.xBaseDiscipline);
                    if (!d || d.baseConfiguration==''){
                        return {heightMax:800, jumpoffHeightVariation:2};
                    } else {
                        let o = JSON.parse(d.baseConfiguration);
                        o.heightMax = o.heightMax ?? 800;
                        o.jumpoffHeightVariation = o.jumpoffHeightVariation ?? 2;
                        return o;
                    }
                },
                resultOnCurrentHeight: function(){
                    // get the result of the athlete in the current attempt. This function will only return a non-null value when the currentAthlete has already jumped on the height. This only happens when autoAdvance=false and the writing client has not pressed "advance" yet (i.e. calculateNextAthlete was not yet run) 
                    // returns the result as a string (O, X, -) or False (when no result yet)

                    let x = this.fakeProperty;

                    // first get the xHeight
                    let xHeight = this.sortedHeights.find(h=>h.height == this.currentHeight)?.xHeight;
                    if (!xHeight===undefined){
                        return false;
                    }
                    // check whether there is already a result for the current athlete on the current height
                    let res = this.currentAthleteStart.resultshigh.find(r=>r.xHeight==xHeight);
                    if (res==undefined){
                        return false;
                    }
                    if (this.attempt == res.resultsHighFailedAttempts){
                        return 'X';
                    }
                    if (res.resultsHighPassed){
                        return '-';
                    }
                    if (res.resultsHighValid){
                        return 'O';
                    }
                    return false;
 
                },

            },
            beforeMount(){
                // work on data before it is showed the first time
                // moved to when the data arrives
/*                this.createAllHeights();
                this.evaluateHeightDeletable();*/
            },
            mounted:function(){
                // initialize all series assignments
                this.seriesAssignments.forEach((SA)=>{
                    SA.initFunc.bind(this)();
                })

                // regularly update the shown time
                this.timeInterval = setInterval(()=>{
                    const t = new Date();
                    this.timeHours = t.getHours().toString().padStart(2,0);
                    this.timeSeconds = t.getSeconds().toString().padStart(2,0);
                    this.timeMinutes = t.getMinutes().toString().padStart(2,0);
                    this.timeOdd = t.getMilliseconds() < 500;
                }, 100); // 10 times per second
                
            },
            components:{
                'draggable': vuedraggable,
                'v-table':VTable,
                'v-th': VTh,
                'v-tr':VTr,
            },
        }

        vueSeriesAdminTech = Vue.createApp(vueAppConfig).mount('#vueSeriesAdminTech')

        // load the room:
        let ms = getMeetingShortname();

        // get the GET-parameter xContest (null if not found)
        let xContest = findGetParameter('xContest')
        
        //xContest = 3; // TODO: delete

        if (xContest!=null && !isNaN(xContest)){
            xContest = Number(xContest)
            // start the roomClientView
            rCTech = new vuContestTechHigh(vueSeriesAdminTech, ms, xContest, writing);

            rSites = new vuSites(vueSeriesAdminTech, ms);

        } else {
            // eventually show a message that there is no  
        }

    }

</script>
<script type="module">
    // MODULE stuff for printing
    import {dContestSheet, dSeriesSheetHigh, dPersonContestSheetHigh, dPersonContestResultHigh, dHeaderFooter, printer, pPersonContestSheetHigh, pSeriesContestSheetHigh, pContestSheetHigh, pHeaderFooter, pPersonContestResultHigh, pSeriesContestResultsHigh, pContestResultsHigh} from "/static/printDocumentStructure.js";


    /**
     * Create the data structure for printing
     * @param {object} contest The contest object of the room
     * @param {array} series Array storing all series 
     * @param {array} startgroups Array with all additional information (name, firstname, event, etc) for each startgroup=seriesStartResult
     * @param {array} categories
     * @param {array} heights
     * @param {array} disciplines
     * @param {array} relatedGroups
     * @param {array} sites all sites
     * @param {integer} xSeries The series to show. Null means that all series are printed. default=null 
     * @returns dContest instance with all series/persons as childs
     */
    function createDataStructureSeries(contest, series, startgroups, categories, heights, disciplines, relatedGroups, sites, xSeries=null){

        // get the name of the discipline
        let discName = disciplines.find(d=>d.xBaseDiscipline==contest.xBaseDiscipline)?.name 

        let cContest =  new dContestSheet(contest.datetimeAppeal, contest.datetimeCall, contest.datetimeStart, contest.status, contest.conf, discName, relatedGroups, categories);

        // create each series-container and add it to the contest
        for (let s of series){
            if (xSeries==null || s.xSeries == xSeries){
                
                // get the name of the site
                let siteName = '';
                if (s.xSite !== null){
                    const site = sites.find(si=>si.xSite == s.xSite);
                    if (site){
                        siteName = site.name;
                    }
                }

                let cSeries = new dSeriesSheetHigh(s.xSeries, s.status, s.number, s.name, siteName, s.seriesstartsresults, heights, s.datetime);

                // add each person in this series. Get the necessary information from the startgroup
                for (let ssr of s.seriesstartsresults){
                    // try to find the startgroup corresponding to SSR
                    let startGroup = startgroups.find(sg=>sg.xStartgroup==ssr.xStartgroup)
                    if (startGroup){

                        // get the category name
                        let cat = categories.find(c=> c.xCategory==startGroup.xCategory);
                        let catName;
                        if (cat){
                            catName = cat.shortname;
                        }

                        let p = new dPersonContestSheetHigh(startGroup.athleteName, startGroup.athleteForename, startGroup.bib, startGroup.birthdate, startGroup.country, startGroup.regionShortname, startGroup.clubName, startGroup.eventGroupName, startGroup.xDiscipline, ssr.position, catName, heights, ssr.startConf)

                        cSeries.children.push(p);
                    } else {
                        // TODO: replace by correct logging!
                        console.log(`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`)
                        throw {code:5, message:`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`}
                    }
                }

                // sort the persons by their position
                cSeries.sortChildren('position');

                cContest.addSeries(cSeries);
            }
        }
        cContest.sortSeries('number')
        return cContest
    }

    /**
     * Create the data structure for printing
     * @param {object} contest The contest object of the room
     * @param {array} series Array storing all series 
     * @param {array} startgroups Array with all additional information (name, firstname, event, etc) for each startgroup=seriesStartResult
     * @param {array} categories
     * @param {array} heights
     * @param {array} disciplines
     * @param {array} relatedGroups
     * @param {array} sites all sites
     * @param {integer} xSeries The series to show. Null means that all series are printed. default=null 
     * @returns dContest instance with all series/persons as childs
     */
    function createDataStructureResults (contest, series, startgroups, categories, heights, disciplines, relatedGroups, sites, tempRankingData, conf, xSeries=null){

        // get the name of the discipline
        let discName = disciplines.find(d=>d.xBaseDiscipline==contest.xBaseDiscipline)?.name 

        // dContest sheet is the same (pContestSheet will be different) 
        let cContest =  new dContestSheet(contest.datetimeAppeal, contest.datetimeCall, contest.datetimeStart, contest.status, contest.conf, discName, relatedGroups, categories, {}, false);

        // create each series-container and add it to the contest
        for (let s of series){
            if (xSeries==null || s.xSeries == xSeries){
                
                // get the name of the site
                let siteName = '';
                if (s.xSite !== null){
                    const site = sites.find(si=>si.xSite == s.xSite);
                    if (site){
                        siteName = site.name;
                    }
                }

                let cSeries = new dSeriesSheetHigh(s.xSeries, s.status, s.number, s.name, siteName, s.seriesstartsresults, heights, s.datetime, series.length>1); // only show the series line when there is more than one series

                // add each person in this series. Get the necessary information from the startgroup
                for (let ssr of s.seriesstartsresults){
                    // try to find the startgroup corresponding to SSR
                    let startGroup = startgroups.find(sg=>sg.xStartgroup==ssr.xStartgroup)
                    if (startGroup){

                        // get the category name
                        let cat = categories.find(c=> c.xCategory==startGroup.xCategory);
                        let catName;
                        if (cat){
                            catName = cat.shortname;
                        }

                        // get the temporary ranking data
                        let trd = tempRankingData[ssr.xSeriesStart];

                        // create an array with all results, where each result looks like: [3.50, 'XO', 0] // 0 denotes the jumpoffOrder
                        let results = [];
                        for (let res of ssr.resultshigh){
                            // find the height
                            let h = s.heights.find(h=>h.xHeight == res.xHeight);
                            // create the string
                            let resultStr ='';
                            resultStr += 'X'.repeat(res.resultsHighFailedAttempts);
                            if (res.resultsHighValid){
                                resultStr += 'O';
                            }
                            if (res.resultsHighPassed){
                                resultStr += '-';
                            }
                            results.push({
                                height: h.height/100,
                                resultStr,
                                jumpoffOrder: h.jumpoffOrder,
                            })
                        }
                        // sort the results (should typically be sorted already; however, we never know...)
                        results.sort((a,b)=>{
                            if (a.jumpoffOrder != b.jumpoffOrder){
                                return a.jumpoffOrder - b.jumpoffOrder;
                            }
                            return a.height - b.height;
                        })

                        let p = new dPersonContestResultHigh(startGroup.athleteName, startGroup.athleteForename, startGroup.bib, startGroup.birthdate, startGroup.country, startGroup.regionShortname, startGroup.clubName, startGroup.eventGroupName, startGroup.xDiscipline, ssr.position, catName, trd.rank, trd.lastValidHeight, results, ssr.startConf, ssr.resultOverrule, ssr.resultRemark, true);

                        cSeries.children.push(p);
                    } else {
                        // TODO: replace by correct logging!
                        console.log(`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`)
                        throw {code:5, message:`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`}
                    }
                }

                // sort the persons by their rank
                cSeries.sortChildren(['resultOverruleSorting', 'rankSorting']);

                cContest.addSeries(cSeries);
            }
        }
        cContest.sortSeries('number')
        return cContest
    }

    async function printResultsTechHigh(){
        // dynamically get the print configuration for the current language
        let lang = getLanguage();
        const {confPrint} = await import(`/${lang}/confPrint`);
        const conf = confPrint;

        let cContest = createDataStructureResults(vueSeriesAdminTech.contest, vueSeriesAdminTech.series, vueSeriesAdminTech.startgroups, vueSeriesAdminTech.categories, vueSeriesAdminTech.allHeights, vueSeriesAdminTech.disciplines, vueSeriesAdminTech.relatedGroups, vueSeriesAdminTech.sites, vueSeriesAdminTech.tempRankingData, conf, null);
        let hf = new dHeaderFooter([cContest], vueSeriesAdminTech.meeting);
        
        // define the translations from dataContainers to prtContainers
        const dataToPrint = {
            dHeaderFooter: pHeaderFooter,
            dContestSheet: pContestResultsHigh, 
            dSeriesSheetHigh: pSeriesContestResultsHigh, 
            dPersonContestResultHigh: pPersonContestResultHigh
        }

        let p = await printer.create([hf], dataToPrint, conf, true)

        p.showNewTab()

        return p;

    }

    async function printSeriesTechHigh(){

        // dynamically get the print configuration for the current language
        let lang = getLanguage();
        const {confPrint} = await import(`/${lang}/confPrint`);
        const conf = confPrint;

        let cContest = createDataStructureSeries(vueSeriesAdminTech.contest, vueSeriesAdminTech.series, vueSeriesAdminTech.startgroups, vueSeriesAdminTech.categories, vueSeriesAdminTech.allHeights, vueSeriesAdminTech.disciplines, vueSeriesAdminTech.relatedGroups, vueSeriesAdminTech.sites, null);
        let hf = new dHeaderFooter([cContest], vueSeriesAdminTech.meeting);

        // define the translations from dataContainers to prtContainers
        const dataToPrint = {
            dHeaderFooter: pHeaderFooter,
            dContestSheet: pContestSheetHigh,
            dSeriesSheetHigh: pSeriesContestSheetHigh,
            dPersonContestSheetHigh: pPersonContestSheetHigh
        }

        let p = await printer.create([hf], dataToPrint, conf, true)
        //let p = new printer([hf], true)

        // add the page number in a rather strange way, by directly replacing a placeholder in the content stream as a hex word. Please note that with that approach the text will not be aligned correctly when the alignment is not left, since the original alignment done in some function was based on the placeholder and not the replaced string.
        // To increase speed, we could not try to replace a part of a string (which requires searching all strings for the given needle), but instead simply replace a shole string, which only requires the comparison of full strings and a replacement whenever needed. 

        // encode the string to be replaced 
        /*let placeholder = p.fonts.Helvetica.encodeText('{The number of pages}')

        // encode replacement string 
        let replacer = p.fonts.Helvetica.encodeText('Page X of Y')

        for (let iO of p.doc.context.indirectObjects.values()){ // indirectObjects is a MAP
            // only further consider PDF content streams and Tj operators
            if (iO.constructor.name == 'PDFContentStream'){
                for (let oP of iO.operators){
                    if (oP.name==='Tj'){
                        // this is a text operator
                        // now search for the encoded text and replace it
                        // args of Tj have always only one element
                        oP.args[0].value = oP.args[0].value.replace(placeholder.value, replacer.value);
                    }
                }
            }
        }*/
        // Tested. Works. (But this is certainly not the best approach.)

        p.showNewTab()

        return p
    }

    // make sure the pritnContest function is visible/accessible to all other rooms.
    window.printSeriesTechHigh = printSeriesTechHigh;
    window.printResultsTechHigh = printResultsTechHigh;
</script>
<!-- up to here, content of techHighBase; all subsequent stuff (i.e. how the data is shown) is defined separately. -->
<%- content %>