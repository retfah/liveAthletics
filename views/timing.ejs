
<!--
    Taken from adminServer.ejs and root.ejs, but now merged together to include the complete html-structure and without the preloading etc stuff.
    
    -->
    
    <!DOCTYPE html>
    <html>
        <head>
            <meta name="viewport" content="width=device-width,initial-scale=1"> <!-- make sure mobile browsers do nto lie about their width and then do some ugly scaling -->
            <title><%= __("Timing") %> <%= timingName %></title> 
            <link rel="shortcut icon" type="image/x-icon" href="/static/favicon_quickNdirty.ico">
            <link rel="icon" type="image/x-icon" href="/static/favicon_quickNdirty.ico">
            <link rel="stylesheet" type="text/css" href="/static/styling.css">
            <!--<link rel="icon" type="image/x-icon" href="favicon.ico">-->
            <script src="/static/roomManager.js" type="text/javascript"></script>
            <script src="/static/main.js" type="text/javascript"></script> 
            <script src="/static/wsProcessorBrowser.js" type="text/javascript"></script>
            <!--<script src="/static/vue.js" type="text/javascript"></script>-->
            <script src="/static/vue3.global.js" type="text/javascript"></script>
            <script src="/static/ajv.min.js"></script>
            
            <script src="/static/roomClient.js" type="text/javascript"></script>
            <script type="module">
                // include stuff which is in a module; add it to window, so that it can be used 
                import {formatCountryRegion, disciplineFormatters, validatePerformance} from '/static/performanceProcessing.js';
                window.formatCountryRegion = formatCountryRegion;
                window.disciplineFormatters = disciplineFormatters;
                window.validatePerformance = validatePerformance;
            
            </script>
            <script type="text/javascript">
                

            const timingName = '<%= timingName %>';
            var vueTiming;
            var rTiming;
    
            function startupTiming(){
                
                // start the ws-connection
                wsHandler = new socketProcessor2();
    
                // start the event handler --> not needed anymore
                eH = new eventHandling2();
    
                eH.eventRegister('wsConnected');
    
                // start the roomManager
                rM = new roomManager('aConnection');
    
                // start the room
                load();
            }
    
            function unloadMe(){
                // called on before unload: --> properly unconnect the room(s)
    
                // TODO
            }
            
            // do everything with Vue now in this class
            class vuTiming extends roomClientVue{
            
                constructor(vue){
                
                    // parent constructor: initializes the room
                    //(roomName, writing, storeInfos, path, className, datasetName='')
                    super('timing' + timingName, true, true, '/static/rTimingClient.js', 'rTimingClient');
                
                    // needed to call things in the vue class
                    this.vue = vue;
                }
                
                /**
                 * called when a a writing ticket is stored or deleted
                 */
                onWritingTicketChange(){
                    if (this.room.writingTicketID){
                        //this.vueServerAdmin.readOnly = false;
                    } else {
                        //this.vueServerAdmin.readOnly = true;
                    }
                }
                onChange(){

                }

                setProps(){
                    this.vue.timingOptions = this.room.data.timingOptions;
                    this.vue.siteConf = this.room.data.siteConf;
                    this.vue.capabilities = this.room.data.capabilities; // stays constant
                    this.vue.disciplines = this.room.data.disciplines; // stays constant
                    this.vue.meeting = this.room.data.meeting; // stays constant
                    this.vue.infos = this.room.data.infos;
                    this.vue.auto = this.room.data.auto
                    this.vue.timers = this.room.data.timers
                    this.vue.data = this.room.data.data; // the actual data in rTiming
                    this.vue.contests = this.room.data.contests; 

                    this.room.data.timingOptions = this.vue.timingOptions;
                    this.room.data.siteConf = this.vue.siteConf;
                    this.room.data.infos = this.vue.infos;
                    this.room.data.auto = this.vue.auto;
                    this.room.data.timers = this.vue.timers;
                    this.room.data.data = this.vue.data;
                    this.room.data.contests = this.vue.contests;
                }
                
                afterFullreload(){
                    // set the changed data-property as data of the vue-instance
                    this.setProps();
                }
                
                dataArrived(){
                    this.setProps();
                }
            }
            
            /**
             * load: is automatically called after loading the page
             */
            function load(){
                //this.vueMeetingSelection = new Vue({
                let vueTimingConfig = {
                    data(){
                        return {
                            timingOptions:{},
                            siteConf: {},
                            capabilities: {}, // stays constant
                            infos:{},
                            auto: {},
                            timers: {},
                            data: [], // the actual data of rTiming, i.e. the data as is/was written to the timing. 
                            siteData: {},
                            contests: [], // the data of rSiteTrack
                            disciplines: [], // stays constant
                            meeting: {}, // stays constant

                            overlay: null, // null, siteConf, timingOptions, conf (auto + timers), 

                            // copy for mod:
                            siteConfCopy: {}, 
                            timingOptionsCopy: {},
                            autoCopy: {},
                            timersCopy: {},

                            // info overlay
                            infoTitle: '',
                            infoContent:'',
                            infoVisible:false,

                            showReactionTimes: true,

                            // the names and id's of series and contest states:
                            // Note: the comment before the ejs-include only affects the first row of the included file; (thats why it still works)
                            // also gets seriesStates and participationStates
                            //<%- include('contestStates.ejs') %>

                            readOnly:false, // not really used yet
                            
                            transferToTiming:{
                                add: true,
                                update: true,
                                delete: true,
                                updateContest: true,
                            },
                            transferToLA: {
                                add: true,
                                update: false,
                                includeReaction: true,
                            },

                            // for testing only
                            auto2: {10:{heatAud:'', heatD:true, heatPreventOnResult:true, resultAud: ''}, 70:{heatAud:'', heatD:true, heatPreventOnResult:true, resultAud: ''}, 130:{heatAud:'au', heatD:true, heatPreventOnResult:true, resultAud: ''}, 150:{heatAud:'', heatD:true, heatPreventOnResult:true, resultAud: ''}, 180:{heatAud:'', heatD:true, heatPreventOnResult:true, resultAud: ''}, 200:{heatAud:'', heatD:true, heatPreventOnResult:true, resultAud: ''}},
                        }
                    },
                    methods:{
                        overlayInfo(title, content){
                            this.infoTitle = title;
                            this.infoContent = content;
                            this.infoVisible = true;
                        },
                        showHeatsToTiming(){
                            this.transferToTiming.add = true;
                            this.transferToTiming.update = true;
                            this.transferToTiming.delete = true;
                            this.transferToTiming.updateContest = true;
                            this.overlay = 'heatsToTiming';
                        },
                        applyHeatsToTiming(){
                            // send "note" (actually a request where we do not care about the answer) to server
                            rTiming.room.heatsToTimingInit(this.transferToTiming.add, this.transferToTiming.update, this.transferToTiming.delete, this.transferToTiming.updateContest);
                            this.overlay = null;
                        },
                        heatToTiming(xContest, xSeries){
                            rTiming.room.heatToTimingInit(xContest, xSeries);
                        },
                        showResultsToLA(){
                            this.transferToLA.add = true;
                            this.transferToLA.update = false;
                            this.transferToLA.includeReaction = true;
                            this.overlay = 'resultsToLA';
                        },
                        applyResultsToLA(){
                            // send "note" (actually a request where we do not care about the answer) to server
                            rTiming.room.resultsToLAInit(this.transferToLA.add, this.transferToLA.update, this.transferToLA.includeReaction);
                            this.overlay = null;
                        },
                        resultsToLASingle(xContest, xSeries, includeReaction){
                            rTiming.room.resultsToLASingleInit(xContest, xSeries, includeReaction);
                        },
                        formatDate(dateString, noDate=false){
                            // first, get the first and last date of the competition (consider start, call and appealtime) 
                            const firstDate = new Date(this.meeting.dateFrom); 
                            const lastDate = new Date(this.meeting.dateTo);
                            let showMonth = noDate ? false : lastDate.getMonth() != firstDate.getMonth();
                            let showDay = noDate ? false : lastDate.getDay() != firstDate.getDay();

                            // exclude month if the competition does not span 2 month
                            // exclude day if the competition is on one day only
                            if (dateString==null){
                                return "";
                            }
                            var d = new Date(dateString);
                            var str = "";
                            if (showDay){
                                str += `${d.getDate()}`.padStart(2,'0') + ".";
                            }
                            if (showMonth){
                                str += `${d.getMonth()+1}`.padStart(2, '0') + ", "; // Month is zero based
                            }
                            if (showDay && !showMonth){
                                str += ' ';
                            }
                            str += `${d.getHours()}`.padStart(2, '0');
                            str += ":" + `${d.getMinutes()}`.padStart(2,'0');
                            return str;
                        },
                        formatTime(timeValue, xBaseDiscipline){
                            let disc = this.disciplines.find(d=>d.xBaseDiscipline==xBaseDiscipline);
                            return window.disciplineFormatters[disc.type](timeValue, disc, true, true); // including milliseconds
                        },
                        formatReactionTime(time){
                            if (time==undefined){
                                return '';
                            }
                            // time is in ms
                            let timeStr = (time/1000).toLocaleString(undefined, {minimumFractionDigits:3});
                            return `${timeStr} s`;
                        },
                        getContestTitleSite(contest){
                            // contest is the contest as available in main
                            // if available, use the data in site; otherwise teh data from timing
                            
                            // title string shall be "time disciplineName contestName"
                            let time = new Date(contest.site.datetimeStart);
                            let contestName = contest.site.name;
                            let xBaseDiscipline = contest.site.xBaseDiscipline;

                            return `${this.formatDate(time)} - ${this.translateDiscipline(xBaseDiscipline).name} ${contestName}`;
                        },
                        getContestTitleTiming(contest){
                            // contest is the contest as available in main
                            // if available, use the data in site; otherwise teh data from timing
                            
                            // title string shall be "time disciplineName contestName"
                            let time = new Date(contest.timing.datetimeStart);
                            let contestName = contest.timing.name;
                            let xBaseDiscipline = contest.timing.xBaseDiscipline;

                            return `${this.formatDate(time)} - ${this.translateDiscipline(xBaseDiscipline).name} ${contestName}`;
                        },
                        getContestTitle(contest){
                            // contest is the contest as available in main
                            // if available, use the data in site; otherwise teh data from timing
                            
                            // title string shall be "time disciplineName contestName"
                            if (contest.site){
                                return this.getContestTitleSite(contest);
                            } else {
                                return this.getContestTitleTiming(contest);
                            }
                        },
                        translateDiscipline(xBaseDiscipline){

                            let lang = getLanguage(); // gets it from the URL
                            
                            // get the baseDisciplne
                            const bd = this.disciplines.find(bd=>bd.xBaseDiscipline == xBaseDiscipline);
                            let name, shortname;
                            // try to get a translation: 
                            let local = bd.basedisciplinelocalizations.find(bdl=>bdl.language==lang);
                            if (local){
                                name = local.name;
                                shortname = local.shortname;
                            }else {
                                // use the default value
                                name = bd.nameStd;
                                shortname = bd.shortnameStd;
                            };
                            return {name, shortname};
                        },
                        showSiteConf(){
                            // create a copy to be modified in order to allow easy reset
                            this.siteConfCopy = JSON.parse(JSON.stringify(this.siteConf));

                            this.overlay = "siteConf";
                        },
                        saveSiteConf(){
                            // make sure that secure is a boolean

                            rTiming.room.updateSiteConfInit(this.siteConfCopy);
                            this.overlay = null;
                        },
                        showTimingOptions(){
                            // create a copy to be modified in order to allow easy reset
                            this.timingOptionsCopy = JSON.parse(JSON.stringify(this.timingOptions));

                            this.overlay = "timingOptions";
                        },
                        saveTimingOptions(){
                            // make sure that secure is a boolean

                            rTiming.room.updateTimingOptionsInit(this.timingOptionsCopy);
                            this.overlay = null;
                        },
                        showConf(){
                            // create a copy to be modified in order to allow easy reset
                            this.timersCopy = JSON.parse(JSON.stringify(this.timers));
                            this.autoCopy = JSON.parse(JSON.stringify(this.auto));

                            this.overlay = "conf";
                        },
                        saveConf(){
                            // only apply the changes if really something has changed
                            // since we cannot have two requests at the same time, we must defer on until the answer of the other has arrived
                            if (JSON.stringify(this.auto) != JSON.stringify(this.autoCopy)){
                                let onResponse = null;
                                if (JSON.stringify(this.timers) != JSON.stringify(this.timersCopy)){
                                    onResponse = ()=>{rTiming.room.updateTimersInit(this.timersCopy)};
                                }
                                rTiming.room.updateAutoInit(this.autoCopy, onResponse);
                            }
                            else if (JSON.stringify(this.timers) != JSON.stringify(this.timersCopy)){
                                rTiming.room.updateTimersInit(this.timersCopy);
                            }
                            
                            this.overlay = null;
                        },

                        statusBackgroundColor(status, states=this.contestStates){
                            let s = states.find(s=>s.value==status);
                            if (s){
                                return s.backgroundColor;
                            }
                            return '#ffffff';
                        },
                        colorHexMultiplier(color, f){
                            // split the hex code into the three parts and multiply it with f
                            let R = Math.min(255,Math.round(f*parseInt(color.slice(1,3),16)));
                            let G = Math.min(255,Math.round(f*parseInt(color.slice(3,5),16)));
                            let B = Math.min(255,Math.round(f*parseInt(color.slice(5,7),16)));
                            return '#' + R.toString(16).padStart(2,0) + G.toString(16).padStart(2,0) + B.toString(16).padStart(2,0);
                        },
                        statusBackgroundColorHover(status, states=this.contestStates){
                            let s = states.find(s=>s.value==status);
                            if (s){
                                return this.colorHexMultiplier(s.backgroundColor)
                                // split the hex code into the three parts and multiply it with 0.8
                                /*let f = 0.8;
                                let R = Math.round(f*parseInt(s.backgroundColor.slice(1,3),16));
                                let G = Math.round(f*parseInt(s.backgroundColor.slice(3,5),16));
                                let B = Math.round(f*parseInt(s.backgroundColor.slice(5,7),16));
                                return '#' + R.toString(16).padStart(2,0) + G.toString(16).padStart(2,0) + B.toString(16).padStart(2,0);*/
                            }
                            return '#eeeeee';
                        },
                        statusTextColor(status, states=this.contestStates){
                            let s = states.find(s=>s.value==status);
                            if (s){
                                return s.textColor;
                            }
                            return '#000000';
                        },
                        statusText(status, states=this.contestStates){
                            let s = states.find(s=>s.value==status);
                            if (s){
                                return s.text;
                            }
                            return status;
                        },
                        // copied from https://github.com/ReactiveSets/toubkal/blob/master/lib/util/value_equals.js
                        /* --------------------------------------------------------------------------
                            @function value_equals( a, b, enforce_properties_order, cyclic )
                            
                            @short Returns true if a and b are deeply equal, false otherwise.
                            
                            @parameters
                            - **a** (Any type): value to compare to ```b```
                            - **b** (Any type): value compared to ```a```
                            - **enforce_properties_order** (Boolean): true to check if Object
                            properties are provided in the same order between ```a``` and
                            ```b```
                            - **cyclic** (Boolean): true to check for cycles in cyclic objects
                            
                            @description
                            Implementation:
                            ```a``` is considered equal to ```b``` if all scalar values in
                            a and b are strictly equal as compared with operator '===' except
                            for these two special cases:
                            - ```0 === -0``` but are not considered equal by value_equals().
                            - ```NaN``` is not equal to itself but is considered equal by
                            value_equals().
                            
                            ```RegExp``` objects must have the same ```lastIndex``` to be
                            considered equal. i.e. both regular expressions have matched
                            the same number of times.
                            
                            Functions must be identical, so that they have the same closure
                            context.
                            
                            ```undefined``` is a valid value, including in Objects
                            
                            This function is checked by 106 CI tests.
                            
                            Provide options for slower, less-common use cases:
                            
                            - Unless enforce_properties_order is true, if ```a``` and ```b```
                            are non-Array Objects, the order of occurence of their attributes
                            is considered irrelevant: ```{ a: 1, b: 2 }``` is considered equal
                            to ```{ b: 2, a: 1 }```.
                            
                            - Unless cyclic is true, Cyclic objects will throw a
                            ```RangeError``` exception: ```"Maximum call stack size exceeded"```
                        */
                        objectsEqual( a, b, enforce_properties_order, cyclic ) {
                            return a === b       // strick equality should be enough unless zero
                                && a !== 0         // because 0 === -0, requires test by _equals()
                                || _equals( a, b ) // handles not strictly equal or zero values
                            ;
                            
                            function _equals( a, b ) {
                                // a and b have already failed test for strict equality or are zero
                                
                                var toString = Object.prototype.toString;
                                var s, l, p, x, y;
                                
                                // They should have the same toString() signature
                                if ( ( s = toString.call( a ) ) !== toString.call( b ) ) return false;
                                
                                switch( s ) {
                                default: // Boolean, Date, String
                                    return a.valueOf() === b.valueOf();
                                
                                case '[object Number]':
                                    // Converts Number instances into primitive values
                                    // This is required also for NaN test bellow
                                    a = +a;
                                    b = +b;
                                    
                                    return a ?         // a is Non-zero and Non-NaN
                                        a === b
                                    :                // a is 0, -0 or NaN
                                        a === a ?      // a is 0 or -O
                                        1/a === 1/b    // 1/0 !== 1/-0 because Infinity !== -Infinity
                                    : b !== b        // NaN, the only Number not equal to itself!
                                    ;
                                // [object Number]
                                
                                case '[object RegExp]':
                                    return a.source   == b.source
                                    && a.global     == b.global
                                    && a.ignoreCase == b.ignoreCase
                                    && a.multiline  == b.multiline
                                    && a.lastIndex  == b.lastIndex
                                    ;
                                // [object RegExp]
                                
                                case '[object Function]':
                                    return false; // functions should be strictly equal because of closure context
                                // [object Function]
                                
                                case '[object Array]':
                                    if ( cyclic && ( x = reference_equals( a, b ) ) !== null ) return x; // intentionally duplicated bellow for [object Object]
                                    
                                    if ( ( l = a.length ) != b.length ) return false;
                                    // Both have as many elements
                                    
                                    while ( l-- ) {
                                    if ( ( x = a[ l ] ) === ( y = b[ l ] ) && x !== 0 || _equals( x, y ) ) continue;
                                    
                                    return false;
                                    }
                                    
                                    return true;
                                // [object Array]
                                
                                case '[object Object]':
                                    if ( cyclic && ( x = reference_equals( a, b ) ) !== null ) return x; // intentionally duplicated from above for [object Array]
                                    
                                    l = 0; // counter of own properties
                                    
                                    if ( enforce_properties_order ) {
                                    var properties = [];
                                    
                                    for ( p in a ) {
                                        if ( a.hasOwnProperty( p ) ) {
                                        properties.push( p );
                                        
                                        if ( ( x = a[ p ] ) === ( y = b[ p ] ) && x !== 0 || _equals( x, y ) ) continue;
                                        
                                        return false;
                                        }
                                    }
                                    
                                    // Check if 'b' has as the same properties as 'a' in the same order
                                    for ( p in b )
                                        if ( b.hasOwnProperty( p ) && properties[ l++ ] != p )
                                        return false;
                                    } else {
                                    for ( p in a ) {
                                        if ( a.hasOwnProperty( p ) ) {
                                        ++l;
                                        
                                        if ( ( x = a[ p ] ) === ( y = b[ p ] ) && x !== 0 || _equals( x, y ) ) continue;
                                        
                                        return false;
                                        }
                                    }
                                    
                                    // Check if 'b' has as not more own properties than 'a'
                                    for ( p in b )
                                        if ( b.hasOwnProperty( p ) && --l < 0 )
                                        return false;
                                    }
                                    
                                    return true;
                                // [object Object]
                                } // switch toString.call( a )
                            } // _equals()
                            
                            /* -----------------------------------------------------------------------------------------
                                reference_equals( a, b )
                                
                                Helper function to compare object references on cyclic objects or arrays.
                                
                                Returns:
                                - null if a or b is not part of a cycle, adding them to object_references array
                                - true: same cycle found for a and b
                                - false: different cycle found for a and b
                                
                                On the first call of a specific invocation of equal(), replaces self with inner function
                                holding object_references array object in closure context.
                                
                                This allows to create a context only if and when an invocation of equal() compares
                                objects or arrays.
                            */
                            function reference_equals( a, b ) {
                                var object_references = [];
                                
                                return ( reference_equals = _reference_equals )( a, b );
                                
                                function _reference_equals( a, b ) {
                                var l = object_references.length;
                                
                                while ( l-- )
                                    if ( object_references[ l-- ] === b )
                                    return object_references[ l ] === a;
                                
                                object_references.push( a, b );
                                
                                return null;
                                } // _reference_equals()
                            } // reference_equals()
                        }, // equals()
                        pushHeats(){
                            rTiming.room.pushHeatsInit();
                        },
                        pullResults(){
                            rTiming.room.pullResultsInit();
                        },
                        pullReactionTimes(){
                            rTiming.room.pullReactionInit();
                        },
                    },
                    computed:{
                        /**
                         * gets the language code (ISO 639-1) from the path
                         */
                        timingName(){
                            let p = window.location.pathname; // something like /en/timing/theName
                            let arr = p.split('/');
                            if (arr[0]=="" && arr.length>=4){
                                //generally, the first element should be empty, since the string starts with "/"
                                return arr[3]; 
                            }
                            return '';
                        },
                        autoTransferGridRows(){
                            let s = '[header1] auto [header2] auto';
                            for (let status of this.seriesStates){
                                s += ` [s${status.value}] auto`;
                            }
                            s += ' [end]';
                            return s;
                        },
                        basePath(){
                            // derive the base path from the current path
                            // origin = 'https://www.xy.com:1234', pathname = /hello/world.php, href: 'https://www.xy.com:1234/hello/world.php'

                            return window.location.origin + window.location.pathname.split('/').slice(0,2).join('/') + "/";

                        },
                        main(){
                            // create the main data object, which is an array of contests on the top level
                            // create a data structure with contest/heats/athletes, where on all the level both, the rTiming data as well as the rSiteTrack data are together
                            let cs = [];
                            // this.data is the rTiming data
                            for (let c of this.data){
                                const c2 = {
                                    xContest: c.xContest, 
                                    timing: c,
                                    site: null,
                                    heats:[],
                                };
                                cs.push(c2);
                                for (let h of c.series){
                                    let h2 = {
                                        xSeries: h.xSeries,
                                        timing: h,
                                        site: null,
                                        number: h.number,
                                    };

                                    c2.heats.push(h2);
                                }
                            }
                            // this.contests is the site data
                            for (let c of this.contests){
                                // check if the contest already exists
                                let c2 = cs.find(c3=>c3.xContest == c.xContest);
                                if (!c2){
                                    c2 = {
                                        xContest: c.xContest, 
                                        timing: null,
                                        site: c,
                                        heats:[],
                                    };
                                    cs.push(c2);
                                } else {
                                    c2.site = c;
                                }

                                for (let h of c.series){
                                    let h2 = c2.heats.find(h3=>h3.xSeries == h.xSeries);
                                    if (!h2){
                                        h2 = {
                                            xSeries: h.xSeries,
                                            number: h.number,
                                            timing: null,
                                            site: h,
                                        };
                                        c2.heats.push(h2);
                                    } else {
                                        h2.site = h;
                                    }
                                }
                            }
                            
                            // now compare all objectes and define which options (copy heats to timing, copy results to site, ...) are applicable to the contest/heat
                            /**
                             * - heatToTiming(-Update or -Create) --> single heat in contest
                             * - heatsToTiming(-Update or -Create) --> all heats of contest (currently always available!)
                             * - contestToTimingUpdate ("create" does NOT exist; this is automatically done when a/all heat/s is/are added, but the contest does not exist yet) (currently always available!)
                             * - heatsToTimingDelete (currently always available!)
                             * - resultsToSite (all of contest) (currently always available!)
                             * - resultsToSiteSingle (only for this heat)
                             * - reactionsToSite (TODO) 
                             **/
                            // IMPORTANT: these comparisons must be done in analogy to the comparison in rTiming.fullUpdate
                            for (let c of cs){
                                // currently, the buttons for "allHeatsToTiming" and "allREsultsToLiveAthletics" are alwaqys shown!
                                // only the buttons for each heat depend on the actual state
                                for (let h of c.heats){
                                    h.heatToTiming = false;
                                    h.resultsToSite = false;
                                    // if heat is not in timing or is different between timing and live athletics, provide a 
                                    // the site might not be sorted; thus sort it here
                                    if (h.site){
                                        h.site.SSRs.sort((a,b)=> a.position-b.position);
                                    }
                                    if (!h.timing){
                                        h.heatToTiming = true;
                                    } else if (!h.site || !this.objectsEqual( h.timing, h.site, false, false )){

                                        // differentiate with/out results
                                        let hasResults = false;
                                        for (let SSR of h.timing.SSRs){
                                            if (SSR.resultstrack){
                                                hasResults = true;
                                                break;
                                            }
                                        }

                                        if (hasResults){
                                            h.resultsToSite = true;
                                        } else{
                                            h.heatToTiming = true;
                                        }
                                    } 
                                }
                            }
                            

                            // finally, sort the object by starttime, heat number and position; use the data of rSIte if available
                            cs.sort((c1, c2)=>{
                                return c1.datetimeStart-c2.datetimeStart;
                            })

                            // then sort each series
                            for (let c of cs){
                                c.heats.sort((s1, s2)=>{
                                    // use the number for sorting.
                                    return s1.number-s2.number;
                                })

                                // sort the athletes in the heat
                                for (let s of c.heats){
                                    if (s.timing){
                                        s.timing.SSRs.sort((ssr1, ssr2)=>{
                                            return ssr1.position-ssr2.position;
                                        })
                                    }
                                    if (s.site){
                                        s.site.SSRs.sort((ssr1, ssr2)=>{
                                            return ssr1.position-ssr2.position;
                                        })
                                    }
                                }
                            }
                            return cs;
                        }
                    },
                    watch: {
                        auto(newAuto, oldAuto){
                            // initially check if all states exist in auto.seriesStateSetting; if not, add some default data. if existing, the default is a copy of the status with the next lower value. Otherwise, a general default is applied
                            if (Object.keys(oldAuto).length === 0){

                                let confBefore = JSON.stringify(newAuto); 

                                if (!('seriesStateSetting' in newAuto)){
                                    newAuto.seriesStateSetting = {};
                                }

                                let currentStates = Object.keys(newAuto.seriesStateSetting).sort();

                                for (let state of this.seriesStates){
                                    if (!(state.value in newAuto.seriesStateSetting)){
                                        // try to get the best matching current value
                                        let lastS = -1;
                                        for (let s of currentStates){
                                            if (s>state.value){
                                                break;
                                            }
                                            lastS = s;
                                        }
                                        if (lastS==-1){
                                            // no matching state found; apply default value
                                            newAuto.seriesStateSetting[state.value] = {heatAud:"", heatD:false, heatPreventOnResult:true, resultAud:""};
                                        } else {
                                            newAuto.seriesStateSetting[state.value] = JSON.parse(JSON.stringify(newAuto.seriesStateSetting[lastS]));
                                        }
                                    }
                                }
                                // cleanup: delete settings that are not used anymore
                                for (let stateSetting in newAuto.seriesStateSetting){
                                    // check if the state exists in the seriesStates; if not, delete the setting here
                                    if (this.seriesStates.findIndex(ss=>ss.value==stateSetting)==-1){
                                        delete newAuto[stateSetting];
                                    }
                                }
                                if (JSON.stringify(newAuto) != confBefore){
                                    rTiming.room.updateAutoInit(newAuto, null);
                                }
                            }
                        },
                    },
                };

                // start the vueInstance, which should do the rest (connect to the room, get the right data, show it)
                vueTiming = Vue.createApp(vueTimingConfig).mount('#vueDiv');
                
                rTiming = new vuTiming(vueTiming);
            }
            
            </script>
        </head>
        <body onload="startupTiming()" onbeforeunload="unloadMe()">
            <div id="vueDiv"> <!-- inside here all the vue.js stuff -->
                <h1><%= __("Timing") %> {{timingName}}</h1>
                <h3><%= __("Status") %></h3>
                <!-- provide some information about the status etc 
                 "lastHeatPushFailed": false, "siteServerConnected": true, "lastSiteServerConnectionError": "", "siteRoomConnected": true, "lastSiteRoomConnectionError": "", "timing": { "tcpConnectedMain": true, "tcpErrorLastMain": "16:18:48: Error: connect ECONNREFUSED 127.0.0.1:4446", "xmlHeatErrorLast": "", "xmlResultErrorLast": "" } }-->
                <div style="margin:3px 0;">
                    <%= __("General status information") %>:
                    <div class="statusEl" v-bind:title="`Last site server connection error: ${infos.lastSiteServerConnectionError}`" v-bind:class="{connected: infos.siteServerConnected, disconnected: !infos.siteServerConnected}">
                        <div v-if="infos.siteServerConnected">
                            <%= __("Site server connected") %>
                        </div>
                        <div v-else>
                            <%= __("Site server disconnected") %>
                        </div>
                    </div>
                    <div class="statusEl" v-bind:title="`Last site room connection error: ${infos.lastSiteRoomConnectionError}`" v-bind:class="{connected: infos.siteRoomConnected, disconnected: !infos.siteRoomConnected}">
                        <div v-if="infos.siteRoomConnected">
                            <%= __("Site room connected") %>
                        </div>
                        <div v-else>
                            <%= __("Site room disconnected") %>
                        </div>
                    </div>
                    <div class="statusEl" v-bind:class="{connected: !infos.lastHeatPushFailed, disconnected: infos.lastHeatPushFailed}">
                        <div v-if="infos.lastHeatPushFailed">
                            <%= __("Last heats push failed") %>
                        </div>
                        <div v-else>
                            <%= __("Last heats push successful") %>
                        </div>
                    </div>
                </div>
                <!--  further add all timing specific variables; TODO: include this from a timing-specific file! The following is for ALGE-->
                <div style="margin:3px 0;" v-if="infos.timing && Object.keys(infos.timing).length>0"> <!-- not before the data is initially loaded -->
                    <%= __("Timing specific status information") %>:
                    <div class="statusEl" v-if="timingOptions.hostMain != ''" v-bind:title="`Last tcp connection error: ${infos.timing.tcpErrorLastMain}`" v-bind:class="{connected: infos.timing.tcpConnectedMain, disconnected:!infos.timing.tcpConnectedMain}">
                        <div v-if="infos.timing.tcpConnectedMain">
                            <%= __("ALGE Versatile Exchange connected") %>
                        </div>
                        <div v-else>
                            <%= __("ALGE Versatile Exchange disconnected") %>
                        </div>
                    </div>
                    <div class="statusEl" v-if="timingOptions.hostStartjudge != ''" v-bind:title="`Last tcp connection error: ${infos.timing.tcpErrorLastStartjudge}`" v-bind:class="{connected: infos.timing.tcpConnectedStartjudge, disconnected:!infos.timing.tcpConnectedStartjudge}">
                        <div v-if="infos.timing.tcpConnectedStartjudge">
                            <%= __("ALGE Startjudge2 connected") %>
                        </div>
                        <div v-else>
                            <%= __("ALGE Startjudge2 disconnected") %>
                        </div>
                    </div>
                    <div class="statusEl">
                        <%= __("Last heat writing error") %>: {{infos.timing.xmlHeatErrorLast}}
                    </div>
                    <div class="statusEl">
                        <%= __("Last results reading error") %>: {{infos.timing.xmlResultErrorLast}}
                    </div>
                </div>

                <button class="btn" v-on:click="overlay='information'"><%= __("Show information") %></button>
                <button v-if="capabilities.heatsPushable" class="btn" v-on:click="pushHeats"><%= __("Send heats") %></button>
                <button v-if="capabilities.resultsPullable" class="btn" v-on:click="pullResults"><%= __("Get results") %></button>
                <button v-if="capabilities.reactionPullable" class="btn" v-on:click="pullReactionTimes"><%= __("Get reaction times") %></button>
                <div style="">
                    <h3><%= __("Contests") %></h3>
                    <!-- development note: subgrids are not yet available in Chrome based browsers, but it is in development (2023-01);-->
                    <!-- create the following container for every contest -->
                    <details v-for="(contest, iContest) in main" style="border: 1px solid black; margin: 0;" >
                        <!-- this is the container per contest -->
                        <summary v-if="contest.site" style="padding-left:3px" v-bind:style="{ 'background-color': statusBackgroundColor(contest.site.status), '--backColorHover': statusBackgroundColorHover(contest.site.status), color: statusTextColor(contest.site.status) }">
                            <!-- header to expand the details; -->
                            {{getContestTitle(contest)}} {{contest.site.xContest}} {{statusText(contest.site.status)}}<!-- TODO: remove the xContest in production -->
                        </summary>
                        <summary v-else style="margin-left:3px" >
                            <!-- header to expand the details; -->
                            {{getContestTitle(contest)}} {{contest.site.xContest}} <!-- TODO: remove the xContest in production -->
                        </summary>
                        <div style="top:0px; position: sticky; display: grid; grid-template-columns:[site] 45% [buttons] minmax(20px, 10%) [timing] 45%; margin: 2px; background-color: white;"><!-- display: grid; grid-template-columns:[site] 45% [buttons] minmax(20px, 10%) [timing] 45%; margin: 2px; -->
                            <!-- this is the sticky contest header -->
                            <div style="border:1px solid black; grid-column: site / span 1;">
                                <div v-if="contest.site" >
                                    <div style="font-weight:bold">{{getContestTitleSite(contest)}}</div>
                                    live athletics: {{contest.site.series.length}} <%= __("Heats") %>
                                </div>
                                <div v-else>
                                    <%= __("Contest does not exist in live athletics") %>
                                </div>
                            </div>
                            <div style="border:1px solid black; grid-column: buttons / span 1;">
                                <button type="button" class="btn" v-on:click="showHeatsToTiming"> <%= __("Heats to timing") %> </button>
                                <button type="button" class="btn" v-on:click="showResultsToLA"> <%= __("Results to liveAthletics") %> </button>
                            </div>
                            <div style="border:1px solid black; grid-column: timing / span 1; ">
                                <div v-if="contest.timing" >
                                    <div style="font-weight:bold">{{getContestTitleTiming(contest)}}</div>
                                    timing: {{contest.timing.series.length}} <%= __("Heats") %>
                                </div>
                                <div v-else>
                                    <%= __("Contest does not exist in timing") %>
                                </div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns:[site] 45% [buttons] minmax(20px, 10%) [timing] 45%; margin: 2px;">
                            <!-- This is the container for the heats -->
                            <template v-for="(heat, iHeat) in contest.heats">
                                <div v-if="heat.site" style="border:1px solid black; grid-column: site / span 1; " v-bind:style="{'grid-row-start': heat.number*2, }"> <!--  -->
                                    <div v-bind:style="{ 'background-color': statusBackgroundColor(heat.site.status, seriesStates), '--backColorHover': statusBackgroundColorHover(heat.site.status, seriesStates), color: statusTextColor(heat.site.status, seriesStates) }">
                                        {{formatDate(heat.site.datetime, false)}} - <%= __("Heat") %> {{heat.number}} {{heat.site.name}}
                                        {{statusText(heat.site.status, seriesStates)}} 
                                        <br>{{heat.site.id}}
                                        <!-- TODO: allow to change the status! -->
                                    </div>
                                </div>
                                <div v-if="heat.site" style="border:1px solid black; grid-column: site / span 1;" v-bind:style="{'grid-row-start': heat.number*2+1}">
                                    <!-- place the heat here -->
                                    <table>
                                        <tr>
                                            <th v-if="JSON.parse(contest.site.conf).startInLanes"><%= __("Lane") %></th>
                                            <th v-if="!JSON.parse(contest.site.conf).finishInLanes"><%= __("Position") %></th>
                                            <th><%= __("Name") %></th>
                                            <th><%= __("Firstname") %></th>
                                            <th><%= __("Club") %></th>
                                            <th><%= __("Result") %></th>
                                            <th><%= __("Rank") %></th>
                                            <th v-if="showReactionTimes"><%= __("Reaction time") %></th>

                                        </tr>
                                        <tr v-for="ssr in heat.site.SSRs">
                                            <td v-if="JSON.parse(contest.site.conf).startInLanes">{{ssr.startConf}}</td>
                                            <td v-if="!JSON.parse(contest.site.conf).finishInLanes">{{ssr.position}}</td>
                                            <td>{{ssr.athleteName}}</td>
                                            <td>{{ssr.athleteForename}}</td>
                                            <td>{{ssr.clubName}}</td>
                                            <td>{{formatTime(ssr.resultstrack?.time, contest.site.xBaseDiscipline)}}</td>
                                            <td v-if="ssr.resultOverrule==0">{{ssr.resultstrack?.rank}}</td>
                                            <td v-else>{{participationStatesTrack.find(el=>el.value==ssr.resultOverrule)?.abbreviation}}</td>
                                            <td v-if="showReactionTimes">{{formatReactionTime(ssr.resultstrack?.reactionTime)}}</td>
                                        </tr>
                                    </table>
                                </div>
                                <!--<div v-else style="border:1px solid black; grid-column: site / span 1; "></div>--> <!-- since there is no content, we do not need to show the div -->
                                <div style="border:1px solid black; grid-column: buttons / span 1; grid-row-end: span 2;" v-bind:style="{'grid-row-start': heat.number*2}">
                                    <button type="button" class="btn" v-on:click="heatToTiming(contest.xContest, heat.xSeries)" v-bind:disabled="!heat.heatToTiming"> <%= __("Heat to timing") %> </button>
                                    <button type="button" class="btn" v-on:click="resultsToLASingle(contest.xContest, heat.xSeries, false)" v-bind:disabled="!heat.resultsToSite"> <%= __("Results to liveAthletics") %> </button>
                                    <button type="button" class="btn" v-on:click="resultsToLASingle(contest.xContest, heat.xSeries, true)" v-bind:disabled="!heat.resultsToSite"> <%= __("Results and reaction times to liveAthletics") %> </button>
                                </div>
                                <div v-if="heat.timing" style="border:1px solid black; grid-column: timing / span 1; " v-bind:style="{'grid-row-start': heat.number*2, }">
                                    xSeries (timing): {{heat.timing.xSeries}}<br>
                                
                                </div>
                                <div v-if="heat.timing" style="border:1px solid black; grid-column: timing / span 1; " v-bind:style="{'grid-row-start': heat.number*2+1, }">
                                    <table>
                                        <tr>
                                            <th v-if="JSON.parse(contest.timing.conf).startInLanes"><%= __("Lane") %></th>
                                            <th v-if="!JSON.parse(contest.timing.conf).finishInLanes"><%= __("Position") %></th>
                                            <th><%= __("Name") %></th>
                                            <th><%= __("Firstname") %></th>
                                            <th><%= __("Club") %></th>
                                            <th><%= __("Result") %></th>
                                            <th><%= __("Rank") %></th>
                                            <th v-if="showReactionTimes"><%= __("Reaction time") %></th>
                                        </tr>
                                        <tr v-for="ssr in heat.timing.SSRs">
                                            <td v-if="JSON.parse(contest.timing.conf).startInLanes">{{ssr.startConf}}</td>
                                            <td v-if="!JSON.parse(contest.timing.conf).finishInLanes">{{ssr.position}}</td>
                                            <td>{{ssr.athleteName}}</td>
                                            <td>{{ssr.athleteForename}}</td>
                                            <td>{{ssr.clubName}}</td>
                                            <td>{{formatTime(ssr.resultstrack?.time, contest.site.xBaseDiscipline)}}</td>
                                            <td v-if="ssr.resultOverrule==0">{{ssr.resultstrack?.rank}}</td>
                                            <td v-else>{{participationStatesTrack.find(el=>el.value==ssr.resultOverrule)?.abbreviation}}</td>
                                            <td v-if="showReactionTimes">{{formatReactionTime(ssr.resultstrack?.reactionTime)}}</td>

                                        </tr>
                                    </table>
                                </div>
                                <div v-else style="border:1px solid black; grid-column: timing / span 1; "></div>
                            </template>
                        </div>
                    </details>


                    <!--<div style="border:1px solid black; grid-column: site / span 1; height: 20px;"></div>
                    <div style="border:1px solid black; grid-column: buttons / span 1; height: 20px;"></div>
                    <div style="border:1px solid black; grid-column: timing / span 1; height: 20px;"></div>

                    <div style="border:1px solid black; grid-column: site / span 1; height: 20px;"></div>
                    <div style="border:1px solid black; grid-column: timing / span 1; height: 20px;"></div>

                    <div style="border:1px solid black; grid-column: site / span 1; height: 20px;"></div>
                    <div style="border:1px solid black; grid-column: timing / span 1; height: 20px;"></div>-->
                </div>

                <!--<h3>All data of the room</h3>
                TimingOptions: {{timingOptions}} <br>
                SiteConf: {{siteConf}} <br>
                Capabilities: {{capabilities}} <br>
                Infos: {{infos}} <br>
                Auto: {{auto}} <br>
                Timers: {{timers}} <br>
                Data: {{data}} <br>
                Contests: {{contests}} <br>-->
                <button class="btn" @click="showSiteConf"><%= __("Site connection setup") %></button>   
                <button class="btn" @click="showTimingOptions"><%= __("Timing setup") %></button>
                <button class="btn" @click="showConf"><%= __("Automatic transfer setup") %></button>

                <div class="overlay" v-bind:class="{shown: overlay=='siteConf'}">
                    <div class="overlayContainer">
                        <h3><%= __("Site connection setup") %></h3>
                        <form class="verticalForm">
                            <label>
                                <%= __("Host") %>
                                <input class="formCtrl" type="text"  v-model="siteConfCopy.host">
                            </label>
                            <label>
                                <%= __("Port") %>
                                <input class="formCtrl" type="number"  v-model.number="siteConfCopy.port" min="1" max="65535">
                            </label>
                            <label>
                                <%= __("Secure connection") %>
                                <input type="checkbox"  v-model="siteConfCopy.secure">
                            </label>
                            <label>
                                <%= __("Path") %>
                                <input class="formCtrl" type="text"  v-model="siteConfCopy.path">
                            </label>
                            <label>
                                <%= __("Meeting shortname") %>
                                <input class="formCtrl" type="text" maxlength="10"  v-model="siteConfCopy.shortname">
                            </label>
                            <label>
                                <%= __("Site number") %>
                                <input class="formCtrl" type="number"  v-model.number="siteConfCopy.siteNumber" min="1">
                            </label>
                            <label>
                                <%= __("Token") %>
                                <input class="formCtrl" type="text" maxlength="36" v-model="siteConfCopy.token" size="36">
                            </label>
                        </form>
                        <button type="button" class="btn btnRed" v-on:click="overlay = null"><%= __("Close") %></button>
                        <button type="button" class="btn btnGreen" v-on:click="saveSiteConf"><%= __("Save") %></button>
                    </div>
                </div>
                <div class="overlay" v-bind:class="{shown: overlay=='information'}" v-on:click="overlay=null">
                    <div class="overlayContainerWide">
                        <h3><%= __("Information on data transfer") %></h3>
                        <ul>
                            <li><%= __("This tool transfers heats from liveAthletics to a timing software and the results back to liveAthletics.") %></li>
                            <li><%= __("The left side always shows the latest data for the contests/heats for the chosen site (see 'Site connection setup'), while the right side shows the data in timing software*.") %></li>
                            <li><%= __("*Dependent on the way of data transfer, there might be small inconsistencies between what is shown on the right and the actual data in the timing software; see below for more information.") %></li>
                            <li><%= __("Data is transferred from/to liveAthletics/timing (left/right) manually and/or automatically (see 'Automatic transfer setup').") %></li>
                            <!--<li><%= __("") %></li>-->
                        </ul>
                        <h4><%= __("Heats to timing") %></h4>
                        <ul>
                            <li><%= __("Whenever data gets manually/automatically transferred from liveAthletics (left side) to the timing (right side), the changed heats will instantly be sent (e.g. send a network message or write/update a file) to the timing.") %></li>
                            <li><%= __("If the transfer to the timing is by writing a file, you might have to manually read from this file in your timing software in order to get the latest changes.") %></li>
                            <li><%= __("If the transfer fails (more likely in network protocols such as udp/tcp/http than for file writing), you may manually send (or write) the heats again by clickling the button.") %></li>
                            <li><%= __('If the status of a heat is changed, the automatic transfer of heats to timing gets re-evaluated.') %></li>
                        </ul>
                        <h4><%= __("Results and reaction times to liveAthletics") %></h4>
                        <ul>                        
                            <li><%= __("If the transfer of results/reaction times can be initiated by liveAthletics (e.g. reading from files or requesting the results through tcp/http), you may set an interval (see 'Automatic timing setup') at which liveAthletics checks for new data.") %></li>
                            <li><%= __("Additionally, you may manually request resulst/reaction times by clicking the respective buttons.") %></li>
                            <li><%= __("Some timing softwares might (also) send new results/reaction times as soon as available.") %></li>
                            <li><%= __("Whenever new results/reaction times arrive, they will show up on the right side. Additionally, the data will be transferred to liveAthletics if the rules set in 'Automatic timing setup' are met.") %></li>
                            <li><%= __('If the status of a heat is changed, the automatic transfer of results to liveAthletics gets re-evaluated.') %></li>
                        </ul>
                    </div>
                </div>
                <div class="overlay" v-bind:class="{shown: overlay=='conf'}">
                    <div class="overlayContainerWide">
                        <h3><%= __("Automatic transfer") %></h3>
                        <h5>Automatically transfer the following data between liveAthletics and timing:<button type="button" class="information" v-on:click="overlayInfo('<%= __('Description of the settings') %>:', '<%= __('General notes: there are two different types of heat deletion: (1) deletion due to the current state of the heat in live athletics and (2) deletion because the heat is in fact deleted in live athletics. heats to timing: What should be done to the heats in the timing when a heat in live athletics is changed? The reaction is set on the basis of the (new) state in live athletics. add/update will transfer the data to timing. Delete (=type 1) will delete the heat in timing. (Note: this is e.g. useful when heats that are finished shall be deleted from the timing.) propagate delete: delete (=type 2) a heat in the timing when it gets deleted in live athletics? This should eventually not be active when the heat is running currently. no change with results: prevent that results from timing are transferred to live athletics whenever there is already a result in live athletics. results to site: transfer (add/update/delete) results or not from timing to live athletics when the data changes in the timing.') %>')"><%= __('i') %></button></h5>
                        <form class="verticalForm" v-if="overlay=='conf'"><!-- the if is needed to prevent errors when autoCopy is not yet ready -->
                            <!-- New method -->
                            <div style="display:grid; justify-items: stretch; grid-template-columns: [status] auto [heatAUD] auto [heatD] auto [heatPreventOnResult] auto [resultAUD] auto;" v-bind:style="{'grid-template-rows': autoTransferGridRows}">
                                <div style="grid-column: heatAUD / span 3; grid-row: header1">heats to timing</div>
                                <div style="grid-column: resultAUD; grid-row: header1">results to site</div>

                                <div style="grid-column: status; grid-row: header2;">Status</div>
                                <div style="grid-column: heatAUD; grid-row: header2;">add update status-delete</div>
                                <div style="grid-column: heatD; grid-row: header2;">propagate delete</div>
                                <div style="grid-column: heatPreventOnResult; grid-row: header2;">no change with results</div>
                                <div style="grid-column: resultAUD; grid-row: header2;">transfer results to site</div>
                                
                                <!-- add here all states with the options -->
                                <template v-for="status in seriesStates">
                                    <div style="grid-column: status;" v-bind:style="{ 'background-color': status.backgroundColor,  '--backColorHover': statusBackgroundColorHover(status.value), color: status.textColor, 'grid-row': `s${status.value}`}">
                                        {{status.text}}
                                    </div>

                                    <select v-model="autoCopy.seriesStateSetting[status.value].heatAud" class="formCtrl" style="grid-column: heatAUD;" v-bind:style="{'grid-row': `s${status.value}`}">
                                        <option value="">-</option>
                                        <option value="a">add</option>
                                        <option value="u">update</option>
                                        <option value="au">add/update</option>
                                        <option value="d">delete</option>
                                    </select>

                                    <input type="checkbox" style="grid-column: heatD" v-model="autoCopy.seriesStateSetting[status.value].heatD">

                                    <input type="checkbox" style="grid-column: heatPreventOnResult" v-model="autoCopy.seriesStateSetting[status.value].heatPreventOnResult">

                                    <select v-model="autoCopy.seriesStateSetting[status.value].resultAud" class="formCtrl" style="grid-column: resultAUD;" v-bind:style="{'grid-row': `s${status.value}`}">
                                        <option value="">-</option>
                                        <option value="a">add</option>
                                        <option value="u">update</option>
                                        <option value="au">add/update</option>
                                        <option value="audd">add/update/delete</option>
                                    </select>

                                </template> 
                            </div>

                            <!--
                            <label>
                                <%= __("Contest changed") %>
                                <select class="formCtrl" v-model.number="autoCopy.changeContestAuto" :disabled="readOnly" v-bind:style="{ 'background-color': statusBackgroundColor(autoCopy.changeContestAuto), '--backColorHover': statusBackgroundColorHover(autoCopy.changeContestAuto), color: statusTextColor(autoCopy.changeContestAuto) }">
                                    <option value="-1"><%= __("Never") %></option>
                                    <option value="-2"><%= __("Always") %></option>
                                    <template v-for="status in contestStates">
                                        <option v-bind:value="status.value" v-bind:style="{ 'background-color': status.backgroundColor,  '--backColorHover': statusBackgroundColorHover(status.value), color: status.textColor }">
                                            <%= __("Status") %> &ge; {{status.text}}
                                        </option>
                                    </template>
                                </select>
                            </label>
                            <label>
                                <%= __("Series added") %>
                                <select class="formCtrl" v-model.number="autoCopy.addSeriesAuto" :disabled="readOnly" v-bind:style="{ 'background-color': statusBackgroundColor(autoCopy.addSeriesAuto), '--backColorHover': statusBackgroundColorHover(autoCopy.addSeriesAuto), color: statusTextColor(autoCopy.addSeriesAuto) }">
                                    <option value="-1"><%= __("Never") %></option>
                                    <option value="-2"><%= __("Always") %></option>
                                    <template v-for="status in seriesStates">
                                        <option v-bind:value="status.value" v-bind:style="{ 'background-color': status.backgroundColor,  '--backColorHover': statusBackgroundColorHover(status.value), color: status.textColor }">
                                            <%= __("Status") %> &ge; {{status.text}}
                                        </option>
                                    </template>
                                </select>
                            </label>
                            <label>
                                <%= __("Series changed") %> <button type="button" class="information" v-on:click="overlayInfo('<%= __('Note') %>:', '<%= __('If the status of the heat changes, the rules set for adding/deleting the heat are applied to determine whether the heat shall be added to/deleted from the timing automatically.') %>')"><%= __('i') %></button>
                                <select class="formCtrl" v-model.number="autoCopy.changeSeriesAuto" :disabled="readOnly" v-bind:style="{ 'background-color': statusBackgroundColor(autoCopy.changeSeriesAuto), '--backColorHover': statusBackgroundColorHover(autoCopy.changeSeriesAuto), color: statusTextColor(autoCopy.changeSeriesAuto) }">
                                    <option value="-1"><%= __("Never") %></option>
                                    <option value="-2"><%= __("Always") %></option>
                                    <template v-for="status in seriesStates">
                                        <option v-bind:value="status.value" v-bind:style="{ 'background-color': status.backgroundColor,  '--backColorHover': statusBackgroundColorHover(status.value), color: status.textColor }">
                                            <%= __("Status") %> &ge; {{status.text}}
                                        </option>
                                    </template>
                                </select>
                            </label>
                            <label>
                                <%= __("Series deleted") %>
                                <select class="formCtrl" v-model.number="autoCopy.deleteSeriesAuto" :disabled="readOnly" v-bind:style="{ 'background-color': statusBackgroundColor(autoCopy.deleteSeriesAuto), '--backColorHover': statusBackgroundColorHover(autoCopy.deleteSeriesAuto), color: statusTextColor(autoCopy.deleteSeriesAuto) }">
                                    <option value="-1"><%= __("Never") %></option>
                                    <option value="-2"><%= __("Always") %></option>
                                    <template v-for="status in seriesStates">
                                        <option v-bind:value="status.value" v-bind:style="{ 'background-color': status.backgroundColor,  '--backColorHover': statusBackgroundColorHover(status.value), color: status.textColor }">
                                            <%= __("Status") %> &ge; {{status.text}}
                                        </option>
                                    </template>
                                </select>
                            </label>

                            <h5>Automatically transfer the following new data in the timing to live athletics:</h5>
                            <label>
                                <%= __("Evaluated time of a person") %>
                                <select class="formCtrl" v-model.number="autoCopy.addResultAuto" :disabled="readOnly" v-bind:style="{ 'background-color': statusBackgroundColor(autoCopy.addResultAuto), '--backColorHover': statusBackgroundColorHover(autoCopy.addResultAuto), color: statusTextColor(autoCopy.addResultAuto) }">
                                    <option value="-1"><%= __("Never") %></option>
                                    <option value="-2"><%= __("Always") %></option>
                                    <template v-for="status in seriesStates">
                                        <option v-bind:value="status.value" v-bind:style="{ 'background-color': status.backgroundColor,  '--backColorHover': statusBackgroundColorHover(status.value), color: status.textColor }">
                                            <%= __("Status") %> &le; {{status.text}}
                                        </option>
                                    </template>
                                </select>
                            </label>
                            <label>
                                <%= __("Evaluated times of a full heat") %>
                                <select class="formCtrl" v-model.number="autoCopy.addResultHeatAuto" :disabled="readOnly" v-bind:style="{ 'background-color': statusBackgroundColor(autoCopy.addResultHeatAuto), '--backColorHover': statusBackgroundColorHover(autoCopy.addResultHeatAuto), color: statusTextColor(autoCopy.addResultHeatAuto) }">
                                    <option value="-1"><%= __("Never") %></option>
                                    <option value="-2"><%= __("Always") %></option>
                                    <template v-for="status in seriesStates">
                                        <option v-bind:value="status.value" v-bind:style="{ 'background-color': status.backgroundColor,  '--backColorHover': statusBackgroundColorHover(status.value), color: status.textColor }">
                                            <%= __("Status") %> &le; {{status.text}}
                                        </option>
                                    </template>
                                </select>
                            </label>
                            <label>
                                <%= __("Reaction times") %>
                                <select class="formCtrl" v-model.number="autoCopy.addReactionTimeAuto" :disabled="readOnly" v-bind:style="{ 'background-color': statusBackgroundColor(autoCopy.addReactionTimeAuto), '--backColorHover': statusBackgroundColorHover(autoCopy.addReactionTimeAuto), color: statusTextColor(autoCopy.addReactionTimeAuto) }">
                                    <option value="-1"><%= __("Never") %></option>
                                    <option value="-2"><%= __("Always") %></option>
                                    <template v-for="status in seriesStates">
                                        <option v-bind:value="status.value" v-bind:style="{ 'background-color': status.backgroundColor,  '--backColorHover': statusBackgroundColorHover(status.value), color: status.textColor }">
                                            <%= __("Status") %> &le; {{status.text}}
                                        </option>
                                    </template>
                                </select>
                            </label>
                        -->

                            <h5>Check for results/reaction times in the timing software in the following interval (in seconds; 0=never):</h5>
                            <!-- data that must/can be pulled from the timing software -->
                            <label>
                                <%= __("Results") %>
                                <input class="formCtrl" type="number"  v-model.number="timersCopy.pullResults" min="0">
                            </label>
                            <label>
                                <%= __("Reaction times") %>
                                <input class="formCtrl" type="number"  v-model.number="timersCopy.pullReactionTimes" min="0">
                            </label>
                        </form>
                        <button type="button" class="btn btnRed" v-on:click="overlay = null"><%= __("Close") %></button>
                        <button type="button" class="btn btnGreen" v-on:click="saveConf"><%= __("Save") %></button>
                    </div>
                </div>
                <div class="overlay" v-bind:class="{shown: overlay=='heatsToTiming'}">
                    <div class="overlayContainer">
                        <h3><%= __("Transfer heats to timing") %></h3>
                        <form class="verticalForm">
                            <label>
                                <input type="checkbox"  v-model="transferToTiming.add">
                                <%= __("Add new heats") %>
                            </label>
                            <label>
                                <input type="checkbox"  v-model="transferToTiming.update">
                                <%= __("Update changed heats") %>
                            </label>
                            <label>
                                <input type="checkbox"  v-model="transferToTiming.delete">
                                <%= __("Delete removed heats") %>
                            </label>
                            <label>
                                <input type="checkbox"  v-model="transferToTiming.updateContest">
                                <%= __("Update contest information") %>
                            </label>
                            <button type="button" class="btn btnRed" v-on:click="overlay = null"><%= __("Close") %></button>
                            <button type="button" class="btn btnGreen" v-on:click="applyHeatsToTiming"><%= __("Apply") %></button>
                        </form>
                    </div>
                </div>
                <div class="overlay" v-bind:class="{shown: overlay=='resultsToLA'}">
                    <div class="overlayContainer">
                        <h3><%= __("Transfer results to live athletics") %></h3>
                        <form class="verticalForm">
                            <label>
                                <input type="checkbox"  v-model="transferToLA.add">
                                <%= __("Add new results") %>
                            </label>
                            <label>
                                <input type="checkbox"  v-model="transferToLA.update">
                                <%= __("Update results") %>
                            </label>
                            <label>
                                <input type="checkbox"  v-model="transferToLA.includeReaction">
                                <%= __("include reaction times (if available)") %>
                            </label>
                            <button type="button" class="btn btnRed" v-on:click="overlay = null"><%= __("Close") %></button>
                            <button type="button" class="btn btnGreen" v-on:click="applyResultsToLA"><%= __("Apply") %></button>
                        </form>
                    </div>
                </div>

                <div class="overlay" v-bind:class="{shown: overlay=='timingOptions'}">
                    <div class="overlayContainer">
                        <h3><%= __("Timing setup") %></h3>
                        <!-- TODO: this should be inserted on the basis of the respective timing software! The following is for ALGE -->
                        <form class="verticalForm">
                            <label>
                                <%= __("Folder where the heats shall be exported to") %><button type="button" class="information" v-on:click="overlayInfo('<%= __('Notes') %>:', '<%= __('The path must be accessible from the server that provides this page.') %>')"><%= __('i') %></button>
                                <input class="formCtrl" type="text" v-model="timingOptionsCopy.xmlHeatsFolder"> <!-- NOTE: "type=file directory" is not what we need (it uploads simply all files in a folder, but does not provide the folder name); what we need does not exist for security reasons -->
                            </label>
                            <label>
                                <%= __("Folder where the results shall be imported from") %> <button type="button" class="information" v-on:click="overlayInfo('<%= __('Notes') %>:', '<%= __('The path must be accessible from the server that provides this page.') %>')"> <%= __('i') %></button>
                                <input class="formCtrl" type="text" v-model="timingOptionsCopy.xmlResultsFolder"> <!-- NOTE: "type=file directory" is not what we need (it uploads simply all files in a folder, but does not provide the folder name); what we need does not exist for security reasons -->
                            </label>
                            <!-- all tcp server settings -->
                            <fieldset>
                                <legend>
                                    ALGE Versatile Exchange protocol
                                    <button type="button" class="information" v-on:click="overlayInfo('ALGE Versatile exchange protocol', '<%= __(`The ALGE Versatile exchange protocol provides a push message for the following events: start (including false start), finish (with inofficial finish time), single results during evaluation, heat results when official. Go to "ATL exchange settings/AlgeVersatileExchangeProtocolOutput/Ports/[0]" and set "Layer=Tcp Server" and "Tcp Server/Local Port" to e.g. 4446. Provide the same port number  together withh the host (IP or server name) in the settings here.`) %>');"><%= __('i') %></button>
                                </legend>
                                <h4><%= __("Settings are only required when any of the checkboxes is selected") %></h4>
                                <label>
                                    <%= __("Host") %>
                                    <input class="formCtrl" type="text"  v-model="timingOptionsCopy.hostMain">
                                </label>
                                <label>
                                    <%= __("Port") %>
                                    <input class="formCtrl" type="number"  v-model.number="timingOptionsCopy.portMain" min="1" max="65535">
                                </label>
                                <label>
                                    <%= __("Relay start and finish signal from ALGE to live athletics") %>
                                    <input type="checkbox"  v-model="timingOptionsCopy.handlePushHeatStartFinish">
                                </label>
                                <label>
                                    <%= __("Get inofficial results during evaluation") %> DOES NOT WORK YET
                                    <input type="checkbox"  v-model="timingOptionsCopy.handlePushCompetitorEvaluated">
                                </label>
                                <!--<div v-if="timingOptionsCopy.handlePushCompetitorEvaluated==true" style="padding-left: 15px;">
                                    <label >
                                        <%= __("Also get the inofficial rank") %><button type="button" class="information" v-on:click="overlayInfo('<%= __(`Inofficial rank`) %>', '<%= __(`Only set this to true when the timing crew always evaluates the times in the order of the placing, and e.g. not in the order of the lanes. Otherwise, the temporary ranks are wrong.`) %>');"><%= __('i') %></button>
                                        <input type="checkbox"  v-model="timingOptionsCopy.competitorEvaluatedWithRank">
                                    </label>
                                </div>   -->                             
                                <label>
                                    <%= __("Instantly import results when official") %>
                                    <input type="checkbox"  v-model="timingOptionsCopy.handlePushHeatResult">
                                </label>
                            </fieldset>
                            <fieldset>
                                <legend><%= __("StartJudge2") %><button type="button" class="information" v-on:click="overlayInfo('ALGE StartJudge2 Link', '<%= __(`The StartJudge2 provides the reactiontimes at every start through. If teh reaction times shall be grabbed, provide here the host and port of the StartJudge2.`) %>');"><%= __('i') %></button></legend>
                                <label>
                                    <%= __("Host") %>
                                    <input class="formCtrl" type="text"  v-model="timingOptionsCopy.hostStartjudge">
                                </label>
                                <label>
                                    <%= __("Port") %>
                                    <input class="formCtrl" type="number"  v-model.number="timingOptionsCopy.portStartjudge" min="1" max="65535">
                                </label>
                            </fieldset>

                        </form>
                        <button type="button" class="btn btnRed" v-on:click="overlay = null"><%= __("Close") %></button>
                        <button type="button" class="btn btnGreen" v-on:click="saveTimingOptions"><%= __("Save") %></button>
                    </div>
                </div>
                <div id="overlay" v-on:click="infoVisible=false" v-bind:class="{shown: infoVisible}">
                    <!-- overlay used for displaying general information -->
                    <div id="overlayContainer">
                        <div id="overlayTitle"><b>{{infoTitle}}</b></div>
                        <div id="overlayContent">{{infoContent}}</div>
                    </div>
                </div>
            </div>
            <a id="aConnection" class="Conn" onclick="rM.data.wsWindowShown=true;"><%= __("Connection") %></a>
            <!-- include the roomManager-frontend -->
            <%- include('roomManagerDrawings') %>
    
        </body>
    </html>
    
    