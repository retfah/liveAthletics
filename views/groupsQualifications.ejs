
<script type="module">
    import {rankTechLong} from "/static/rankTechLong.js";
    import {rankTechHigh} from "/static/rankTechHigh.js";
    import {rankTrack} from "/static/rankTrack.js";
    import {formatCountryRegion, disciplineFormatters, validatePerformance} from '/static/performanceProcessing.js';

    window.rankTechLong = rankTechLong;
    window.rankTechHigh = rankTechHigh;
    window.rankTrack = rankTrack;
    window.formatCountryRegion = formatCountryRegion;
    window.disciplineFormatters = disciplineFormatters;
    window.validatePerformance = validatePerformance;
</script>
<script type="text/javascript">



    // connect to the respective contest; 
    // in contrast to the original vuContestXY in in the respective file, this class here assigns the data from the room to different properties in the vue instance. Additionally, we do not request writing rights
    class vuContestTechHigh2 extends roomClientVue{
        constructor(vue, meetingShortname, xContest){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super(`contests/${xContest}@${meetingShortname}`, false, true, '/static/rContestTechHighClient.js', 'rContestTechHighClient', '')

            // needed to call things in the vue class
            this.vue = vue;
            this.xContest = xContest;
        }

        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            this.vue.readOnly = this.room.writingTicketID==false;
        }

        onChange(){

            // some computed properties such as resultGridTemplate are not updated when its content changes (e.g. xHeight changed from negative values to the true value); thus we need this stupid fake property
            // is this still required?
            this.vue.fakeProperty++;

        }

        setProps(){

            // make sure that the series are sorted
            this.room.sortSeries();

            // set the changed data-property as data of the vue-instance
            this.vue.contests[this.xContest] = {
                series: this.room.data.series,
                auxData: this.room.data.auxData,
                contest: this.room.data.contest,
                room: this.room, 
            }
            
            this.room.data.series = this.vue.contests[this.xContest].series;
            this.room.data.auxData = this.vue.contests[this.xContest].auxData
            this.room.data.contest = this.vue.contests[this.xContest].contest
        }
        
        afterFullreload(){

            // first, calculate the time offset of the browser's time and the time on the server
            // the offset is defiend as serverTime - timeHere; i.e. the value is positive, when the time here is lower than on the server.
            this.vue.timeOffset = new Date(this.room.data.serverTime) - new Date();

            // 
            this.setProps()

            // also update the writing status
            this.onWritingTicketChange();

        }
        
        dataArrived(){

            this.setProps();
            
            // also update the writing status
            this.onWritingTicketChange();

        }

    }

    class vuContestTrack2 extends roomClientVue{
        constructor(vue, meetingShortname, xContest, writing=false){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super(`contests/${xContest}@${meetingShortname}`, writing, true, '/static/rContestTrackClient.js', 'rContestTrackClient', '')

            // needed to call things in the vue class
            this.vue = vue;
            this.xContest = xContest;
        }

        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            this.vue.readOnly = this.room.writingTicketID==false;
        }

        onChange(){

            // some computed properties such as resultGridTemplate are not updated when its content changes (e.g. xHeight changed from negative values to the true value); thus we need this stupid fake property
            // is this still required?
            this.vue.fakeProperty++;

        }

        setProps(){

            // make sure that the series are sorted
            this.room.sortSeries();

            // set the changed data-property as data of the vue-instance
            this.vue.contests[this.xContest] = {
                series: this.room.data.series,
                auxData: this.room.data.auxData,
                contest: this.room.data.contest,
                //room: this.room
            }

            this.room.data.series = this.vue.contests[this.xContest].series;
            this.room.data.auxData = this.vue.contests[this.xContest].auxData
            this.room.data.contest = this.vue.contests[this.xContest].contest

        }
        
        afterFullreload(){

            // first, calculate the time offset of the browser's time and the time on the server
            // the offset is defiend as serverTime - timeHere; i.e. the value is positive, when the time here is lower than on the server.
            this.vue.timeOffset = new Date(this.room.data.serverTime) - new Date();

            // 
            this.setProps()

            // also update the writing status
            this.onWritingTicketChange();

        }
        
        dataArrived(){

            // 2022-12: same as afterFullReload
            this.afterFullreload()

            // OLD: 
            // this.setProps();
            
            // // also update the writing status
            // this.onWritingTicketChange();

        }

    }

    class vuClubs extends roomClientVue{
        
        constructor(vue, meetingShortname){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super('clubs@' + meetingShortname, false, true, '/static/rClubsClient.js', 'rClubsClient', '')

            // needed to call things in the vue class
            this.vue = vue;
        }

        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }

        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            this.vue.clubs = this.room.data.clubs; // this will actually store a proxy of the data!

            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            this.room.data.clubs = this.vue.clubs;
        }
        
        dataArrived(){
            // raised as soon as the room has its data stored for the first time
            this.vue.clubs = this.room.data.clubs;
        
            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            //this.room.data.clubs = this.vue.clubs;

        }
    }
    
    // for a singeEventGroup (to set qualification and groups of athletes)
    class vuEventGroup extends roomClientVue{
        
        constructor(vue, meetingShortname, xEventGroup){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super(`eventGroups/${xEventGroup}@${meetingShortname}`, true, true, '/static/rEventGroupClient.js', 'rEventGroupClient', '')
    
            // needed to call things in the vue class
            this.vue = vue;
        }
    
        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }
    
        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            this.vue.eventGroup = this.room.data; // this will actually store a proxy of the data!
    
            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            this.room.data = this.vue.eventGroup;

            // sort the rounds and within each round by 
            this.room.data.rounds.sort((a,b)=>a.order-b.order);

            for (let r of this.room.data.rounds){
                r.groups.sort((a,b)=>a.number-b.number)
            }
        }
        
        dataArrived(){
            // the same as after full reload
            this.afterFullreload()
        }
    }

    class vuStartsInGroups extends roomClientVue{
        
        constructor(vue, meetingShortname){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super(`startsInGroup@${meetingShortname}`, true, true, '/static/rStartsInGroupClient.js', 'rStartsInGroupsClient', '')
    
            // needed to call things in the vue class
            this.vue = vue;
        }
    
        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }
    
        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            this.vue.startsInGroups = this.room.data.startsInGroups; // this will actually store a proxy of the data!
    
            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            this.room.data.startsInGroups = this.vue.startsInGroups;

        }
        
        dataArrived(){
            // the same as after full reload
            this.afterFullreload()
        }
    }

    class vuStarts extends roomClientVue{
        
        constructor(vue, meetingShortname){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super('starts@' + meetingShortname, false, true, '/static/rStartsClient.js', 'rStartsClient', '')

            // needed to call things in the vue class
            this.vue = vue;
        }

        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }

        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            this.vue.startsAll = this.room.data.starts; // this will actually store a proxy of the data!
            this.vue.disciplines = this.room.data.disciplines;

            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            this.room.data.starts = this.vue.startsAll;
        }
        
        dataArrived(){
            // raised as soon as the room has its data stored for the first time
            this.vue.startsAll = this.room.data.starts;
            this.vue.disciplines = this.room.data.disciplines;
        
            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            this.room.data.starts = this.vue.startsAll;

        }
    }

    class vuInscriptions extends roomClientVue{
        
        constructor(vue, meetingShortname){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super('inscriptions@' + meetingShortname, false, true, '/static/rInscriptionsClient.js', 'rInscriptionsClient', '')

            // needed to call things in the vue class
            this.vue = vue;
        }

        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }

        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            this.vue.inscriptions = this.room.data.inscriptions; // this will actually store a proxy of the data!

            //this.vue.regions = this.room.data.regions;
            this.vue.meeting = this.room.data.meeting;
            //this.vue.regions = this.room.data.regions;
            this.vue.categories = this.room.data.categories;

            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            this.room.data.inscriptions = this.vue.inscriptions;
        }
        
        dataArrived(){
            // raised as soon as the room has its data stored for the first time
            
            this.vue.inscriptions = this.room.data.inscriptions;
            
            //this.vue.regions = this.room.data.regions;
            this.vue.meeting = this.room.data.meeting;
            //this.vue.regions = this.room.data.regions;
            this.vue.categories = this.room.data.categories;
        
            // backtransfer the "proxied" data from the vue, so that changing data in the room runs through the proxy
            this.room.data.inscriptions = this.vue.inscriptions;

        }
    }
    
    var vueGQ={};
    var rEG = undefined;
    var rStarts = undefined;
    var rInscriptions = undefined;
    var rStartsInGroups = undefined;
    var rClubs = undefined; 

    function startupGQ(){
    
        let vueAppConfig = {
            data(){
                return {
                    contests: {}, // here, the single contests store their data, referenced with xContest, e.g. {123:{contestData}, 456:{contestData}}
                    contestVUs: {}, // store the VU of each contest
                    contestsRequested: [], // the contests that should soon have the data registered in contests.
                    clubs: [],
                    eventGroup: {}, // the eventGroup data
                    disciplines: [],
                    startsAll: [],
                    inscriptions: [],
                    startsInGroups: [],
                    categories: [],
                    meeting: [],
                    showFullDetails: false,
                    //assignmentForRound: 0, // 0 if there is nothing to change currently and the round number for the round to do the change
                    showEvent: true, // whether to show the event (and category) of each entry

                    infoTitle:'',
                    infoContent:'',
                    infoVisible:false,
                    overlay: undefined,
                    qualificationConfiguration: {}, // one entry per module, referenced with the module nameDB
                    selectedQualificationModel:'', // the nameDB of the selected module; the first shall be selected as default; 
                    qualificationModules: [
                    //includes<% qualificationModules.forEach((QM)=>{ %>
                        // next include:<%- include(QM, {type:"js"}) %>,
                    //<% }); %>
                    ],
                    roundMod: undefined,
                    qualiMod: undefined,
                    qualiModXContest: undefined,
                    newQState: undefined,

                    filters: {}, // TODO: needed?

                    tabSelection:{}, // shall store 'overview' or 'result' for each xRound; will be automatically generated by a watcher 

                    // add contest and seriesStates; they are translated
                    // <%- include('contestStates.ejs') %>
                    
                }

            },
            methods:{

                autoHighlightTab(round, event){
                    // if any contest is not past series assignment, we show the overview
                    this.tabSelection[round.xRound] = 'results';
                    if (event.target.open){
                        for (let g of round.groups){
                            // try to find the contest; show the overview if a contest is not found
                            let c = this.contests[g.xContest];
                            if (!c){
                                this.tabSelection[round.xRound] = 'overview';
                                return;
                            }
                            // based on the status of the contest, set 
                            if (c.contest.status<90){
                                this.tabSelection[round.xRound] = 'overview';
                                return;
                            }
                        }
                    }
                },

                updateContests(){

                    // as long as disciplines is not available, we cannot know the type and therefore cannot call the contests
                    if(!this.discipline){
                        return;
                    }

                    // new 2024-10: load all contests instantly; (before only the contests of the "current" round were loaded.)

                    var oldContestsRequested = this.contestsRequested;
                    
                    // get all contests that are required from now on; use map and filter then all undefined values
                    var requiredNew = [];

                    for (let r of this.eventGroup.rounds){
                        for (let g of r.groups){
                            if (g.xContest !== null){
                                requiredNew.push(g.xContest);
                            }
                        }
                    }

                    // compare the old and new list of requested contests
                    // request the contests that were previously not needed and delete the contests that are not needed anymore
                    for (let xcNew of requiredNew){
                        // if the contest is not loaded yet, load it
                        if (oldContestsRequested.indexOf(xcNew)==-1){
                            // get the vue
                            if (this.discipline.type==1){
                                this.contestVUs[xcNew] = new vuContestTechHigh2(this, ms, xcNew);
                            } else if (this.discipline.type==2){
                                // TODO
                            } else if (this.discipline.type==3){
                                this.contestVUs[xcNew] = new vuContestTrack2(this, ms, xcNew);
                            }
                            
                        }
                    }
                    for (let xcOld of oldContestsRequested){
                        if (requiredNew.indexOf(xcOld)==-1){
                            // return the vue, since it is not used anymore
                            // TODO
                        }
                    }

                    this.contestsRequested = requiredNew;

                },

                groupChanged(start, event, round){
                    // start is what roundData.starts provides

                    if (start.xStartgroup == undefined){
                        // this should actually never be needed, since start.xStartgroup should never be undefined. However, it is here to allow users to handle such a bug.
                        // add start
                        let data = {
                            xRound: round.xRound, 
                            number: parseInt(event.target.value),
                            xStart: start.xStart,
                        };
                        rStartsInGroups.room.addStartsInGroupInit(data);
                    } else {
                        // change the existing startsInGroup (which should always be the case)
                        let data = {
                            xStartgroup: start.xStartgroup, 
                            number: parseInt(event.target.value), // note that this number is changed in the data due to the vue binding, but actually we then have an inconsistent group-object, which will be the old name together with the new group number
                        }
                        rStartsInGroups.room.updateStartsInGroupInit(data);
                    }

                    // reset the value back, so that it is clear to the user that the change is not yet processed on the server!
                    event.target.value = start.groupNumber;
                },

                // TODO: replace with funciton in the formatter-include
                formatTime(time, dateIfNeeded=true, secondsIfNeeded=true){
                    // return a formatted time value.
                    // if dateFrom=dateTo, only return the time; otherwise include the portion of date needed.
                    // if seconds are given, include them
                    let s = '';
                    let d = new Date(time);
                    if (dateIfNeeded && this.meeting.dateFrom != this.meeting.dateTo){
                        s += (d.getMonth()+1).toString().padStart(2,0);
                        s += "." + d.getDate().toString().padStart(2,0) + ' ';
                    }
                    s += `${d.getHours()}`.padStart(2, '0');
                    s += ":" + `${d.getMinutes()}`.padStart(2,'0');
                    if (secondsIfNeeded && d.getSeconds() != 0){
                        s += ':' + `${d.getSeconds()}`.padStart(2,'0');
                    }

                    return s;

                },

                setQualificationSetup(r){
                    this.roundMod = r; // this is the round as provided by the computed object; the actual round is r.round 

                    if (r.round.qualiModule === null || r.round.qualiModule==''){
                        this.selectedQualificationModel = this.qualificationModulesFiltered[0].nameDB;
                    } else {
                        this.selectedQualificationModel = r.round.qualiModule;
                    }

                    // reset the properties for all models
                    for (let qm of this.qualificationModules){
                        this.qualificationConfiguration[qm.nameDB] = qm.defaultValues();
                        qm.updateFunc.bind(this)(this.discipline);
                    }

                    // for the selected model, try to get the data from the configuration
                    const qualiConf = r.round.qualiConf ? JSON.parse(r.round.qualiConf) : {};
                    // set the properties
                    // always loop over the properties in the default object, to make sure that eventual changes in the props get reset
                    for (let key of Object.keys(this.qualificationConfiguration[this.selectedQualificationModel])){
                        if (qualiConf[key]!==undefined && qualiConf[key] !== null){
                            this.qualificationConfiguration[this.selectedQualificationModel][key] = qualiConf[key];
                        }
                    }
                    // udpate special props for the selected qualificaiton module again.
                    const qm = this.qualificationModules.find(qm=>qm.nameDB==this.selectedQualificationModel);
                    qm.updateFunc.bind(this)(this.discipline);

                    this.overlay = "qualificationSetup";
                },

                modQualification(resObj, xContest){
                    this.qualiMod = resObj;
                    this.qualiModXContest = xContest;
                    this.newQState = resObj.qualification;
                    this.overlay = 'modQualification';
                },
                saveQualificationMod(){
                    if (this.newQState != this.qualiMod.qualification){
                        let data = {
                            xContest: this.qualiModXContest,
                            xSeries: this.qualiMod.xSeries,
                            xSeriesStart: this.qualiMod.xSeriesStart,
                            qualification: this.newQState, 
                        };
                        
                        rEG.room.updateQualificationInit(data);
                    }
                    this.overlay=undefined;
                },

                overlayInfo(title, content){
                    this.infoTitle = title;
                    this.infoContent = content;
                    this.infoVisible = true;
                },
                
                /**
                 * returns the index and the object itself of the first object where the property prop is equal to value 
                 * @param {array of objects} arr 
                 * @param {string} prop 
                 * @param {*} val 
                 * @return {array} [index, the object]
                 */
                findObjInArrayByProp(arr, prop, val){
                    for (let i=0; i<arr.length;i++){
                        if (arr[i][prop] == val){
                            return [i, arr[i]];
                        }
                    }
                    return [-1, {}];
                },
                /**
                 * The same as findObjInArrayByProp, but only the object is returned
                 **/
                findObjInArrayByProp2(arr, prop, val){
                    return this.findObjInArrayByProp(arr, prop, val)[1];
                },

                /**
                 * Transfer the values of the properties in objFrom to the properties in objTo. Recursive. 
                 * If updateOnly=false (default), then properties that do exist only in objTo will be deleted. 
                 * @param {object or array} objFrom 
                 * @param {object or array} objTo 
                 * @param {boolean} updateOnly If true, properties in objTo are not deleted when they do not exist in objFrom. Default: false 
                 */
                propertyTransfer(objFrom, objTo, updateOnly=false){

                    if (Array.isArray(objFrom)){

                        if (!Array.isArray(objTo)){
                            console.log('objTo was not of type array, but objFrom was. The property transfer would fail and thus is aborted.')
                            return
                        }

                        // use pop and push to alter the length of the array. Note that we do not detect moved elements. We rather delete or add elements at the end and just transfer the values at each position. (Push is actually not needed, since assigning to elements outside the range is possible.)
                        while (objTo.length>objFrom.length){
                            objTo.pop();
                        }
                        /*
                        let l = objTo.length; 
                        for (let i=0;i<l-objFrom.length;i++){
                            // delete the last elements
                            objTo.pop();
                        }*/

                        // copy the elements
                        for (let i=0;i<objFrom.length;i++){
                            // pay attention to objects and arrays --> recursive calls needed
                            if (typeof(objFrom[i])=='object'){
                                // since typeof(null)=object, we have to handle this separately here
                                if (objTo[i]===null){
                                    objTo[i] = objFrom[i];
                                } else if (typeof(objTo[i])!='object'){
                                    // if this is not done here and if objTo[i] is just a property, the recursive call on propertyTransfer will not occur byReference, as it must be to work.
                                    if (Array.isArray(objFrom[i])){
                                        objTo[i] = [];
                                    } else {
                                        objTo[i] = {};
                                    }
                                } else {
                                    // typeof(null)=object; therefore
                                    // is it of the same type? otherwise reset the element in objTo
                                    if (Array.isArray(objTo[i]) && !Array.isArray(objFrom[i])){
                                        objTo[i] = {};
                                    } else if (!Array.isArray(objTo[i]) && Array.isArray(objFrom[i])){
                                        objTo[i] = [];
                                    }
                                }
                                this.propertyTransfer(objFrom[i], objTo[i], updateOnly);
                            } else {
                                objTo[i] = objFrom[i];
                            }
                        }
                        
                    } else {

                        if (Array.isArray(objTo)){
                            console.log('objTo was of type array, but should be a normal object as objFrom. The property transfer would fail and thus is aborted.')
                            return
                        }

                        // is a regular object
                        // copy new to objTo
                        for (let prop in objFrom){
                            if (typeof(objFrom[prop])=='object' && objFrom[prop] != null){ // null interestingly is an object...

                                if (!(prop in objTo)){
                                    if (Array.isArray(objFrom[prop])){
                                        objTo[prop] = [];
                                    } else {
                                        objTo[prop] = {};
                                    }
                                } else {
                                    // is it of the same type? otherwise reset the property in objTo
                                    if ((typeof(objTo[prop])!='object' || Array.isArray(objTo[prop])) && !Array.isArray(objFrom[prop])){
                                        objTo[prop] = {};
                                    } else if ((typeof(objTo[prop])!='object' || !Array.isArray(objTo[prop])) && Array.isArray(objFrom[prop])){
                                        objTo[prop] = [];
                                    }
                                }
                                // transfer the property
                                this.propertyTransfer(objFrom[prop], objTo[prop], updateOnly);
                            } else {
                                // just copy from/to
                                // the problem is that if properties are added in the property transfer, using the simple assignement does not raise any observer set by Vue. Thus vue will not be updated! 
                                objTo[prop] = objFrom[prop];

                                // TEST: if the property is not available in objTo, do not assign it to a property, but use a method that is observed
                                //objTo = Object.assign(objTo, {[prop]:objFrom[prop]}) // does not work

                            }
                        }
                        // delete all properties in objTo, which are not present in objFrom
                        if (!updateOnly){
                            for (let prop in objTo){
                                if (!(prop in objFrom)){
                                    delete objTo[prop];
                                }
                            }
                        }
                    }
                },
                
                // create all data to be shown in the list for group assignment and qualifications
                // this data includes start, inscription, startgroup (if available); 
                createAssignmentData: function(start, SIG, ssr, group){

                    // what to get from where: 
                    // inscriptions: name, firstname, bib, birthdate, sex, xClub, xRegion
                    // start: bestPerf, bestPerfLast
                    // startgroup: group assignment
                    // (last) contest: the performance in the last contest
                    // round: the round of the last performance

                    let data = {
                        group:{},
                        club:{},
                    };

                    const inscription = this.inscriptions.find(i=>i.xInscription==start.xInscription);
                    const club = this.clubs.find(c=>c.xClub == inscription?.athlete.xClub);


                    this.propertyTransfer(start, data, true);
                    this.propertyTransfer(SIG, data, true);
                    this.propertyTransfer(group, data.group, true);
                    this.propertyTransfer(inscription, data, true);
                    this.propertyTransfer(club, data.club, true);
                    this.propertyTransfer(ssr, data, true);

                    // create a combination of category and event info
                    let info = ' ' + this.eventGroup.events.find(e=>e.xEvent==data.xEvent)?.info;
                    info = info.length>1 ? info : ''; 
                    data.eventStr = this.categories.find(c=>c.xCategory==data.xCategory)?.name + info;


                    return data;
                },
                // add formatting of performances
                //<%- include('formatters.js') %>
                
                /**
                 * 
                 * format the given integer-value for the presentation to the user
                 * @param {integer} value The integer value to format
                 * @param {boolean} showUnit
                 * @param {boolean} showMillis
                 **/
                formatValue(value, showUnit=true, showMillis=true){
                    return window.disciplineFormatters[this.discipline.type](value, this.discipline, showUnit, showMillis); 
                },

                applyQualification(){
                    // save the potentially changed qulification setting and (re)apply the set qualification mode. The actual work will be done in the qualification module. Here, only apply the changes to the SSR in the rContest
                    const apply = ()=>{
                        this.qualificationModules.find(QM=>QM.nameDB==this.selectedQualificationModel).apply.bind(this)();
                    }

                    // this overrides the default exe fucntion in the roomClient. Thus, we need to first apply the actual changes and then actually apply the qualification.
                    const funcOverride = (data, defaultFunc)=>{
                        defaultFunc(data);
                        apply();
                    };

                    if (this.qualificationChanged()){

                        this.saveQualification(funcOverride);

                    } else {
                        // apply the qualification directly
                        apply();
                    }
                    this.overlay = undefined;

                },
                compareObjects(o1, o2){
                    // simple, shallow comparison of objects

                    const entries1 = Object.entries(o1);
                    const keys2 = Object.keys(o2);
                    if (entries1.length !== keys2.length) {
                        return false;
                    }
                    for (let i = 0; i < entries1.length; ++i) {

                        // check for key. (Note: not checking this might lead to wrong results when o1.propName=undefined and o2.propName does not exist.)
                        if (keys2.indexOf(entries1[i][0]) == -1) return false;
                        
                        // check for value
                        if (entries1[i][1] != o2[entries1[i][0]]) return false
                    }

                    return true;
                },
                qualificationChanged(){
                    // check if there was a change in the qualificaiton setup
                    // only save to server in this case
                    const confDB = this.roundMod.round.qualiConf ? JSON.parse(this.roundMod.round.qualiConf) : {};
                    return !(this.compareObjects(confDB, this.qualificationConfiguration[this.selectedQualificationModel]) && this.roundMod.round.qualiModule == this.selectedQualificationModel); // either conf or the module has changed
                },
                saveQualification(funcOverride=undefined){
                    // save the potentially changed qulification setting
                    // do the update in rEventGroup


                    if (this.qualificationChanged()){

                        const rCopy = JSON.parse(JSON.stringify(this.roundMod.round))

                        rCopy.qualiModule = this.selectedQualificationModel
                        rCopy.qualiConf = JSON.stringify(this.qualificationConfiguration[this.selectedQualificationModel]);

                        rEG.room.updateRoundInit(rCopy, funcOverride)
                    } 
                    this.overlay = undefined;
                    
                },
                contestLink(contest){
                    if (this.discipline.type==1){
                        return `./techHighAdmin?xContest=${contest.xContest}`
                    } else if (this.discipline.type==2){
                        return `./techLongAdmin?xContest=${contest.xContest}`
                    } else if (this.discipline.type==3){
                        return `./trackAdmin?xContest=${contest.xContest}`
                    }
                    return '';
                },
                sortRank(a,b){
                    if (a.ranking.overall==b.ranking.overall){
                        return (a.rank-b.rank);
                    } else {
                        return (a.ranking.overall - b.ranking.overall);
                    }
                },
                rankFormatter(r){
                    if (r>=99999){
                        return ''
                    } else {
                        return r;
                    }
                },
                rF(r){
                    return this.rankFormatter(r);
                },
            },
            computed:{

                // whether the current QM setup is valid (null) or not (the error string)
                QMvalidation: function(){
                    return this.qualificationModules.find(QM=>QM.nameDB==this.selectedQualificationModel).validate.bind(this)();
                },

                // NOTE: Probably not needed anymore
                // Create a datastructure as needed to use the server-side ranking and bundling functionality. This means that we first merge all data from all groups/contests and series together and split them again afterwards during bundling, based on the chosen kind of bundling. 
                // TODO: how can we have several different rankings (by series, by contest, by round) stored, independent on the chosen bundling*? (All those different rankings might be needed for the qualification module, even if the data is not shown in this way)
                // * the view (by series, overall series within contest, overall contests) is linked to the bundling.
                /*resultData: function(){
                    const resultData = [];
                    for (let [xContest, contest] of this.contests){
                        if (contest.status<200){
                                continue;
                            }
                        for (let series of contest.series){
                            if (series.status<200){
                                continue;
                            }
                            for (let ssr of series.seriesstartsresults){

                                // only consider ssr of persons in the respective event

                                if (this.discipline.type==1){
                                    // techHigh
                                    let res = JSON.parse(JSON.stringify(ssr));

                                    // rename the results array
                                    res.results = res.resultshigh;
                                    delete res.resultshigh;

                                    // to be filled
                                    res.rankingData = {
                                        totalFailedAttempts: 0, // until and with the last valid hight
                                        //failedAttemptsSinceLastValid: 0, // after 3, the person is out of the competition. 
                                        failedAttemptsOnLastValid: 0,
                                        lastValidHeight: 0,
                                        numFailedJumpoffAttempts:0,
                                        numValidJumpoffAttempts:0
                                    }
                                    for (let rh of ssr.resultshigh){
                                        let h = series.heights.find(h=>h.xHeight==rh.xHeight);
                                        
                                        if (h.jumpoffOrder==0 && rh.resultsHighValid && h.height>res.rankingData.lastValidHeight){
                                            res.rankingData.lastValidHeight = h.height;
                                            res.rankingData.failedAttemptsOnLastValid = rh.resultsHighFailedAttempts;
                                        }
                                    }
                                    for (let rh of ssr.resultshigh){
                                        // get the height in cm
                                        let h = series.heights.find(h=>h.xHeight==rh.xHeight);

                                        res.results.push({
                                            height: h.height,
                                            //resultsStr, // not needed here
                                            jumpoffOrder: h.jumpoffOrder,
                                            resultsHighFailedAttempts: rh.resultsHighFailedAttempts,
                                            resultsHighValid: rh.resultsHighValid,
                                            resultsHighPassed: rh.resultsHighPassed,
                                        });

                                        // calculate the ranking data
                                        if (h.jumpoffOrder>0){
                                            // in jumpoff
                                            if (rh.resultsHighValid){
                                                res.rankingData.numValidJumpoffAttempts++;
                                            } else{
                                                res.rankingData.numFailedJumpoffAttempts++;
                                            }
                                        } else {
                                            // regular result
                                            // the totalFailedAttempts shall only consider the failed atempts until and including the lastValidHeight, but not in further 
                                            if (h.height<=res.rankingData.lastValidHeight){
                                                res.rankingData.totalFailedAttempts += rh.resultsHighFailedAttempts;
                                            }
                                        }
                                    }

                                    resultData.push(res);
                                    
                                } else if (this.discipline.type==2){
                                    // techLong
                                    let res = JSON.parse(JSON.stringify(ssr));

                                    // rename the results array
                                    res.results = res.resultstech;
                                    delete res.resultstech;
                                    
                                    res.rankingData = {
                                        bestResultWindValid: 0, // will ALWAYS be filled with the best result where the wind either does not exist (e.g throws or indoor) or where it is <=2.0 m/s; this is actually not needed for ranking during a competition, but only for qualification limits, PB /SB etc.
                                        bestResultWindValidWind: null, // will be set to the wind of the best result with valid wind
                                        bestResult: 0, // the overall best result
                                        bestResultWind: null, // the wind for the respective result
                                        resultsSorted: [], // best first; only non-zero results, but independent of the wind; will be used for ranking later (Note: the wind is not important here)
                                    }

                                    for (let r of res.results){
                                        // assuming that a value of 0 means a not valid result
                                        if (r.result){
                                            res.rankingData.resultsSorted.push(r.result);
                                        }

                                        // calculate the best result considering wind
                                        if ((r.wind===null || r.wind<=200)){
                                            if (res.rankingData.bestResultWindValid < r.result){
                                                res.rankingData.bestResultWindValid = r.result;
                                                res.rankingData.bestResultWindValidWind = r.wind;

                                            } else if (res.rankingData.bestResultWindValid == r.result && r.wind<res.rankingData.bestResultWindValidWind){
                                                // just update the wind, because it is lower
                                                res.rankingData.bestResultWindValidWind = r.wind;
                                            }
                                        }

                                        // the best result independent of the wind
                                        if ( res.rankingData.bestResult < r.result){
                                            res.rankingData.bestResult = r.result;
                                            res.rankingData.bestResultWind = r.wind;
                                        } else if ( res.rankingData.bestResult == r.result && r.wind<res.rankingData.bestResultWind){
                                            // just update the wind, because it is lower
                                            res.rankingData.bestResultWind = r.wind;
                                        }

                                    }
                                    // sort the results for the sorted view;
                                    res.rankingData.resultsSorted.sort().reverse(); 

                                    resultData.push(res);
                                    
                                } else if (this.discipline.type==1){
                                    // track
                                    // not a lot to do, but include the extra track table
                                    let res = JSON.parse(JSON.stringify(ssr));
                                    delete res.resultstrack; // not needed
                                    res.time = ssr.resultstrack.time
                                    res.timeRounded = ssr.resultstrack.timeRounded
                                    res.rank = ssr.resultstrack.rank
                                    //res.reactionTime = ssr.resultstrack.reactionTime

                                    resultData.push(res);
                                } 
                            }
                        }
                    }
                },*/

                roundData: function(){
                    // create a data structure, which is ideal for drawing; 
                    // we want to have two views per round: 
                    // (A) for group assignment: one list of all participants in this round, i.e. for the frist round, based on "start" for the event/eventgroup in and for any subsequent round, based on the qualification in the previous round. Include PB/SB in the first round and additionally the result in the previous round in all subsequent rounds. 
                    // (B) to define the qualification for the next round. One list per group in this round, series seaprated or merged; including the results and rank
                    // is an array with objects for each round: [{round1},{round2}]
                    // include information on what shall be collapsed/expanded/shown by default
                    if (! ('rounds' in this.eventGroup && this.inscriptions.length!=0 && this.clubs.length!=0)){
                        return [];
                    }
                    let rounds = [];

                    for (let r of this.eventGroup.rounds){
                        // Note: we cannot define here, whether overview=group assignment or results=qualification shall be shown, since this shall not be "reset" on every change.
                        
                        // create a list of all "starts" (but include all relrevant data, not only the entries in start!) for the overview. This depends on the round: in the first round, it is based on the "start" entry, then it is based on the qualification in the previous round.
                        let starts = [];
                        let resAll = []; // all results (copy of ssrs extended with result/ranking stuff as needed for the automatic ranking)
                        let resByGroup = {}; // an array of an object for each group, referenced with the group number. The object looks like {all:[array of all results in this group], resBySeries:{xSeries1:[array of results in this series], xSeries2:[], ...}}

                        
                        // find the current SIGs of this round
                        let SIGs = this.startsInGroups.filter(sig=>sig.xRound==r.xRound);
                        let xSIGs = SIGs.map(s=>s.xStartgroup);

                        if (r.order==1){
                            starts = this.starts.map(s=>{
                                // find the inscription (includes the name etc)
                                const i = this.inscriptions.find(i2=>i2.xInscription==s.xInscription);
                                const a = i.athlete;
                                const c = this.clubs.find(c2=>c2.xClub==a.xClub); 
                                const sig = this.startsInGroups.find(sig2=>sig2.xRound==r.xRound && sig2.xStart==s.xStart) ?? null;

                                // create a combination of category and event info
                                let e =this.eventGroup.events.find(e=>e.xEvent==s.xEvent);
                                let info = ' ' + e.info;
                                info = info.length>1 ? info : ''; 
                                let eventStr = this.categories.find(c=>c.xCategory==e.xCategory)?.name + info;

                                // TODO: eventually add region
                                return {
                                    xStart: s.xStart,
                                    xInscription: s.xInscription,
                                    paid: s.paid,
                                    notificationPerf: s.notificationPerf,
                                    bestPerf: s.bestPerf,
                                    bestPerfLast: s.bestPerfLast,
                                    competitive: s.competitive,
                                    xCategory: i.xCategory,
                                    bib: i.number,
                                    birthdate: a.birthdate,
                                    forename: a.forename,
                                    lastname: a.lastname,
                                    identifier: a.identifier,
                                    nationalBody: a.nationalBody,
                                    sex: a.sex,
                                    clubName: c.name,
                                    xClub: a.xClub,
                                    xAthlete: a.xAthlete,
                                    xRegion: a.xRegion,
                                    xStartgroup: sig?.xStartgroup,
                                    groupNumber: sig.number,
                                    eventStr,
                                }
                            }); // all starts of this eventGroup
                        } else {
                            // TODO: get all starts based on the qualifications set in the previous round.
                            // then simply create the same data as above
                        }
                        
                        let groups = [];
                        for (let g of r.groups){
                            let o={};
                            for (let prop of Object.getOwnPropertyNames(g)){
                                o[prop] = g[prop];
                            }

                            resByGroup[g.number] =
                            {
                                all:[],
                                resBySeries:{}
                            };

                            // add some more data to the group-object:
                            if (g.xContest in this.contests){
                                const contest = this.contests[g.xContest].contest;
                                const seriesOriginal = this.contests[g.xContest].series;
                                o.contest = contest;
                                o.seriesOriginal = seriesOriginal;
                                o.series = []; // create a copy of the series object, but where ssrs are filtered and only ssrs of people of the eventGroup are considered; additionaly, the SSR is as needed for ranking and also includes all information for display

                                if (contest.status>=200){
                                    for (let s of seriesOriginal){

                                        resByGroup[g.number].resBySeries[s.xSeries] = [];

                                        let sCopy = {
                                            seriesstartsresults:[],
                                            heights: s.height, // reference the original (!) heights object, if present
                                            xSeries: s.xSeries,
                                            xContest: s.xContest,
                                            xSite: s.xSite,
                                            status: s.status,
                                            number: s.number,
                                            name: s.name,
                                            datetime: s.datetime,
                                            id: s.id,
                                            aux: s.aux,
                                        };
                                        o.series.push(sCopy);

                                        for (let ssr of s.seriesstartsresults){

                                            // only consider ssr of persons in the respective event
                                            if (xSIGs.indexOf(ssr.xStartgroup)==-1){ 
                                                continue;
                                            }

                                            // Create a datastructure as needed to use the server-side ranking and bundling functionality. This means that we slightly modify the aw-datastructure and create arrays of ssr/result objects as we want to assign the rank to them. ¨
                                            // start with a copy of the ssr, before we change this object
                                            let res = JSON.parse(JSON.stringify(ssr));
                                            //add a reference to the original object
                                            res.ssrOriginal = ssr;
                                            res.qualification = ssr.qualification;
                                            if (this.discipline.type==1){
                                                // techHigh

                                                // rename the results array
                                                res.results = res.resultshigh;
                                                delete res.resultshigh;
                                                
                                                // to be filled
                                                res.rankingData = {
                                                    totalFailedAttempts: 0, // until and with the last valid hight
                                                    //failedAttemptsSinceLastValid: 0, // after 3, the person is out of the competition. 
                                                    failedAttemptsOnLastValid: 0,
                                                    lastValidHeight: 0,
                                                    numFailedJumpoffAttempts:0,
                                                    numValidJumpoffAttempts:0,
                                                    inCompetition: true, // needed to know how many athletes are still in compeititon, since the competition ends early if this is less than the reuired number of athletes.
                                                }
                                                for (let rh of ssr.resultshigh){
                                                    let h = s.heights.find(h=>h.xHeight==rh.xHeight);
                                                    
                                                    if (h.jumpoffOrder==0 && rh.resultsHighValid && h.height>res.rankingData.lastValidHeight){
                                                        res.rankingData.lastValidHeight = h.height;
                                                        res.rankingData.failedAttemptsOnLastValid = rh.resultsHighFailedAttempts;
                                                    }
                                                }
                                                for (let rh of ssr.resultshigh){
                                                    // get the height in cm
                                                    let h = s.heights.find(h=>h.xHeight==rh.xHeight);

                                                    res.results.push({
                                                        height: h.height,
                                                        //resultsStr, // not needed here
                                                        jumpoffOrder: h.jumpoffOrder,
                                                        resultsHighFailedAttempts: rh.resultsHighFailedAttempts,
                                                        resultsHighValid: rh.resultsHighValid,
                                                        resultsHighPassed: rh.resultsHighPassed,
                                                    });

                                                    // calculate the ranking data
                                                    if (h.jumpoffOrder>0){
                                                        // in jumpoff
                                                        if (rh.resultsHighValid){
                                                            res.rankingData.numValidJumpoffAttempts++;
                                                        } else{
                                                            res.rankingData.numFailedJumpoffAttempts++;
                                                        }
                                                    } else {
                                                        // regular result
                                                        // the totalFailedAttempts shall only consider the failed atempts until and including the lastValidHeight, but not in further 
                                                        if (h.height<=res.rankingData.lastValidHeight){
                                                            res.rankingData.totalFailedAttempts += rh.resultsHighFailedAttempts;
                                                        }
                                                        if (rh.resultsHighFailedAttempts==3) {
                                                            res.rankingData.inCompetition = false;
                                                        }

                                                    }
                                                }
                                                if (res.rankingData.lastValidHeight>0){
                                                    res.resultStr = this.formatValue(res.rankingData.lastValidHeight);
                                                } else {
                                                    res.resultStr = '<%= __("NM") %>';
                                                }
                                                
                                            } else if (this.discipline.type==2){
                                                // techLong

                                                // rename the results array
                                                res.results = res.resultstech;
                                                delete res.resultstech;
                                                
                                                res.rankingData = {
                                                    bestResultWindValid: 0, // will ALWAYS be filled with the best result where the wind either does not exist (e.g throws or indoor) or where it is <=2.0 m/s; this is actually not needed for ranking during a competition, but only for qualification limits, PB /SB etc.
                                                    bestResultWindValidWind: null, // will be set to the wind of the best result with valid wind
                                                    bestResult: 0, // the overall best result
                                                    bestResultWind: null, // the wind for the respective result
                                                    resultsSorted: [], // best first; only non-zero results, but independent of the wind; will be used for ranking later (Note: the wind is not important here)
                                                }

                                                for (let r of res.results){
                                                    // assuming that a value of 0 means a not valid result
                                                    if (r.result){
                                                        res.rankingData.resultsSorted.push(r.result);
                                                    }

                                                    // calculate the best result considering wind
                                                    if ((r.wind===null || r.wind<=200)){
                                                        if (res.rankingData.bestResultWindValid < r.result){
                                                            res.rankingData.bestResultWindValid = r.result;
                                                            res.rankingData.bestResultWindValidWind = r.wind;

                                                        } else if (res.rankingData.bestResultWindValid == r.result && r.wind<res.rankingData.bestResultWindValidWind){
                                                            // just update the wind, because it is lower
                                                            res.rankingData.bestResultWindValidWind = r.wind;
                                                        }
                                                    }

                                                    // the best result independent of the wind
                                                    if ( res.rankingData.bestResult < r.result){
                                                        res.rankingData.bestResult = r.result;
                                                        res.rankingData.bestResultWind = r.wind;
                                                    } else if ( res.rankingData.bestResult == r.result && r.wind<res.rankingData.bestResultWind){
                                                        // just update the wind, because it is lower
                                                        res.rankingData.bestResultWind = r.wind;
                                                    }

                                                }
                                                // sort the results for the sorted view;
                                                res.rankingData.resultsSorted.sort().reverse(); 

                                                res.resultStr = this.formatValue(res.rankingData.bestResult);
                                                
                                            } else if (this.discipline.type==3){
                                                // track
                                                // not a lot to do, but include the extra track table
                                                delete res.resultstrack; // not needed
                                                res.time = ssr.resultstrack.time
                                                res.timeRounded = ssr.resultstrack.timeRounded
                                                res.rank = ssr.resultstrack.rank
                                                //res.reactionTime = ssr.resultstrack.reactionTime

                                                res.resultStr = this.formatValue(res.time);

                                            } 

                                            // TODO: ranking
                                            // TODO: show all this nice data
                                            // TODO: qualification setup
                                            // TODO: apply qualification

                                            // add all info (name, club, etc) to res
                                            const sig = this.startsInGroups.find(sig2=>sig2.xStartgroup==ssr.xStartgroup);
                                            const start = this.starts.find(s2=>s2.xStart==sig.xStart);
                                            const i = this.inscriptions.find(i2=>i2.xInscription==start.xInscription);
                                            const a = i.athlete;
                                            const c = this.clubs.find(c2=>c2.xClub==a.xClub); 
                                            // create a combination of category and event info
                                            let e =this.eventGroup.events.find(e=>e.xEvent==start.xEvent);
                                            let info = ' ' + e.info;
                                            info = info.length>1 ? info : ''; 
                                            let eventStr = this.categories.find(c=>c.xCategory==e.xCategory)?.name + info;
                                            
                                            // TODO: eventually add region
                                            res.xStart = start.xStart;
                                            res.xInscription = start.xInscription;
                                            res.paid = start.paid;
                                            res.notificationPerf = start.notificationPerf;
                                            res.bestPerf = start.bestPerf;
                                            res.bestPerfLast = start.bestPerfLast;
                                            res.competitive = start.competitive;
                                            res.xCategory = i.xCategory;
                                            res.bib = i.number;
                                            res.birthdate = a.birthdate;
                                            res.forename = a.forename;
                                            res.lastname = a.lastname;
                                            res.identifier = a.identifier;
                                            res.nationalBody = a.nationalBody;
                                            res.sex = a.sex;
                                            res.clubName = c.name;
                                            res.xClub = a.xClub;
                                            res.xAthlete = a.xAthlete;
                                            res.xRegion = a.xRegion;
                                            res.xStartgroup = sig?.xStartgroup;
                                            res.groupNumber =sig.number;
                                            res.eventStr = eventStr;

                                            resByGroup[g.number].resBySeries[s.xSeries].push(res);
                                            sCopy.seriesstartsresults.push(res);

                                            resAll.push(res);
                                            resByGroup[g.number].all.push(res);
                                        }

                                        // add rank within series
                                        if (this.discipline.type==1){
                                            rankTechHigh(resByGroup[g.number].resBySeries[s.xSeries], 'series')
                                        } else if (this.discipline.type==2){
                                            rankTechLong(resByGroup[g.number].resBySeries[s.xSeries], 'series')
                                        } else if (this.discipline.type==3){
                                            rankTrack(resByGroup[g.number].resBySeries[s.xSeries], 'series')
                                        }
                                    } // end of series loop
                                } // end of contest status>=200

                            } else {
                                o.contest = null;
                            }
                            // more?

                            groups.push(o);

                            // rank within group
                            if (this.discipline.type==1){
                                rankTechHigh(resByGroup[g.number].all, 'group')
                            } else if (this.discipline.type==2){
                                rankTechLong(resByGroup[g.number].all, 'group')
                            } else if (this.discipline.type==3){
                                rankTrack(resByGroup[g.number].all, 'group')
                            }
                        }
                        groups.sort((a,b)=>a.number-b.number);

                        // rank overall
                        if (this.discipline.type==1){
                            rankTechHigh(resAll, 'overall')
                        } else if (this.discipline.type==2){
                            rankTechLong(resAll, 'overall')
                        } else if (this.discipline.type==3){
                            rankTrack(resAll, 'overall')
                        }

                        const roundFinished = groups.reduce((finished, g)=>finished && g.contest?.status>=200, true);

                        rounds.push({
                            round:r,
                            starts,
                            groups, // references the contests
                            roundFinished,
                            //resAll,
                            //resByGroup,
                        })
                    }

                    rounds.sort((a,b)=>{
                        return a.order-b.order;
                    })
                    return rounds;
                },

                // the discipline of this contest
                discipline: function(){
                    return this.disciplines.find(d=>d.xDiscipline==this.eventGroup.xDiscipline)
                },
                

                // get a list of all xEvents of this 
                xEvents: function(){
                    return this.eventGroup.events.map(e=>e.xEvent);
                },

                // get all starts related to this eventGroup
                xStarts: function(){
                    return this.starts.map(s=>s.xStart);
                },
                starts: function(){
                    return this.startsAll.filter(s=>this.xEvents.indexOf(s.xEvent)>-1)
                },

                // list of all startInGroup per round, e.g. [[{SIG1 of orund 1}, {SIG2 of roud 1}], [{SIG1 of round 2}, ...], ...]
                SIGs: function(){
                    let SIGs = [];
                    for (let r of this.eventGroup.rounds){
                        SIGs.push(this.startsInGroups.filter(sig=>sig.xRound==r.xRound))
                    }
                    return SIGs;
                },
                xSIGs: function(){
                    let xSIGs = [];
                    for (let i=0; i<this.SIGs.length; i++){
                        xSIGs.push(this.SIGs[i].map(sig=>sig.xStartgroup));
                    }
                    return xSIGs;
                },

                // calculate for every round in which state it is, returns an array.
                // 0 = the contests of all groups (if there is a linked one) are still in the initial state, i.e. before the end of the roll call 
                // 1 = at least one group is still in the initial state, i.e. we can assign an athlete to this group, but eventually no others
                // 2 = currently, all contests are ongoing and no group assignements are possible
                // 3 = all contests are finished, i.e. it is possible to do the qualifications for the next round
                roundStates: function(){
                    // we assume that the rounds are sorted

                    if (!this.eventGroup?.rounds){
                        // the data is not yet loaded; return empty array
                        return [];
                    }
                    let states = Array.from(this.eventGroup.rounds.length);

                    for (let iR=0; iR<this.eventGroup.rounds.length; iR++){
                        const r = this.eventGroup.rounds[iR];
                        let rollCallCount = 0;
                        let finishedCount = 0;
                        let ongoingCount = 0;
                        for (let iG=0; iG<r.groups.length; iG++) {
                            const g = r.groups[iG];
                            if (g.contest){
                                // if contest is null, just ignore it (i.e. a group that has no contest does not matter, escept that we could show a warning)
                                if (g.contest.status<40){
                                    // in roll Call mode
                                    rollCallCount += 1;
                                } else if (g.contest.status>=180){
                                    // finished
                                    finishedCount += 1;
                                } else {
                                    ongoingCount += 1;
                                }
                            } else {
                                // if contest is not given, the state is considered as before roll call
                                rollCallCount += 1;
                            }
                        }

                        if (finishedCount==r.groups.length){
                            states[iR] = 3;
                        } else if (rollCallCount==r.groups.length){
                            states[iR] = 0;
                        } else if (rollCallCount>0){
                            states[iR] = 1;
                        } else {
                            states[iR] = 2;
                        }
                    }

                    return states;
                },
                
                // get the round-order that we can modify currently; returns null if none
                /*assignmentForRound: function(){
                    // the first round with state <=1
                    for (let i =0; i<this.roundStates.length; i++){
                        if (this.roundStates[i]<=1){
                            return i+1;
                        }
                    }
                    return null;
                },
                workRound: function(){
                    return this.eventGroup.rounds[this.assignmentForRound-1];
                },*/

                // create an object for each entry to show with all needed data, including start, inscription, startgroup (if available); 
                // there will be three different arrays:
                // (1) Q=qualified: people participating (startgroup defined, but eventually no SSR!) in the last round which are qualified, i.e. they have the qualification tag in SSR
                // (2) NQ=non-qualified: people participating in the last round but not qualificated
                // (3) PQ=pre-qualified: starts that do not have any startgroup entry (this obviously includes everybody in the first round) and starts people that were qualified in a previous round but since then were never in a startgroup. NOTE: those are e.g. people that were allowed to leave out (a) round(s). (Such a direct qualification for the semi-finals was used at the Europeam Championships 2022 in Munich). 
                // the groups 1 + 3 can get a group assigned, while group 2 cannot
                
                // group 1 (qualified)
                startsQ: function(){
                    // TODO: create a list of all qualified persons in the last round. Do this on the basis of the qualified flags in the seriesstartsresults (SSR) of the previous round.
                    return [];
                },
                // groups 2 (non-qualified)
                startsNQ: function(){
                    // TODO: create a list of all persons that perticipated in the previous round, but did not qualify there. This list contains all persons of the last round, when the qualifications were not done yet
                    return [];
                },
                // group 3 (pre-qualified)
                startsPQ: function(){

                    // if there is no assignmentForROnd defined, do not run the next aprt, sicne it would fail
                    if (!(this?.assignmentForRound)){
                        return [];
                    }

                    const startsPQdata = [];

                    // loop over all starts of this eventGroup

                    // begin with all starts and remove all entries from startsNQ and startsQ, i.e. all starts which have a result in the last round
                    const startsPQ = this.starts.filter(s=> !( this.startsNQ.find(s2=> s2.xStart==s.xStart) || this.startsQ.find(s2=> s2.xStart==s.xStart)));

                    startLoop:
                    for (let i=startsPQ.length-1; i>=0; i--){
                        
                        const start = startsPQ[i];
                        
                        let ssr;
                        let SIG;
                        //let roundIndex;
                        // get the group entry of the person of the round to be changed
                        SIG = this.SIGs[this.assignmentForRound-1].find(sig=>sig.xStart==start.xStart);
                        const group = this.eventGroup.rounds[this.assignmentForRound-1].groups.find(gr=> gr.number == SIG?.number);

                        // loop backwards over all rounds from the assignmentForRound

                        // -2 because assignment for round is already 1-based and here we only want to loop over the rounds before this round
                        for(let roundIndex=this.assignmentForRound-2; roundIndex>=0; roundIndex--){
                            // is there a startgroup entry for this start for this round?
                            SIG = this.SIGs[roundIndex].find(sig=>sig.xStart==start.xStart);
                            if (SIG){
                                // check if an SSR exists for this round
                                // get the contest, then try to get the series and SSR
                                const group2 = this.eventGroup.rounds[roundIndex].groups.find(gr=> gr.number == SIG.number); // it should not be necessary to check xRound as well

                                const contest = this.contests[group2.contest.xContest];
                                if (!group2 || !contest){
                                    alert('Could not find the group or contest; this should never happen and startsPQ cannot be calculated because of that');
                                    return [];
                                }
                                // loop over all series and try to find the SIG
                                for (let iS=0; iS<contest.series.length; iS++){
                                    ssr = contest.series[iS].seriesstartsresults.find(ssr=>ssr.xStartgroup=SIG.xStartgroup);
                                    if (ssr){
                                        // we have found the ssr and can stop the loop over the series     
                                        break;
                                    }
                                }
                                if (!ssr){
                                    // it seems like the person actually is part in this contest, but has no ssr entry; 
                                    // I dont know if this ever happens; but in any case, remove the person
                                    startsPQ.splice(i,1);
                                    continue startLoop;
                                }


                                // if the person has a result in a previous round and was NOT qualified, remove it from the list
                                if (ssr.qualification==0){
                                    startsPQ.splice(i,1);
                                    continue startLoop;
                                }

                            } else {
                                // has no entry; try in previous round
                                // nothing to do here
                            }
                        }

                        // create the actual data
                        startsPQdata.push(this.createAssignmentData(start, SIG, ssr, group));

                    }

                    // TODO: eventually create here the data for each start that we need to show to the user, i.e. a combination of start, inscription, ...
                    return startsPQdata;
                },

                /*roundForContests: function(){
                    // only to allow that the watcher to get the contests could be reused in the future for other rounds than 'assignmentforRound' function
                    return this.assignmentForRound;
                },*/
                
                // always make sure that the contests present in the round "assignmentForRound" exist
                // probably not needed anymore
                /*contestsRequested2: function(){
                    // it is not perfectly proper programming to set other variables than the one this function is made for; however, we should use this approach, since a watcher would only watch e.g. roundForContests, but there must also be a reaction to changes in group.xContest

                    // TODO: this does not work!!! contestsRequested seems to be always undefined 
                    var oldContestsRequested;
                    if (this.contestsRequested){
                        oldContestsRequested = this.contestsRequested.slice();
                    } else {
                        oldContestsRequested = [];
                    }
                    
                    // get all contests that are required from now on; use map and filter then all undefined values
                    var requiredNew;
                    if (this.roundForContests){
                        requiredNew = this.eventGroup.rounds[this.roundForContests-1].groups.map(g=>g.xContest).filter(c=>c);
                    } else {
                        requiredNew = [];
                    }

                    // compare the old and new list of requested contests
                    // request the contests that were previously not needed and delete the contests that are not needed anymore
                    for (let xcNew of requiredNew){
                        // if the contest is not loaded yet, load it
                        if (oldContestsRequested.indexOf(xcNew)==-1){
                            // get the vue
                            this.contestVUs[xcNew] = new vuContestTechHigh2(this, ms, xcNew);
                        }
                    }
                    for (let xcOld of oldContestsRequested){
                        if (requiredNew.indexOf(xcOld)==-1){
                            // return the vue, since it is not used anymore
                            // TODO
                        }
                    }

                    return requiredNew;
                },*/
                qualificationStatesObj: function(){
                    const o={};
                    for (let qs of this.qualificationStates){
                        o[qs.value] = qs;
                    }
                    return o;
                },
                qualificationStates: function(){
                    if (this.discipline){
                        if (this.discipline.type==3){
                            return this.qualificationStatesTrack;
                        } else {
                            return this.qualificationStatesTech;
                        }
                    } else {
                        return [];
                    }
                },
                qualificationStateLegend: function(){
                    let t = '';
                    for (let qs of this.qualificationStates){
                        if(qs.abbreviation!=''){
                            
                            if (t!=''){
                                t+=`; `
                            }
                            t+=`${qs.abbreviation}: ${qs.text}`;
                        }
                    }
                    return t;
                },
                qualificationModulesFiltered: function(){
                    return this.qualificationModules.filter(mod=>mod.baseDisciplineTypes.includes(this.discipline.type));
                },
                
            },
            watch:{

                'eventGroup.rounds': function(){
                    for (let r of this.eventGroup.rounds){
                        // by default always show the overview. When the round is opened, it will automatically calculate the best tab to show
                        this.tabSelection[r.xRound] = 'overview';
                    }
                },

                /*assignmentForRound: function() {
                    this.updateContests();
                },
                /*contests: {
                    deep:true,
                    handler: function(newVal, oldVal){
                        // TOOD: actually updateContests only need to be called when the state of a contest changes, contests are added/deleted (etc), but not when a result is added
                        this.updateContests();
                    }
                },*/
                eventGroup: function(newVal, oldVal){
                    this.updateContests();
                },
                discipline: function(newVal, oldVal){
                    // this is needed when the eventGroups arrive before the disciplines (from rStart)
                    this.updateContests(); 
                }

            },
            mounted:function(){
                // initialize all qualification modules
                this.qualificationModules.forEach((QM)=>{
                    QM.initFunc.bind(this)();
                })
            },
            components:{
                'v-table':VTable,
                'v-th': VTh,
                'v-tr':VTr,
            }
        }

        // mount it 
        vueGQ = Vue.createApp(vueAppConfig).mount('#vueGQ');
        
        let ms = getMeetingShortname();
        
        // get the GET-parameter xContest (null if not found)
        let xEventGroup = findGetParameter('xEventGroup');
        
        rEG = new vuEventGroup(vueGQ, ms, xEventGroup);
        rStarts = new vuStarts(vueGQ, ms);
        rInscriptions = new vuInscriptions(vueGQ, ms);
        rStartsInGroups = new vuStartsInGroups(vueGQ, ms);
        rClubs = new vuClubs(vueGQ, ms);
        
    }
    </script>
    
    <div id="vueGQ">
        <h1>{{discipline?.name}} {{eventGroup.name}}</h1>
        <h2><%= __('Events') %>:</h2>
        <ul>
            <li v-for="(event, eventIndex) in eventGroup.events">
                {{categories.find(c=>c.xCategory==event.xCategory)?.name}}
                {{event.info}}
                <!--<br>{{event.xEvent}}-->
            </li>
        </ul>
        <h2><%= __('Rounds') %>: </h2>
        <details v-for="r in roundData" v-on:toggle="autoHighlightTab(r, $event)"> <!--style="border:1px solid black; border-radius:3px; padding: 3px;" -->
            <summary style="font-size:1.17em; font-weight: bold;"><%= __("Round") %> {{r.order}}<template v-if="r.name!=''">: {{r.name}}</template></summary>
            <template v-if="r.groups.length>1">
                <!-- show the list of groups only when there are multiple groups in this round -->
                <%= __("Groups") %>
                <ul>
                    <li v-for="g in r.groups">
                        {{g.number}}<template v-if="g.name!=''">: "{{g.name}}"</template> 
                        <template v-if="g.contest">
                            , <a v-bind:href="contestLink(g.contest)" v-bind:style="{'background-color':contestStates.find(cs=>cs.value==g.contest.status).backgroundColor, color:contestStates.find(cs=>cs.value==g.contest.status).textColor}">{{formatTime(g.contest.datetimeStart)}} {{g.contest.name}}, <!--<%= __("Status") %>--> {{contestStates.find(cs=>cs.value==g.contest.status).text}}</a>
                        </template>
                        <template v-else>
                            , <%= ("No contest linked to this group.") %>
                        </template>
                        <!--{{g}}-->
                    </li>
                </ul>
            </template>
            <template v-if="r.groups.length==1">
                <template v-if="r.groups[0].contest">
                    <a v-bind:href="'./techHighAdmin?xContest='+r.groups[0].contest.xContest" v-bind:style="{'background-color':contestStates.find(cs=>cs.value==r.groups[0].contest.status).backgroundColor, color:contestStates.find(cs=>cs.value==r.groups[0].contest.status).textColor}">{{formatTime(r.groups[0].contest.datetimeStart)}} {{r.groups[0].contest.name}}, <!--<%= __("Status") %>--> {{contestStates.find(cs=>cs.value==r.groups[0].contest.status).text}}</a>
                </template>
                <template v-else>
                    <%= ("No contest linked yet.") %>
                </template>
            </template>
            <!-- is the first round really different? Yes, since in the first round we must be able to assign the initial group, and later on the group for the next round based on the qualification -->
             <!-- We need to views for each round: 
              (A) A view to define the group of each person for this round. The data needed for this differs between round 1 and the subsequent rounds: For round 1, it is simply given by the "inscription" (i.e. entry in "start" to event/eventGroup). For the subsequent rounds, the data needs to be merged based on the qualifications set in the contests of the previous round. 
              (B) A results view, which is also used to set qualifications (and eventually the group) for the next round. In this view, we might provide the option to view the results merged over all contests and series or seaprately. -->

            <div>
                <label>
                    <input type="checkbox" v-model="showEvent">
                    <%= __("Show event") %>
                </label> 
                <label>
                    <input type="checkbox" v-model="showFullDetails">
                    Show full details (for debugging)
                </label> 
                
                <div class="tabContainer" style="--numcols:3;">
                    <input class="tabHead" type="radio" v-bind:id="'tab1'+r.round.xRound" v-bind:name="'tabGroup'+r.round.xRound" value="overview" v-model="tabSelection[r.round.xRound]" checked>
                    <label class="tabHead" v-bind:for="'tab1'+r.round.xRound" style="grid-column:1;"><%= __("Overview") %><template v-if="r.round.groups.length>1"> / <%= __("Group assignment") %></template></label>
                    <div class="tabContent">
                        <h3><%= __('Group assignment') %></h3>
                        <!--<div style="width:95vw">{{starts}}</div>
                        <div style="width:95vw">{{roundData}}</div>-->

                        <v-table :data="r.starts" ><!--:filters="filters"-->
                            <template #head>
                                <thead>
                                    <tr>
                                        <th v-if="showFullDetails" is="vue:v-th" sortkey="xInscription">xInscription</th>
                                        <th v-if="showFullDetails" is="vue:v-th" sortkey="xStart">xStart</th>
                                        <th v-if="showFullDetails" is="vue:v-th" sortkey="xStartgroup">xStartgroup</th>
                                        <th is="vue:v-th" sortkey="bib"><%= __('Bib') %></th>
                                        <th is="vue:v-th" sortkey="lastname" defaultsort="asc"><%= __('Name') %></th>
                                        <th is="vue:v-th" sortkey="forename"><%= __('First name') %></th>
                                        <th is="vue:v-th" sortkey="clubName"><%= __('Club') %></th>
                                        <th v-if="showEvent" is="vue:v-th" sortkey="eventStr">Events</th>
                                        <th is="vue:v-th" sortkey="bestPerf">PB</th>
                                        <th is="vue:v-th" sortkey="bestPerfLast">SB</th>
                                        <th is="vue:v-th" sortkey="notificationPerf">ML</th>
                                        <!-- for qualification, add here the result from the last round -->
                                        <th is="vue:v-th" sortkey="group.number"><%= __('Group') %></th>
                                        <th><!--buttons--></th>
                                    </tr>
                                </thead>
                            </template>
                            <template v-slot:body="{displayData}"> 
                                <tbody>
                                    <tr v-for="row in displayData" :key="row.xInscription">
                                        <td v-if="showFullDetails">{{row.xInscription}}</td>
                                        <td  v-if="showFullDetails">{{ row.xStart }}</td>
                                        <td  v-if="showFullDetails">{{ row.xStartgroup }}</td>
                                        <td>{{row.bib}}</td>
                                        <td>{{row.lastname}}</td>
                                        <td>{{row.forename}}</td>
                                        <td>{{row.clubName}}</td>
                                        <td v-if="showEvent">{{row.eventStr}}</td>
                                        <td>{{formatPerf(row?.bestPerf, discipline.xBaseDiscipline)}}</td>
                                        <td>{{formatPerf(row?.bestPerfLast, discipline.xBaseDiscipline)}}</td>
                                        <td>{{formatPerf(row?.notificationPerf, discipline.xBaseDiscipline)}}</td>
                                        <td v-if="r.round.numGroups==1">{{row?.groupNumber}}</td>
                                        <td v-if="r.round.numGroups>1">
                                            <select class="select" v-on:change="groupChanged(row, $event, r)"> <!-- do not use v-model="row.group.number" here to not change the data until it is changed on the server -->
                                                <option value="null" selected v-if="row.xStartgroup === undefined"></option>
                                                <template v-for="(g, gIndex) in r.groups">
                                                    <option :value="g.number" v-bind:selected="row.groupNumber===g.number ? true : null">
                                                        {{g.number}}<template v-if="g.name!=''">: "{{g.name}}"</template>
                                                    </option>
                                                    <!--<option :value="g.number" v-else>
                                                        {{g.number}}<template v-if="g.name!=''">: "{{g.name}}"</template>
                                                    </option>-->
                                                </template>
                                            </select>
                                        </td>
                                        <td>
                                            <!--<button class="btn btnGrey marginRight" v-on:click="modClub(row.xClub)" ><%= __("Change") %></button>
                                            <button class="btn btnRed" v-on:click="deleteClub(row.xClub)"><%= __("Delete") %></button>-->
                                        </td>
                                    </tr>
                                </tbody>
                            </template>
                        </v-table>

                    </div>
                    <input class="tabHead" type="radio" v-bind:id="'tab2'+r.round.xRound" v-bind:name="'tabGroup'+r.round.xRound" value="results" v-model="tabSelection[r.round.xRound]">
                    <label class="tabHead" v-bind:for="'tab2'+r.round.xRound" style="grid-column:2"><%= __("Results") %><template v-if="r.round.order<eventGroup.rounds.length"> / <%= __("Qualifications") %></template></label>
                    <div class="tabContent">
                        <h3><%= __('Results and qualifications') %></h3>
                        <p v-if="!r.roundFinished">The round is not yet finished. The state of all related contests need to be 'Official' or later.</p>
                        <button type="button" class="btn" v-on:click="setQualificationSetup(r)"><%= __("Qualification Assistant") %></button>
                        <div style="display:flex"><div style="flex-grow:1; width:0;"><%= __("Legend") %>: {{qualificationStateLegend}}</div></div>
                        <div> 
                            <details v-for="g in r.groups" open="true">
                                <summary v-bind:style="{'background-color':contestStates.find(cs=>cs.value==g.contest?.status)?.backgroundColor, color:contestStates.find(cs=>cs.value==g.contest?.status)?.textColor}">{{g.number}}{{g.name!=''? ` ${g.name}`:'' }} / {{g.contest!==null ? `${formatTime(g.contest?.datetimeStart)} ${g.contest?.name}, ${contestStates.find(cs=>cs.value==g.contest?.status).text}` : ''}}</summary>
                                <div v-if="g.contest==null || g.contest.status<200">
                                    Contest not yet finished.
                                </div>

                                <div v-for="s in g.series">
                                    <!-- xSeries={{s.xSeries}} xSite={{s.xSite}} status={{s.status}} number={{s.number}} name={{s.name}} datetime={{formatTime(s.datetime)}} id={{s.id}} aux={{s.aux}} -->
                                    <v-table :data="s.seriesstartsresults" ><!--:filters="filters"-->
                                        <template #head>
                                            <thead>
                                                <tr>
                                                    <th is="vue:v-th" :customSort="sortRank" defaultSort="asc">
                                                        <%= __('Rank') %>
                                                        <template v-if="g.series.length>1 || r.groups.length>1"> 
                                                            <template v-if="g.series.length>1 && r.groups.length>1"> <%= __('heat') %>/<%= __('group') %></template>
                                                            <template v-if="g.series.length>1 && r.groups.length==1"> <%= __('heat') %></template>
                                                            <template v-if="g.series.length==1 && r.groups.length>1"> <%= __('group') %></template>/<%= __('round') %>
                                                        </template>
                                                    </th>
                                                    <th v-if="showFullDetails" is="vue:v-th" sortkey="xInscription">xInscription</th>
                                                    <th v-if="showFullDetails" is="vue:v-th" sortkey="xStart">xStart</th>
                                                    <th v-if="showFullDetails" is="vue:v-th" sortkey="xStartgroup">xStartgroup</th>
                                                    <th is="vue:v-th" sortkey="bib"><%= __('Bib') %></th>
                                                    <th is="vue:v-th" sortkey="lastname"><%= __('Name') %></th>
                                                    <th is="vue:v-th" sortkey="forename"><%= __('First name') %></th>
                                                    <th is="vue:v-th" sortkey="clubName"><%= __('Club') %></th>
                                                    <th v-if="showEvent" is="vue:v-th" sortkey="eventStr">Events</th>
                                                    <!--<th is="vue:v-th" sortkey="bestPerf">PB</th>
                                                    <th is="vue:v-th" sortkey="bestPerfLast">SB</th>
                                                    <th is="vue:v-th" sortkey="notificationPerf">ML</th>-->
                                                    <!-- for qualification, add here the result from the last round -->
                                                    <th is="vue:v-th" sortkey="result"><%= __('Result') %></th>
                                                    <th><%= __('Q') %></th>
                                                    <th><!--buttons--></th>
                                                </tr>
                                            </thead>
                                        </template>
                                        <template v-slot:body="{displayData}"> 
                                            <tbody>
                                                <tr v-for="row in displayData" :key="row.xInscription">
                                                    <td>
                                                        <template v-if="row.ranking.overall<99999">  
                                                            <template v-if="g.series.length>1 || r.groups.length>1"> 
                                                                <template v-if="g.series.length>1 && r.groups.length>1"> {{rF(row.rank)}}. / {{rF(row.ranking.group)}}.</template>
                                                                <template v-if="g.series.length>1 && r.groups.length==1"> {{rF(row.ranking.series)}}.</template>
                                                                <template v-if="g.series.length==1 && r.groups.length>1"> {{rF(row.ranking.group)}}.</template>
                                                                / {{row.ranking.overall}}.
                                                            </template>
                                                            <template v-else>
                                                                {{row.ranking.overall}}.
                                                            </template>
                                                        </template> 
                                                    </td>
                                                    <td v-if="showFullDetails">{{row.xInscription}}</td>
                                                    <td  v-if="showFullDetails">{{ row.xStart }}</td>
                                                    <td  v-if="showFullDetails">{{ row.xStartgroup }}</td>
                                                    <td>{{row.bib}}</td>
                                                    <td>{{row.lastname}}</td>
                                                    <td>{{row.forename}}</td>
                                                    <td>{{row.clubName}}</td>
                                                    <td v-if="showEvent">{{row.eventStr}}</td>
                                                    <!--<td>{{formatPerf(row?.bestPerf, discipline.xBaseDiscipline)}}</td>
                                                    <td>{{formatPerf(row?.bestPerfLast, discipline.xBaseDiscipline)}}</td>
                                                    <td>{{formatPerf(row?.notificationPerf, discipline.xBaseDiscipline)}}</td>-->
                                                    <td v-if="row.resultOverrule==0 || (row.resultOverrule==1 && row.rankingData.lastValidHeight>0)">{{row.resultStr}}</td>
                                                    <td v-else>{{participationStatesAll.find(el=>el.value==row.resultOverrule)?.abbreviation}}</td>
                                                    <td>{{qualificationStatesObj[row.ssrOriginal.qualification].abbreviation=='' ? '-' : qualificationStatesObj[row.ssrOriginal.qualification].abbreviation}}</td>
                                                    <td>
                                                        <button class="btn btnGrey marginRight" v-on:click="modQualification(row, g.contest.xContest)" ><%= __("Qabbr") %></button>
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </template>
                                    </v-table>
                                </div>
                            </details>
                        </div>
                    </div>
                </div>
            </div>
            
        </details>
        
        <div class="overlay" v-bind:class="{shown: overlay=='modQualification'}" v-if="overlay=='modQualification'"> <!-- both, v-if and v-bind:class are needed: v-if since some code would create an error when qualiMod is undefined and v-bind:class cannot simply be included in "class" to prevent that it pops up quickly when the page gets loaded.-->
            <div class="overlayContainer">
                <form>
                    <div class="verticalForm">
                        <h3><%= __("Change qualification state for") %> {{qualiMod.forename}} {{qualiMod.lastname}}: </h3>
                        <select class="content dropdown" v-model="newQState">
                            <option v-for="option in qualificationStates" v-bind:value="option.value">
                                <template v-if="option.abbreviation!=''">
                                    {{option.abbreviation}}: {{option.text}}
                                </template>
                                <template v-else>
                                    {{option.text}}
                                </template>
                            </option>
                        </select>
                        <br>
                        <button type="button" class="btn btnGreen marginRight" v-on:click="saveQualificationMod">
                            <%= __("Change") %>
                        </button>
                        <button type="button" class="btn btnRed" v-on:click="overlay = undefined"><%= __("Abort") %></button>
                    </div>
                </form>
            </div>
        </div>

        <div class="overlay" v-bind:class="{shown: overlay=='qualificationSetup'}">
            <div class="overlayContainer" v-if="overlay=='qualificationSetup'"> <!-- the v-if is needed, since the properties in the modules are not present yet before mounted, which would lead to an error -->
                <!-- TODO: change this from seriesAssignment module to qualificaiton module -->
                <form onsubmit="return false">
                    <!-- if there are multiple assignment algorithms, show a dropdown to select-->
                    <div v-if="qualificationModulesFiltered.length>1">
                        <%= __("Qualification Module") %>: <!-- for track it is called heat --> 
                        <!-- if there are multiple series assignment algorithms, show a dropdown to choose from -->
                        <select class="formCtrl" v-model.number="selectedQualificationModel">
                            <template v-for="(QM, index) in qualificationModulesFiltered">
                                <option v-bind:value="QM.nameDB">{{QM.name}}</option>
                            </template>
                        </select>
                    </div>
                    <!-- include the different qualification Modules configuration wizards -->
                    <% qualificationModules.forEach((QM)=>{ %>
                        <%- include(QM, {type:"html"}) %>
                    <% }); %>
                    <template v-if="QMvalidation.message!==''">
                        <div v-if="QMvalidation.error" class="invalid">
                            {{QMvalidation.message}}
                        </div>
                        <div v-else class="valid">
                            {{QMvalidation.message}}
                        </div>
                    </template>
                    <br>
                    <button type="submit" class="btn btnGreen marginRight" v-on:click="applyQualification" v-bind:disabled="!roundMod.roundFinished || QMvalidation.error"><%= __("Save and apply") %></button>
                    <button type="button" class="btn btnGreen marginRight" v-on:click="saveQualification()"><%= __("Save") %></button>
                    <button type="button" class="btn btnRed marginRight" v-on:click="overlay=undefined"><%= __("Abort") %></button>
                </form>
            </div>
        </div>
    
        <div id="overlay" v-on:click="infoVisible=false" v-bind:class="{shown: infoVisible}">
            <!-- overlay used for displaying general information -->
            <div id="overlayContainer">
                <div id="overlayTitle"><b>{{infoTitle}}</b></div>
                <div id="overlayContent">{{infoContent}}</div>
            </div>
        </div>
    
    </div>
    