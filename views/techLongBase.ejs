
<script src="/static/vuContestTechLong.js"></script>
<script type="module">
    // include stuff which is in a module; add it to window, so that it can be used 
    import {formatCountryRegion, disciplineFormatters, validatePerformance} from '/static/performanceProcessing.js';
    globalThis.formatCountryRegion = formatCountryRegion;
    globalThis.disciplineFormatters = disciplineFormatters;
    globalThis.validatePerformance = validatePerformance;

</script>
<script>

    // TODO: Series status: should we have a separate status for the final? If yes, how?
    // difficult question; probably not; otherwise, it would need to be stored to the contest instead of the series
    /** 
     * I see two options for the merged series:
     * 
     * (1) Create a regular extra series after the other parts are finished.
     * + The vue-part is mostly identical to the unmerged rounds (except e.g. for the attempt that is shwon or the rank (quali: rank within series, final: rank overall))
     * + has a regular status
     * - attempt stored in resultstech should not begin at 1 for the final series 
     * - ranking is more cumbersome, since it requires to merge qualification and final SSR first.
     * - How to handle disqualificaitons? If these are separate rounds and an athlete is disquaified in the final, he will not get disqualified in the qualification
     * - ==> more work in techLongBase to handle the special series
     * - eventually problematic in the uploads to the national servers, since there a unique reference to one series might be needed.
     * 
     * (2) The final series is just a virtual series to be shown to the user, but the results are regularly stored in the original series.
     * + no problems for upload to national bodies
     * + It should be rather simple to create an virtual series with the data needed for
     * + disqualification handled correctly automatically. 
     * - requires more changes in the Vue, especially with regard to series.status 
     * - series status does not exist and/or must be done via series.aux data. Eventually the dropdown in final stage should simply always change the status of all series.
     * 
     * ==> I actually think that (2) is better.
     **/

    // connect to the room (defined by te ID in the URL/http-GET-param)
    // class vuContestTest is imported above

    var rCTech;
    var rSites;
    var vueSeriesAdminTech; 

    class vuSites extends roomClientVue{
        
        constructor(vue, meetingShortname){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super('sites@' + meetingShortname, false, true, '/static/rSitesClient.js', 'rSitesClient', '')
    
            // needed to call things in the vue class
            this.vue = vue;
        }
    
        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }
    
        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            this.vue.sites = this.room.data.sites; // this will actually store a proxy of the data!
        }
        
        dataArrived(){
            // raised as soon as the room has its data stored for the first time
            this.vue.sites = this.room.data.sites;
    
        }
    }

    function startSeriesAdminTechRead(){
        // no writing right
        startSeriesAdminTechLong(false);
    }

    function startSeriesAdminTechLong(writing=true){

        /**
         * IMPORTANT NOTE: 
         * 1.) this room shall also work offline, i.e. all changes are written to a stack on the client which will be synchronized as soon as possible. However, this also needs that the changes are directly applied on the client, instead of applying them not before the answer of the server in "online-only" pages.
         * 2) If a change cannot be processed on the server, it has to be reverted on the client! This makes it necessary that the addToStack function is called with everything needed to perform a rollback of the change. This basically needs that the init-function in the room gets the new and old data. 
         **/

        // TODO: eventually move this into vue

        let vueAppConfig = {
            data(){
                return {

                    developMode:true,
                    //showContestInfo: false,
                    show:'none', // will automatically show most reasonable thing at startup
                    overlay: undefined, // either undefined or 'createSeries' or 'config'
                    overlay2: undefined, // createSeries or undefined
                    // there will be no waiting page, but a limit to one client and this will be the first offline working page.
                    burgerChecked: false, // burger menu activated

                    onSeriesChangeCalcNextAth: true,

                    // show a clock on some screens; 
                    // start an interval to update the time in "mounted", if the time is odd, show the ":" between minutes and hours 
                    timeHours:'00',
                    timeMinutes:'00',
                    timeSeconds:'00',
                    timeOdd: false,
                    timeInterval: null, // the function to stop the interval

                    // the data is split into three parts, to be able to reuse the seriesAdmin parts
                    // TODO: also split computed properties, watchers and methods!

                    /* !!! data for SERIES CREATION and COMPETITION !!! */
                    categories:[],
                    meeting:{},     // informational only
                    disciplines:[], // informational only, to be able to show the name of the discipline and get some conf-data about the discipline, such as the max-reasonable height used to create the limit until where the heights shall be created
                    // TODO

                    //activateLate: false, // thing that cannot be drawn at startup, e.g. because they rely 
                    readOnly: false, // whether we can do changes or not (have a writingTicket or not)
                    
                    // info overlay
                    infoTitle: '',
                    infoContent:'',
                    infoVisible:false,

                    // yesNo overlay
                    yesNoVisible:false,
                    yesNoText: '',
                    yesNoTitle: '',
                    yesNoFunction:()=>{},

                    contest:{ // to be overridden as soon as the room-data arrives
                        status: 10,
                    },
                    startgroups: [],
                    relatedGroups: [],
                    // IMPORTANT: the contest data must be equivalent to the data in techLong (which should be the case since this was based on the database structure)

                    // the names and id's of series and contest states:
                    // Note: the comment before the ejs-include only affects the first row of the included file; (thats why it still works)
                    // also gets seriesStates and participationStatesTech
                    //<%- include('contestStates.ejs') %>

                    numSeries:0,
                    //unassignedAthletes:[100,101, 102, 103],
                    unassignedAthletesCreate:[], // the array is manually populated when the initial series assignment is shown

                    series:[],
                    seriesObj:[], //{1:[15,16], 2:[17,18]},
                    sites : [],

                    /* !!! data for SERIES CREATION ONLY !!! */
                    confForMod: {}, // the conf-object that is modified during conf changes. Recreated everytime conf-change is opened. At the end, the changes are either stored back to to the JSON in contest.conf (which then is applied to the computed property conf) or we just do nothing. 

                    // series assignments (the different strategies that can be applied)
                    seriesAssignmentsAll: [
                    //includes<% seriesAssignments.forEach((SA)=>{ %>
                        // next include:<%- include(SA, {type:"js"}) %>,
                    //<% }); %>
                    ],
                    seriesAssignmentConfiguration:{}, // object will be populated by init functions of the respective functions
                    selectedSeriesAssignment: 0, // by default choose the first series assignment strategy

                    filterAthletes:'',
                    showFullDetails: false, // TODO: true for debugging only

                    /* !!! data for COMPETITION only !!! */
                    xResultTemp: -1, // temporary xResult (needed for identical element id's; it is not referenced somewhere)

                    selectedSeries: 0, // which series we are working on. 
                    selectedSeriesLazy: 0, // which series we were working on before
                    //allHeights:[], // contains all already fixed and all predicted heights; computed property as of 2022-06
                    mode: 0, // 0: before the data is ready for competition, 1= regular part of competition running (or is ready to be started), 2=selcted series is finished in regular part, awaiting other series to finish in regular part as well, 3=merged final, 4=finished
                    position:[], // array with the xStartgroup of all athletes starting in the current attempt, defining the order in the competition; changed by the drag and drop part;
                    positionNext: [], //ATTENTION: positionNext here is different from the one on techHigh! It stores the xSeriesStart of the next persons (in the current attempt only, it does not include the athletes in the next attempt)
                    // keep track of the next two persons; will also be stored to the auxData and transmitted to the other clients:
                    //ssrCurrent:null, 
                    //ssrNext: null, 
                    tempRankingData: { // all data needed for ranking and for gettign the current athlete
                        // structure see below at calculateTemporaryRankingData
                    },
                    currentAttempt: 0, 
                    /*attempt2: 0, // in normal mode==1: 1 to 3; 
                    attemptNext2: 0, // 1 to 3; for the next athlete (not the current). It is easier to store this value than to (re)calculate it for drawing.*/
                    
                    currentResultChange: {}, // the result that we are currently changing in the results view 1
                    currentResultString:'',
                    currentResultStringCopy:'',
                    currentWind:0, // in m/s
                    currentWindCopy:0, // in m/s
                    resultKeyPressed: -1, // the key that was pressed last inside a addResult-input. If this is the esc-key, the blur event will not be evaluated. 
                    sortValue1: 1, // default: default order
                    sortValue2: 2, // default by rank
                    fakeProperty:0, // just needed to make sure that the sortedStart's are updated when the ranks change. (Start Vue's updating process)
                    temporaryDeactivation: false, // just to deactivate parts of the html form being rendered temporarily
                    timeOffset: 0,
                    roomAuxData:{
                        // uses xSeries to reference objects storing the following information:
                        // positionNext:[],
                        // position:[],
                        // attemptPeriod: 60, // s
                        // periodStartTime: undefined, // date-string of the server time when the attempt period started
                        // showAttemptPeriod: false,
                        // TODO: techLong related stuff
                        // attempt
                        // attemptNext 
                    },
                    autoAdvance: false,
                    attemptTime: "1:00", // TODO: aventually as time instead of string
                    attemptTimeSetting: "01:00",
                    shownTime: "0:00", // shall be string
                    timeUpdateInterval: undefined,
                    last15: false, // last 15 s
                    //currentResultRegistered: false,

                    competitionDistance: '',
                    competitionWind: null,

                    ssrMod:undefined, // store the xStartgroup that shall be modified in an overlay
                    resultOverruleMod: 0, 

                    // late registration props
                    athleteModID:-1,
                    newAthleteCategory:null,
                    newAthleteClub:null,
                    newAthleteForename:'',
                    newAthleteLastname:'',
                    newAthleteBirthdate:null,
                    newAthleteSex:null,
                    newAthleteRegion:null,
                    regions:null, // TODO

                    baseModuleNames:null, // TODO
                    baseSearchString:null,
                    baseEntriesNum:null,
                    baseEntries:null,

                    previousStatus: 0, 
                    touchTimeout: null,

                    leftWithTab: 0, // is set to +1 (advance) or -1 (return, shift+tab) on some elements, before they lose focus due to a tabkey event 
                    remarkBefore:'',
                }
            },
            methods:{

                /* !!! methods for both SERIES creation and COMPETITION !!! */
                statusFocus(){
                    this.previousStatus = this.contest.status;
                },
                statusChanged(event){

                    // write the change to the room
                    let newStatus = Number(event.target.value);
                    rCTech.room.updateContest2Init('status', newStatus, this.previousStatus); 
                    this.previousStatus = newStatus; 

                    // check whether the current "show" property is meaningful; if not, automatically set a meaningful property
                    const matchStatusShow = [
                        {from: 0, to:39, shows:['rollCall', 'contestInfo']},
                        {from: 60, to:89, shows:['series', 'contestInfo']},
                        {from: 95, to:180, shows:['competition', 'order', 'resMod', 'resShow', 'settings', 'contestInfo']},
                    ]; 
                    const range = matchStatusShow.find(el=>el.from<=this.contest.status && el.to>=this.contest.status);
                    // check if the current selected show makes sense
                    if (range && range.shows.indexOf(this.show)==-1){
                        this.showAuto();
                    }
                },
                showAuto(){
                    // automatically show the most meaningful page (and results sorting) when the selected status is changed
                    if (this.contest.status<=39){
                        this.show='rollCall';
                    } else if (this.contest.status<=89 && this.contest.status>=60){
                        this.show = 'series';
                    } else if (this.contest.status<=180 && this.contest.status>=95){
                        this.show = 'competition';
                        this.sortValue2 = 2;
                    } else if (this.contest.status>180){
                        this.show = 'resShow';
                        this.sortValue2 = 2;
                    }
                },

                statusBackgroundColor(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.backgroundColor;
                    }
                    return '#333333';
                },
                colorHexMultiplier(color, f){
                    // split the hex code into the three parts and multiply it with f
                    let R = Math.min(255,Math.round(f*parseInt(color.slice(1,3),16)));
                    let G = Math.min(255,Math.round(f*parseInt(color.slice(3,5),16)));
                    let B = Math.min(255,Math.round(f*parseInt(color.slice(5,7),16)));
                    return '#' + R.toString(16).padStart(2,0) + G.toString(16).padStart(2,0) + B.toString(16).padStart(2,0);
                },
                statusBackgroundColorHover(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return this.colorHexMultiplier(s.backgroundColor)
                        // split the hex code into the three parts and multiply it with 0.8
                        /*let f = 0.8;
                        let R = Math.round(f*parseInt(s.backgroundColor.slice(1,3),16));
                        let G = Math.round(f*parseInt(s.backgroundColor.slice(3,5),16));
                        let B = Math.round(f*parseInt(s.backgroundColor.slice(5,7),16));
                        return '#' + R.toString(16).padStart(2,0) + G.toString(16).padStart(2,0) + B.toString(16).padStart(2,0);*/
                    }
                    return '#111111';
                },
                statusTextColor(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.textColor;
                    }
                    return status;
                },
                statusText(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.text;
                    }
                    return status;
                },


                selectedSeriesChanged(){

                    let u = new URL(window.location.href)
                    u.searchParams.set('xSeries', this.series[this.selectedSeries].xSeries);
                    // this would reload the page
                    // window.location.href = u.href;
                    // this way only the path in the tab should be changed without any reload. 
                    window.history.replaceState(window.history.state, "", u.href)
                    
                },

                /**
                 * returns the index and the object itself of the first object where the property prop is equal to value 
                 * @param {array of objects} arr 
                 * @param {string} prop 
                 * @param {*} val 
                 * @return {array} [index, the object]
                 */
                findObjInArrayByProp(arr, prop, val){
                    for (let i=0; i<arr.length;i++){
                        if (arr[i][prop] == val){
                            return [i, arr[i]];
                        }
                    }
                    return [-1, {}];
                },
                autoManageAuxData(autoSaveToServer=true){

                    // this should all be done now (2022-06) in the room! It is wrong to do this in the view!

                    /*// based on the available series, automatically create (with default values) and delete the auxData per series.
                    // returns true if something has changed (so far 2022-06 not needed)

                    let changed = false;

                    // first make sure, that all currently available auxData have their respective series; otherwise delete them
                    for (let xSeries in this.roomAuxData){
                        let series = this.series.find(s=>s.xSeries==xSeries);
                        if (!series){
                            delete this.roomAuxData[xSeries];
                            changed=true;
                        }
                    }

                    // then check that all available series have also an entry in auxData
                    for (let series of this.series){
                        if (!(series.xSeries in this.roomAuxData)){
                            this.roomAuxData[series.xSeries] = {
                                positionNext:[],
                                position:[],
                                attemptPeriod: 60, // s; mainly related to the next athlete
                                periodStartTime: null, // date-string of the server time when the attempt period started
                                showAttemptPeriod: false, 
                                currentHeight: -1,
                                currentJumpoffHeightInd: -1,
                                attempt: 0,
                                attemptNext: 0,
                            };
                            changed = true;
                        }
                    }
                    
                    if (changed && autoSaveToServer && !this.readOnly){
                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                    return changed;*/
                },
                overlayInfo(title, content){
                    this.infoTitle = title;
                    this.infoContent = content;
                    this.infoVisible = true;
                },
                sortSeries(){
                    //this.series.sort((s1, s2)=>s1.number-s2.number);
                },

                /* !!! methods for SERIES creation only !!! */


                dragEnded(evt){
                    // TODO implement here all the logic to derive the changes on athletes (in the version where the changes are propagated live.)
                    console.log(`from ${evt.from.id} to ${evt.to.id}`);
                },
                unassignedAthleteChanged(evt){
                    // override the default behavior (add/remove to/from 'displayData' within v-table, which does not work) and add/remove the element instead to/from 'unassignedAthletesCreate'
                    console.log('drag changed');
                    if ('removed' in evt){
                        // remove the element from 'unassignedAthletesCreate'
                        var i = this.unassignedAthletesCreate.indexOf(evt.removed.element);
                        if (i!=-1){
                            // should always come here; remove the element
                            this.unassignedAthletesCreate.splice(i,1);
                        }

                    } else if ('added' in evt){
                        // add the element to 'unassignedAthletesCreate'
                        this.unassignedAthletesCreate.push(evt.added.element)
                    }
                },
                seriesChanged(evt){
                    // TODO: implement reordering of series here
                    let test
                },
                seriesStateChanged(evt){
                    // not needed for series assignment
                },
                presentChanged(affectedRow){
                    // the present status of an athlete was changed. Hand over the request to the room. 
                    rCTech.room.updatePresentStateInit(affectedRow);
                },
                startUpdateConf(){
                    this.confForMod = this.parseConf(this.contest.conf);
                    this.overlay = 'config';
                },
                abortUpdateConf(){
                    this.overlay = undefined;
                },
                saveUpdateConf(){
                    this.overlay = undefined;
                    this.confForMod.preset = Number(this.confForMod.preset);
                    rCTech.room.updateContest2Init('conf', JSON.stringify(this.confForMod), this.contest.conf); 
                },

                parseConf(jason){
                    // a valid JSON must contain {} or []; an empty string, as it might occur in the DB as a default, is not valid!
                    let conf;
                    try{
                        conf = JSON.parse(jason);
                    }catch(ex){
                        conf = {};
                    }
                    // make sure conf has an array called attemptSettings
                    if (!('attemptSettings' in conf)){
                        conf.attemptSettings = [];
                    }
                    return conf;
                },
                getCategory(xCategory, property='shortname'){
                    let cat = this.categories.find(c=>c.xCategory==xCategory)
                    if (cat){
                        return  cat[property]
                    } else {
                        return '';
                    }
                },
                getYearShort: function(dateString){
                    let d = new Date(dateString);
                    return d.getFullYear().toString().slice(-2);
                },
                endRollCallCreateSeries(){
                    rCTech.room.updateContest2Init('status', 70, this.contest.status); 
                    this.show="series";
                    if(this.series.length==0){
                        this.showInitialSeriesAssignment();
                    }
                },
                formatDistance(valueInDB, showUnit=true){
                    return window.disciplineFormatters[2](valueInDB, this.discipline, showUnit);
                },
                formatTime(time, dateIfNeeded=true, secondsIfNeeded=true){
                    // return a formatted time value.
                    // if dateFrom=dateTo, only return the time; otherwise include the portion of date needed.
                    // if seconds are given, include them
                    let s = '';
                    let d = new Date(time);
                    if (dateIfNeeded && this.meeting.dateFrom != this.meeting.dateTo){
                        s += (d.getMonth()+1).toString().padStart(2,0);
                        s += "." + d.getDate().toString().padStart(2,0) + ' ';
                    }
                    s += `${d.getHours()}`.padStart(2, '0');
                    s += ":" + `${d.getMinutes()}`.padStart(2,'0');
                    if (secondsIfNeeded && d.getSeconds() != 0){
                        s += ':' + `${d.getSeconds()}`.padStart(2,'0');
                    }

                    return s;

                },
                showInitialSeriesAssignment: function(){
                    // create a list of all unassigned athletes for the initial series assignment. This is a separate list from the unassignedAthletes for the base configuration
                    this.resetInitialSeriesAssignment()
                    
                    this.overlay2 = 'createSeries';
                },
                addEmptySeriesInitial: function(){
                    // add an empty series to the seriesObj used in the inital series configuration tool
                    this.seriesObj.push({
                        number:this.seriesObj.length+1, 
                        xSite: null, 
                        status: 10, 
                        name:'', 
                        startsingroup:[],
                        datetime: this.contest.datetimeStart,
                    });
                },
                resetInitialSeriesAssignment: function(){
                    // recreate the set of unassigned athletes (=all startingroup where present=true): 
                    this.unassignedAthletesCreate = this.startgroups.filter(el=>el.present);

                    // delete all current series:
                    this.seriesObj = [];
                },
                createSeriesAutomatically: function(){
                    // first, reset current series
                    this.resetInitialSeriesAssignment();

                    // use selected algorithm to do automatic assignment
                    this.seriesAssignments[this.selectedSeriesAssignment].assignFunc.bind(this)()

                    // hide the overlay
                    this.overlay=undefined;
                    
                    // activate the ok button
                    this.$refs["saveInitSeries"].focus();
                },
                saveInitSeries: function(){
                    // save the initial series assignment
                    
                    // TODO: manually populate the actual series object; as soon as the change is processed on the server, the IDs will be replaced here with the actual IDs. 
                    // DIFFICULTY: Assume a client without connection, a series is (locally) generated, then it is deleted again. As soon as we have connection, the changes are sent to the server. However, the answer for the series creation cannot be processed completely, because the series was deleted meanwhile in the local data. HOW CAN THIS PROBLEM BE SOLVED?:
                    // IDEA 1: fail-safe programming. If an object does not exist anymore, simply do not care and just continue. This only works when we do not try to know, what element must be updated on data arrival via e.g. the series number, when we have a unique identifier, e.g. a temporary ID or we have function where the objects are referenced (not the position in the array or the array itself!)
                    
                    // The series structure should look like this
                    // series : all series objects
                    // series[0].heights : the heights jumped in this series
                    // series[0].seriesstartsresults : all athletes in this series
                    // series[0].seriesstartsresults[0].resultshigh : the results of the athletes

                    // do all the data managament in the room and not within vue!
                    rCTech.room.initialSeriesCreationInit(this.seriesObj);

                    this.overlay2 = undefined;

                    return false; // avoid reload of the page

                },
                deleteSeries(xSeries){
                    rCTech.room.deleteSeriesInit(xSeries);
                    this.yesNoVisible = false;
                    //this.showTimeUpdate();
                },
                initDeleteSeries(series){
                    this.yesNoTitle = '<%= __("Delete series") %>';
                    this.yesNoText = `<%= __("Do you want to delete series ${series.number}?") %>`;
                    this.yesNoFunction = ()=>{
                        this.deleteSeries(series.xSeries);
                    }
                    this.yesNoVisible = true;
                },
                addSeries: function(){
                    // add an empty series
                    let xSite = null
                    if (this.defaultSite){
                        xSite = this.defaultSite.xSite;
                    }
                    // add an empty series
                    rCTech.room.addSeriesInit(xSite, this.contest.datetimeStart);
                },
                deleteAllSeriesInit(){
                    // show warning
                    this.yesNoVisible = true,
                    this.yesNoText = '<%= __("Delete all series") %>';
                    this.yesNoTitle = `<%= __("Do you really want to delete all series? This can't be undone.") %>`;
                    this.yesNoFunction = this.deleteAllSeries;
                    
                },
                deleteAllSeries(){
                    this.yesNoVisible=false;
                    // the room functiuon will also change the local data
                    rCTech.room.deleteAllSeriesInit();
                },
                moveSeries: function(evt){
                    // called, when series are reordered
                    // no differentiation needed between moved/added/removed, since only move is possible; 

                    // Note: evt.moved.element is NOT the series-element in data.series, since we work on a copy seriesAsStartgroups
                    rCTech.room.moveSeriesInit(evt.moved.oldIndex, evt.moved.newIndex)

                },
                removeSSR: function(evt){
                    if ("added" in evt){
                        rCTech.room.deleteSSR(evt.added.element.seriesOriginal, evt.added.element.ssrOriginal)
                    }
                    // nothing to do when removed or moved; removed is handled in the add event of the series and moving within the unassignedAthletes is useless, since it is done via the sortable table.
                },
                changePosition: function(series, evt){
                    // this function is responsible for:
                    // - moving athletes within series
                    // - moving athletes beyond series
                    // - newly assign athletes to a series
                    // --> unassign athgletes is handled in "removeSSR"! 

                    // if an athlete is moved from one series to another, the function is called in both series, once with "removed" and once with "added" as the argument; if it is within the same series, then with "moved"
                    // evt .element .newIndex .oldIndex

                    if ("removed" in evt){
                        // if we do the work in added, we  do not need to do anything in removed, since the data will already be gone.
                        // the opposite way around is not possible, since it would not be known where to move the element to.
                    } else if ("added" in evt){

                        // differentiate whether the element is a seriesstartsresult or an xStartgroup (i.e. unassignedAthlete)
                        if ("athleteName" in evt.added.element){
                            // previously was an unassigned athlete
                            // create seriesstartsresults
                            rCTech.room.addSSR(series.seriesOriginal, evt.added.element.xStartgroup, evt.added.newIndex);
                        } else {
                            // athlete moved from one series to another; data is a seriesstartsresults entry
                            // hand over all needed references to the original, referenced objects. Make sure the room stays independent from the copied series structure within 
                            // let the room do the rest
                            rCTech.room.changePositionInit(evt.added.element.ssrOriginal, evt.added.element.seriesOriginal, series.seriesOriginal, evt.added.newIndex);
                        }


                    } else if ("moved" in evt){
                        // hand over all needed references to the original, referenced objects. Make sure the room stays independent from the copied series structure within 
                        // let the room do the rest
                        rCTech.room.changePositionInit(evt.moved.element.ssrOriginal, evt.moved.element.seriesOriginal, series.seriesOriginal, evt.moved.newIndex);
                    }
                    
                },

                /* !!! methods for COMPETITION only !!! */

                transferAuxData(){
                    // manually transfer some of the aux properties (position and positionNext are transferred in calculateNextAthlete)
                    // this is needed when the positionNext and position do not change (when a change arrives on reading clients), because normally those properties are transferred there
                    /*this.currentHeight2 = this.roomAuxDataSelected.currentHeight;
                    this.currentJumpoffHeightInd2 = this.roomAuxDataSelected.currentJumpoffHeightInd;
                    this.attempt2 = this.roomAuxDataSelected.attempt;
                    this.attemptNext2 = this.roomAuxDataSelected.attemptNext;*/

                },

                setTime(){
                    // set the time for the attempt period and show it

                    // split the time between hours (here: minutes) and minutes (here: seconds)
                    let t = this.attemptTimeSetting.split(':');
                    let minutes = Number(t[0])
                    let seconds = Number(t[1])
                    if (isNaN(minutes) || isNaN(seconds)){
                        alert('Time is not valid')
                    } else {
                        this.roomAuxDataSelected.attemptPeriod = minutes*60+seconds;

                        this.roomAuxDataSelected.showAttemptPeriod = true;
                        this.roomAuxDataSelected.periodStartTime = null;

                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                    this.updateShownTime();

                },
                birthdayToXX(bd){
                // convert the birthday to a two letter year code
                    return bd.substr(2,2);
                },
                getStartByXSeriesStart(xSeriesStart){
                    //return this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart == xSeriesStart)
                    // TODO: revert this, since it is only for debugging
                    let x = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart == xSeriesStart)
                    if (!x){
                        alert('could not find the athlete!');
                        // return some empty properties; because there is a short moment where the change of the series is only "halfway" processed, e.g. the value in the model is already changed, but the "calculateNextAthlete" is not yet called

                        // TODO: this is NOT a solution, since the returned object is also used to reference xStartgroup, which will fail with this default, non.existing value 
                        return {
                            xSeriesStart: xSeriesStart,
                            xStartgroup: -1,
                            xSeries: -1,
                            position: -1,
                            resultOverrule: 0,
                            resultRemark:'',
                            qualification: 0,
                            startConf: '',
                            resultshigh:[],
                        }

                    }
                    return x; 
                },
                meterStr(cm){
                    // translate cm to m-string with two decimal points; without unit!
                    let m = cm/100; 
                    return m.toFixed(2);
                },
                sortAthletes(seriesIndex){
                    /* this must be the only sort function run on the seriesstartsresults! They need to keep this order all the time. */
                    this.series[seriesIndex].seriesstartsresults.sort((el1, el2)=>{
                        return el1.position-el2.position;
                    })
                },
                sortAthletesAllSeries(){
                    for (i=0;i<this.series.length;i++){
                        this.sortAthletes(i);
                    }
                },
                replaceXResult(xSeriesStart, oldKey, newKey){
                    alert('TODO')

                    // replace the old key by the new key
                    // TODO

                    // if the result is currently changed, we need to change the key of the input element there, as it will be invalid afterwards otherwise
                    let el = document.getElementById('resChange' + oldKey)
                    if (el){
                        el.id = 'resChange' + newKey;
                    }
                },
                focusRemark(ssr){
                    this.remarkBefore = ssr.resultRemark;
                },
                blurRemark(ssr){
                    if (ssr.resultRemark != this.remarkBefore){
                        // send the change to the server
                        rCTech.room.updateSSRInit(ssr);
                    }
                },
                startUpdateParticipation(ssr){
                    this.ssrMod = ssr;
                    this.resultOverruleMod = ssr.resultOverrule;
                    this.overlay = 'modParticipation';
                },
                saveUpdateParticipation(){
                    // save the changed participation state to the local object and send the change to the server
                    this.ssrMod.resultOverrule = this.resultOverruleMod;
                    this.updateSSR(this.ssrMod);

                    this.ssrMod = undefined;
                    this.calculateNextAthlete();
                    this.overlay = undefined;
                },
                confSelect3plus3(){
                    this.confForMod.attempts = 6;
                    this.confForMod.mergeSeries = 4;
                    this.confForMod.attemptSettings = [
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:0},
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:1},
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:2},
                        {sort: 3, sortRankAfterAttempt:3, filterRank:8, filterAttempt:3},
                        {sort: 3, sortRankAfterAttempt:3, filterRank:8, filterAttempt:3},
                        {sort: 3, sortRankAfterAttempt:3, filterRank:8, filterAttempt:3},
                    ];
                },
                confSelectContinuous(){
                    this.confForMod.attempts = 6;
                    this.confForMod.mergeSeries = 4;
                    this.confForMod.attemptSettings = [
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:0},
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:1},
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:2},
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:3},
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:3},
                        {sort: 0, sortRankAfterAttempt:1, filterRank:0, filterAttempt:3},
                    ];
                },
                confAttemptsChange(event){
                    const oldVal = this.confForMod.attempts;
                    const newVal = Number(event.target.value);
                    this.confForMod.attempts = newVal;
                    
                    if (oldVal<newVal){
                        // duplicate the last entry in attemptSettings
                        this.confForMod.attemptSettings.push(this.confForMod.attemptSettings[this.confForMod.attemptSettings.length-1]);
                    } else {
                        // remove the last element.
                        this.confForMod.attemptSettings.pop();
                    }

                },
                confSortChange(attemptSetting, i, $event){
                    const oldVal = attemptSetting.sort;
                    const newVal = Number(event.target.value);
                    attemptSetting.sort = newVal;
                    // on change from position to rank, set a typical (3) and possible (number of attempts in total and current number of attempt) rank
                    if (oldVal<2 && newVal>1){
                        attemptSetting.sortRankAfterAttempt = Math.min(i-1, 3, this.confForMod.attempts);
                    }
                },
                calculateTemporaryRankingData(){
                    // calculate all data needed for ranking and to find out, who is next
                    // this is done independently of the current mode
                    // special "results": -1: no perf yet, -2: failed (X)
                    // in contrast to techHigh, this is done for all series and there is an additional averall ranking as well
                    /*                             
                    array of objects for each series; if required, the fake series for the merged final as well
                        12:{ // identified by ssr
                            bestPerfOverall:
                            bestPerfUntil: [4.55, 4.76, 4.76, 4.76, 4.88, 4.88], // until (and including) each attempt; can only increase
                            perf: [4.55, 4.67, -2, 4.35, 4.88, -1], // could be received from data actual data too, but eventually it makes sense to have it here as well
                            perfSorted: [4.88, 4.67, 4.55, 4.35, -1, -2], // also include -1 and -2 to be able to compare/sort/rank
                            rankUntil: [4,3,4,5,2,0], // ranks are added for all attempts (even if no result yet in this attempt; rank=0 if there is no valid result yet
                            nextAttempt:,
                        },
                    */

                    // go through every result of every athlete;
                    // make sure that series is sorted!
                    this.series.sort((a,b)=>a.number-b.number);

                    // reset rankingdata
                    this.tempRankingData = []; // array, where each element is an object per series
                    
                    let l = this.conf.attempts;

                    for (let s of this.series){

                        const trd = {};

                        s.seriesstartsresults.forEach((start)=>{

                            let r = {
                                bestPerfOverall:0,
                                bestPerfUntil: (new Array(l)).fill(-1),
                                perf: (new Array(l)).fill(-1), 
                                perfSorted: (new Array(l)).fill(-1), 
                                rankUntil: (new Array(l)).fill(-1), 
                                nextAttempt:1, //set to 0 if finished; ev required during the last attempt and when a person is disqualified.
                                resultOverrule: start.resultOverrule,
                            }
                            trd[start.xSeriesStart] = r;

                            // for each attempt, try to get the result
                            for (let n=1; n<=l; n++){
                                const rt = start.resultstech.find(rt=>rt.attempt==n);
                                if (rt){
                                    if (rt.result==null){
                                        r.perf[n-1] = -2; // X or -
                                    } else {
                                        r.perf[n-1] = rt.result;
                                        r.bestPerfOverall = Math.max(r.bestPerfOverall, rt.result);
                                    }
                                    r.bestPerfUntil[n-1] = Math.max(...r.perf.slice(0,n))
                                    
                                } // nothing to do when the result does not exist yet (-1 is already in the array)

                            }

                            r.perfSorted = r.perf.toSorted().reverse(); // best first
                            
                            // resultOverrule is >0 (i.e. DNS, DQ, retired) then the athlete is 'finished' (nextAttempt=0); it is also finished, when all attempts are through
                            if (start.resultOverrule>0 || l==start.resultstech.length){
                                r.nextAttempt = 0
                            } else {
                                // find the index of the first element in r.perf that is -1
                                r.nextAttempt = r.perf.findIndex(el=>el==-1)+1; // is automatically 0=finished when no index was found.
                            }

                        })

                        this.tempRankingData.push(trd); // add the tempRankingData for this result
                    }

                    // create another fake trd with all elements to have an overall ranking.
                    const totalTrd = this.tempRankingData.reduce((tt, trd)=>{
                        for (let [key, value] of Object.entries(trd)){
                            tt[key] = value;
                        };
                        return tt;
                    }, {})
                    this.tempRankingData.push(totalTrd);

                    // create a function that compares two results arrays, only considering n attempts;
                    const compareCreator = (n, iSeries)=>{
                        const compare = (aSSR,bSSR)=>{

                            const a = this.tempRankingData[iSeries][aSSR.xSeriesStart];
                            const b = this.tempRankingData[iSeries][bSSR.xSeriesStart];

                            if (Math.max(aSSR.resultOverrule,1) !=  Math.max(bSSR.resultOverrule,1)){ // regular (0) and retired (1) must be treated the same
                                return aSSR.resultOverrule - bSSR.resultOverrule; // this should meansingfully sort also within resultOverrule
                            }

                            if (aSSR.resultOverrule<2){
                                // is a regular result, not overrule
                                for (let i=0; i<n; i++){
                                    if (a.perfSorted[i] != b.perfSorted[i]){
                                        return - (a.perf[i] - b.perf[i]);
                                    } 
                                }
                            }

                            return 0;

                        }
                        return  compare;
                    }

                    // do the ranking (define rankUntil) for all series
                    for (let is=0; is<=this.series.length; is++){

                        let starts;
                        if (is==this.series.length){
                            // this is the total series; ssrs need to be merged over all series
                            starts = this.series.reduce((t, v)=>{
                                t.push(...v.seriesstartsresults);
                                return t;
                            }, []);
                        } else {
                            starts = this.series[is].seriesstartsresults;
                        }
                        const sTrd = this.tempRankingData[is];

                        // for each attempt
                        for (let n=1; n<=l; n++){
                            const compFunc = compareCreator(n, is);
                            // sort a copy of sTrd
                            const sortedStarts = starts.slice().sort(compFunc);

                            // after sorting, loop over all elements and set the rank based on the current index (if worse than previous element) or the last used index (if equal to last element). Use the compare function again for this
                            let lastRank = 0;
                            for (let i=0; i<sortedStarts.length; i++){
                                let rank;
                                const start = sortedStarts[i];
                                if (this.tempRankingData[this.selectedSeries][start.xSeriesStart].bestPerfOverall<=0){
                                    rank = 0;
                                } else if (i==0){
                                    if (start.resultOverrule<2){
                                        rank = i+1;
                                    } else {
                                        rank = 0;
                                    }
                                    lastRank = rank;
                                } else {
                                    // compare with previous start; if identical, get the same rank
                                    const startBefore = sortedStarts[i-1];
                                    // compare the current and the previous element; if they are the same, assign the lastRank, otehrwise the one based on i
                                    if (compFunc(start, startBefore)==0){
                                        rank = lastRank;
                                    } else {
                                        rank = i+1;
                                        lastRank = rank;
                                    }
                                }
                                
                                sTrd[start.xSeriesStart].rankUntil[n-1] = rank;
                            }

                        }
                    }

                },
                calculateNextAthlete(){

                    // always only refers to the selected series, and not all series! (In contrast to calculateTemporaryRankingData)
                    let series;
                    if (this.selectedSeries<this.series.length){
                        series = this.series[this.selectedSeries];
                    } else {
                        // the special series for the merged final is selected; create a virtual series object with xSeries = 'merged' and all seriesstartsresults from all series
                        series = {
                            xSeries: 'merged'
                        }
                        series.seriesstartsresults = this.series.reduce((total, value)=>{
                            return total.push(...value.seriesstartsresults)
                        }, [])
                    }

                    // if the selectedSeries changes, we must reset position and positionNext to make sure the algorithm trying to alter the position array as little as possible when athletes are added or removed works as it should. 
                    if (this.selectedSeries != this.selectedSeriesLazy) {
                        if (this.series.length>0){
                            const xSeries = series.xSeries;
                            this.position = this.roomAuxData[xSeries].position; 
                            this.positionNext = this.roomAuxData[xSeries].positionNext;
                        } else {
                            this.position = []; 
                            this.positionNext = [];
                        }
                    }

                    // if the series is empty or no series exists yet (or the pre-"selected" series does not exist), do not start the subsequent calculation!
                    if (!series || series.seriesstartsresults.length==0){
                        this.mode=0;
                        return
                    }

                    this.calculateTemporaryRankingData();

                    // change the mode to regular if it was 0 before
                    if (this.mode==0){
                        this.mode=1;
                    }

                    // calculate the next attempt and then recreate/update the position array, if a new attempt is next.
                    // next attempt must be calculated for all series to find out whether we are in mode 1 (regular) or mode 2 (merged final)
                    let nextAttempts = Array(this.tempRankingData.length).fill(this.conf.attempts+1); // plus 1 to differentiate "all finished" and "in the last attempt"
                    for (let i=0; i<this.tempRankingData.length; i++){
                        Object.values(this.tempRankingData[i]).forEach(trd=>{
                            if (trd.nextAttempt>0 && trd.nextAttempt<nextAttempts[i]){
                                nextAttempts[i] = trd.nextAttempt;
                            }
                        })
                    }

                    // if there is a merged final and all series are past the regular part, change to final (mode 2)
                    if (this.mergeSeries>0){ // this.mergeSeries is only>0 if series.length>1
                        if (nextAttempts.slice(0, this.series.length).every(el=>el>=this.mergeSeries)){
                            // at least in final mode or finished
                            if (nextAttempts[this.series.length]>this.conf.attempts){
                                this.mode = 4; // finished
                            } else {
                                // merged final mode
                                this.mode = 3;
                            }
                        } else {
                            // check if selected series is still ongoing
                            if (nextAttempts[this.selectedSeries]>this.mergeSeries){
                                this.mode = 2; // finished, awaiting other series to finish
                            } else {
                                // regular mode
                                this.mode = 1;
                            }
                        }
                        
                    } else {
                        // no merging needed
                        if (nextAttempts.slice(0, this.series.length).every(el=>el>=this.conf.attempts)){
                            this.mode = 4; // all series are finished
                        } else if(nextAttempts[this.selectedSeries]>this.conf.attempts) {
                            this.mode = 2; // current series finished, other still ongoing
                        } else {
                            this.mode = 1; // current series still ongoing
                        }
                    }


                    if (this.mode==4 || this.mode==2){
                        // currently nothing to change for positions
                        this.position = [];
                        this.positionNext = [];
                        return;
                    }

                    let nextAttempt = nextAttempts[this.selectedSeries];

                    // if the attempt will increase by 1, we (might) need to update position and positionNext; 
                    // the positions only change, when
                    // - mergedSeries begins
                    // - filter (filterRank, filterAttempt) or sort (sort, sortRankAfterAttempt) change from the previous to the current attempt 

                    // (When) are we able to make sure that manual changes are kept?
                    // - whenever sort changes, we cannot / do not keep any previous manual changes but simply create the new order
                    // - when we switch to mergedSeries, also sort will change and a new order is needed anyway
                    // - when filter gets more strict (filterRankNew <(=*) filterRankBefore and filterAttemptNew >= filterAttemptBefore), (but no switch to mergedSeries and no sort change), we basically can/could simply delete the atheletes that are not in the competition anymore. 
                    //    * could be <=, but when equal, it does not have any effect
                    // => since the only case where changing the position array instead of recreating it is extremely rare, we always recreate the array, if anything (sort or filter) changes from one to the next attempt. 

                    // -------------
                    // IMPORTANT:
                    // => generally, simply recreate the position array except for the rare case mentioned above, where only deleting is needed. 
                    // nevertheless, we also need to take care of cases where athletes get deleted or added (byparticipation state change) => how to handle this? Eventually see the code from techHigh
                    // -------------

                    // I think the position array should always contain all xStartgroup in the current attempt, and not delete those that are finished already

                    // if the last person in a certain attempt is competing, we know the next person only if neither sort nor filter changes 

                    // calculate the new position array; however, do NOT directly store them to this, but do this copy at the end, based on whether this client is writing or not!

                    const currentStarts = ()=>{
                        // returns an array with all ssr jumping in the selected series in the current attempt.
                        const setting = this.conf.attemptSettings[nextAttempt-1]; // -1 due to 0-based vs 1-based

                        // always filter the persons with participatinStatus==0
                        const ssrs = series.seriesstartsresults.filter(ssr=>ssr.resultOverrule==0)
                        if (setting.filterRank==0){
                            // all ssr
                            return ssrs;
                        } else {
                            return ssrs.filter(el=> this.tempRankingData[this.selectedSeries][el.xSeriesStart].rankUntil[setting.filterAttempt-1]<=setting.filterRank);// -1 due to 0-based vs 1-based
                        }
                    }
                    const sortStarts = (ssrs)=>{
                        // sort the array of ssr based on the setting for the current attempt
                        // sorts in place, but returns the value to allow for chaining
                        const setting = this.conf.attemptSettings[nextAttempt-1]; // -1 due to 0-based vs 1-based
                        ssrs.sort((a,b)=>{
                            if (setting.sort<=1){
                                // by position (0=regular, 1=reversed)
                                return a.position-b.position;
                            } else {
                                // by rank after sortRankAfterAttempt attempts, (2=best first, 3=best last)
                                // if rank are equal, use position; this is simply to make sure that always the same order results
                                return this.tempRankingData[this.selectedSeries][a.xSeriesStart].rankUntil[setting.sortRankAfterAttempt-1] - this.tempRankingData[this.selectedSeries][b.xSeriesStart].rankUntil[setting.sortRankAfterAttempt-1]; // -1 due to 0-based vs 1-based
                            } 
                        })
                        if (setting.sort==1 || setting.sort==3){
                            // reversed, comapred to the sorting above
                            ssrs.reverse();
                        }
                        return ssrs;
                    }

                    let position=[];
                    if (nextAttempt != this.currentAttempt && compareObject(this.conf.attemptSettings[nextAttempt], this.conf.attemptSettings[this.currentAttempt])==false){
                        // the attempt has changed and the attempt configuration is not the same => always simply recreate the position array.

                        position = sortStarts(currentStarts()).map(el=>el.xSeriesStart);

                    } else {
                        // update the position array, without recreating it in order not to lose the current changes to it. 
                        // check for every athlete that has (had*) the right to jump in this attempt whether he is in the position array or not. finally delete all those entries that should not be present
                        // * includes also all persons that already jumped in the current attempt
                        // NOTE: this funtionality is important e.g. when the participation status changes

                        // list of current positions; ssrs that shall still be in it get removed and at the end only those to be deleted remain.
                        let posCopy = this.position.slice(); 

                        // start with the current position array
                        position = this.position.slice();

                        // make sure all currentStarts exist in position; if not, add them at the ideal position
                        currentStarts().forEach(el=>{
                                
                            let ind = this.position.findIndex(el2=>el2==el.xSeriesStart)
                            if (ind == -1){
                                // start must be added on the best position!
                                // first create an array with the default positions of the athletes in the current positions-list
                                let positionDefault = Array(this.position.length);
                                for (let i=0;i<this.position.length;i++){
                                    let start = series.seriesstartsresults.find(el=>el.xSeriesStart==this.position[i])
                                    if (!start){
                                        alert('Error: Something went terribly wrong.');
                                    }
                                    positionDefault[i] = start.position;
                                }

                                // go through the possible positions (number of positions: position.length+1)
                                // best position is where most of the athletes would be correctly before and after according to the position default
                                let minSortedWrong = this.position.length+10;
                                let minSortedWrongIndex = -1;
                                for (let i=0; i<=this.position.length;i++){
                                    let sortedWrong = 0;
                                    // before:
                                    for (let j=0;j<i;j++){
                                        if (positionDefault[j]>el.position){
                                            sortedWrong++;
                                        }
                                    }
                                    // after: 
                                    for (let j=i;j<this.position.length; j++){
                                        if (positionDefault[j]<el.position){
                                            sortedWrong++;
                                        }
                                    }
                                    if (sortedWrong<minSortedWrong){
                                        minSortedWrong = sortedWrong;
                                        minSortedWrongIndex = i;
                                    }
                                }

                                // add the element at the best position
                                position.splice(minSortedWrongIndex,0,el.xSeriesStart);

                            } else {
                                // remove from posCopy
                                let ind = posCopy.indexOf(el.xSeriesStart);
                                if (ind==-1){
                                    alert('Error: Should not happen...');
                                }else{
                                    posCopy.splice(ind,1);
                                }
                            }
                            
                        })

                        // delete all elements in position that are still in posCopy
                        posCopy.forEach(el=>{
                            let ind = position.indexOf(el);
                            position.splice(ind,1);
                        })
                        // done.

                    }
                    // position is created
                    

                    // who is current and who is next?
                    // loop over the position array, check if teh persons already have a result for the current attempt
                    let ssrCurrent = null;
                    let ssrNext = null;
                    let positionNext = [];
                    for (let xSeriesStart of position){
                        if (this.tempRankingData[this.selectedSeries][xSeriesStart].perf[nextAttempt-1]==-1){
                            positionNext.push(xSeriesStart);
                        }
                    }

                    // transfer position, ssrCurrent and ssrNext to the auxData, if this client is a writing client
                    if (this.readOnly==false) {
                        // writing client. Set position and positionNext. If they have changed, send the changes to the server.
                        if (JSON.stringify(this.position) != JSON.stringify(position) || JSON.stringify(this.positionNext) != JSON.stringify(positionNext) || this.roomAuxData[series.xSeries].currentAttempt != this.currentAttempt ) {
                            this.autoManageAuxData(false);
                            this.roomAuxData[series.xSeries].positionNext = positionNext;
                            this.roomAuxData[series.xSeries].position = position;

                            // additionally propagate the following properties to all clients (this is especially needed when the site is reloaded after the result is entered, but before it is advanced to the next athlete. Then, the currentAttempt would reference to the next attempt, while the position arrays still reference the last attempt.)
                            this.roomAuxData[series.xSeries].currentAttempt = nextAttempt;
                            // eventually add nextattempt

                            // send the changed data to the server
                            rCTech.room.updateAuxDataInit(this.roomAuxData);
                        }
                        this.position = position;
                        this.positionNext = positionNext;
                        this.currentAttempt = nextAttempt; 
                    }

                    // make sure the ordering is updated (needed at least when the ordering is set to ranking)
                    this.fakeProperty++;

                },
                addResultToCurrent(res){
                    // res must be either passed, failed or regular
                    // find the seriesStart of the current athlete and the result for the current height. If this result does not exist yet, it will automatically be generated. 
                    // if sendChangeToServer

                    let series = this.series[this.selectedSeries];

                    let start = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart==this.positionNext[0])
                    if (!start){
                        alert('Error: Could not find athlete, which should never happen.')
                        return undefined;
                    }
                    let status = 0;
                    let result = null;
                    let wind = null;
                    if (res=='passed'){
                        status = 2;
                    } else if (res=='failed'){
                        status = 1;
                    } else if (res=='regular'){
                        // it may still be x or -, but through text input instead of the buttons

                        [status, result] = this.strToResult(this.competitionDistance, true);// will throw an error on an invalid string and show an error message
                        if (status==0){
                            wind = this.competitionWind*100; // to cm/s
                        }
                    } else {
                        throw('res must be either passed, failed or regular.')
                    }

                    // create the resultobject
                    const resObj = {
                        xResult: start.xSeriesStart,  // this is actually the xSeriesStart
                        attempt: this.currentAttempt,
                        status, 
                        result,
                        wind,
                        //doesNotexist:0,
                    };

                    // find the attempt element, if it already exists
                    let h = start.resultstech.find(el=>el.attempt==this.currentAttempt)
                    if (!h){
                        rCTech.room.addResultInit(resObj, start);
                    } else {
                        rCTech.room.updateResultInit(resObj, start);
                    }

                },
                failed(){
                    // current athlete failed: 
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('failed');
                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        // calculateNextAthlete will be called by series watcher
                        //this.calculateNextAthlete();
                    }else{
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();
                },
                saveResult(){

                    // value was entered for the current height
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('regular');

                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        // calculateNextAthlete will be called by series watcher
                        //this.calculateNextAthlete();
                    } else {
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();

                    // reset entries
                    this.competitionWind = null;
                    this.competitionDistance = '';
                },
                passed(){
                    // current athlete passes this height
                    // new 2022-03: do all changes in addResultToCurrent
                    this.addResultToCurrent('passed');

                    // remove the athlete from the position array
                    this.calculateTemporaryRankingData();
                    if (this.autoAdvance){
                        // calculateNextAthlete will be called by series watcher
                        //this.calculateNextAthlete();
                    }else{
                        //this.currentResultRegistered = true;
                    }
                    this.hidePeriod();
                },
                resultToStr(res, showUnit=false){
                    if (res.status == 2){
                        return '-';
                    } else if (res.status ==1){
                        return 'X';
                    } else {
                        // regular result
                        return this.formatDistance(res.result, showUnit);
                    }
                },
                resultToWind(res, showUnit=true, showSign=false){
                    // wind is in cm/s; must be scaled to 
                    const wind = Math.ceil(res.wind/10)/10; // round up to the next dm/s
                    if (showUnit || showSign){
                        // return a string
                        let sign='';
                        let unit='';
                        if (showSign && wind>=0){
                            sign='+';
                        }
                        if (showUnit){
                            unit=' m/s';
                        }
                        return `${sign}${wind.toFixed(1)}${unit}`;
                    } else {
                        // return a float
                        return wind;
                    }
                    
                },
                strToResult(resStr, showAlert=false){
                    let status = 0;
                    let result = null;
                    if (resStr.toLowerCase().includes("x")){
                        status = 1;
                    } else if (resStr.toLowerCase().includes("-")){
                        status = 2;
                    } else {
                        // use the regular performance validation.
                        const resObj = window.validatePerformance(resStr, this.discipline);
                        if (resObj.valid){
                            result = resObj.value;
                        } else {
                            alert(`<%= __('"${resStr}" cannot be interpreted as a distance.') %>`);
                            throw('invalid distance');
                        }
                    }
                    return[status, result];
                },
                resetPositions(){
                    // reset to positions to default order

                    // first check if the positions are really not the default ones
                    if (JSON.stringify(this.position) != JSON.stringify(this.defaultPosition)){
                        this.position = this.defaultPosition;
                        this.calculateNextAthlete();

                        // since this.position is already changed, calculateNextAthlete will not detect any change and will therefore also not realize, that it should send the new changes auxData to the server. Therefore, we do it manually here 
                        this.roomAuxDataSelected.positionNext = this.positionNext;
                        this.roomAuxDataSelected.position = this.position;

                        // send the changed data to the server
                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                    
                },
                onPositionMovingEnded(evt){
                    if (evt.oldIndex!=evt.newIndex){
                        // on position change, we have to recalculate the next athlete (and the positionNext array.)
                        // calculateNextAthlete will likely not be called, since the position change does nto change anything in the series and also teh change in the auxData is only done in calculateNextAthlete, and not before
                        this.calculateNextAthlete();
                    }

                    // since this.position is already changed, calculateNextAthlete will not detect any change and will therefore also not realize, that it should send the new changes auxData to the server. Therefore, we do it manually here 
                    this.roomAuxDataSelected.positionNext = this.positionNext;
                    this.roomAuxDataSelected.position = this.position;

                    // send the changed data to the server
                    rCTech.room.updateAuxDataInit(this.roomAuxData);

                },
                tabOutRes($event){
                    if ($event.key.toLowerCase()=='tab'){
                        if ($event.shiftKey){
                            this.leftWithTab = -1;
                        } else {
                            this.leftWithTab = 1;
                        }
                    }
                },
                saveCurrentResChange(start, $event, startIndex){
                    let addM='';
                    if (window.getComputedStyle(document.getElementById('techResModContainer')).display=='none'){
                        addM = 'M';
                    }
                    const elDist = document.getElementById('resChange' + this.currentResultChange.xResult + ':' + this.currentResultChange.attempt+addM);
                    const elWind = document.getElementById('resChangeWind' + this.currentResultChange.xResult + ':' + this.currentResultChange.attempt+addM);
                    if ($event.relatedTarget==elDist || $event.relatedTarget==elWind){
                        this.leftWithTab = 0;
                        return;
                    }

                    // if the string is empty, delete the result completely, otherwise, just alter it
                    if (this.currentResultString=='' && this.currentResultStringCopy!=''){
                        
                        rCTech.room.deleteResultInit(this.currentResultChange, start)

                        // recalculate the next athlete
                        // calculateNextAthlete will be called by series watcher
                        this.onSeriesChangeCalcNextAth = true;
                        //this.calculateNextAthlete();

                    } else if (this.currentResultString != this.currentResultStringCopy || this.currentWind != this.currentWindCopy){

                        let [status, result] = this.strToResult(this.currentResultString, true);
                        let wind = null;
                        if (status==0){
                            wind = this.currentWind*100; // to cm/s
                        }

                        let resObj = {
                            result,
                            wind,
                            status,
                            attempt: this.currentResultChange.attempt,
                            xResult: this.currentResultChange.xResult,
                        }

                        if (this.currentResultStringCopy==''){
                            // this is a new result
                            rCTech.room.addResultInit(resObj, start);
                        } else {
                            rCTech.room.updateResultInit(resObj, start);
                        }

                        // recalculate the next athlete
                        // calculateNextAthlete will be called by series watcher
                        this.onSeriesChangeCalcNextAth = true;
                        //this.calculateNextAthlete();

                        // TODO: what happens on invlaid input? The focus in this case should stay on the element!

                    } 
                    // leave the result change mode:
                    const attempt = this.currentResultChange.attempt;
                    this.currentResultChange = {};

                    // focus the next element, if tab was used to leave
                    if (this.leftWithTab != 0){
                        let startNext, attemptNext;
                        if (this.leftWithTab==1 && attempt==this.conf.attempts){
                            // go to next athlete (if exists), first attempt
                            if (startIndex+1<this.series[this.selectedSeries].seriesstartsresults.length){
                                startNext = this.series[this.selectedSeries].seriesstartsresults[startIndex+1];
                                attemptNext = 1;
                            }
                        } else if (this.leftWithTab==-1 && attempt==1){
                            // go to previous athlete (if exists), last attempt
                            if (startIndex-1>=0){
                                startNext = this.series[this.selectedSeries].seriesstartsresults[startIndex-1];
                                attemptNext = this.conf.attempts;
                            }
                        } else {
                            // go to next/previous attempt of same athlete
                            attemptNext = attempt+this.leftWithTab;
                            startNext = start;
                        }

                        if (startNext){

                            // go to next attempt of same athlete
                            const res = startNext.resultstech.find(el=>el.attempt==attemptNext);
                            if (res){
                                this.changeResult(res);
                            } else {
                                this.addResult(startNext.xSeriesStart, attemptNext);
                            }

                            this.leftWithTab = 0;
                        }

                    }
                },
                addResult(xSeriesStart, attempt){
                    
                    // has a different function than in techHigh, since adding is done here together with change

                    // create a "fake" (not actually stored/existing) result element for the furture result"
                    this.currentResultChange = {
                        xResult: xSeriesStart,
                        attempt,
                        result:null,
                        wind:null,
                        status:0,
                    }
                    this.currentResultString = '';
                    this.currentResultStringCopy = '';
                    this.currentWind = 0;
                    this.currentWindCopy = 0;

                    // focus the appearing input
                    let addM='';
                    if (window.getComputedStyle(document.getElementById('techResModContainer')).display=='none'){
                        addM = 'M';
                    }
                    const backwardsToWind = this.wind && this.leftWithTab==-1;
                    setTimeout(()=>{
                        if (backwardsToWind){
                            document.getElementById(`resChangeWind${xSeriesStart}:${attempt}${addM}`).focus();
                        } else {
                            document.getElementById(`resChange${xSeriesStart}:${attempt}${addM}`).focus();
                        }
                    },1)
                    this.leftWithTab=0;

                },
                changeResult(res){
                    this.currentResultChange=res;

                    // create a copy of the current result-string. If we are not doing it this way, the value of the html-element will instantly be changed back to the original value, before blur actually hits and we can store the changed result. Additionally, it allows not to raise an update event when there was no change.
                    let resStr = this.resultToStr(res);
                    this.currentResultString = resStr;
                    this.currentResultStringCopy = resStr;
                    this.currentWind = this.resultToWind(res, false); // cm/s to m/s
                    this.currentWindCopy = this.currentWind;

                    // set the focus: problem: when the element is still hidden, it cannot get the focus. And Vue will change the hidden status with a slight delay (either just asynchronous or indeed with a delay), thus we also have to implement some delay here:
                    // focus the appearing input
                    let addM = '';
                    if (window.getComputedStyle(document.getElementById('techResModContainer')).display=='none'){
                        addM = 'M';
                    }
                    const backwardsToWind = this.wind && this.leftWithTab==-1;
                    setTimeout(()=>{
                        if (backwardsToWind){
                            document.getElementById('resChangeWind' + res.xResult + ':' + res.attempt + addM).focus();
                        } else {
                            document.getElementById('resChange' + res.xResult + ':' + res.attempt + addM).focus();
                        }
                    }, 1) // time in ms (1 ms so far seems to be enough, 8-2025)
                    this.leftWithTab=0;
                },
                seriesStatusChanged(series, evt){

                    // send the change to the server
                    rCTech.room.updateSeriesInit(series, 'status', parseInt(evt.target.value));
                
                },
                startPeriod(){
                    // current time:
                    let dHere = new Date();
                    // this difference is incorrect by the ping duration. This is considered acceptable. The timeOffset is meant to correct time differences between the server and this client and not the ping. 
                    let dServer = new Date(dHere.valueOf()+this.timeOffset);

                    // since the time we store shwll be the virtual time on the server when the period is started, we have to correct it with the offset this client has to the server:

                    this.roomAuxDataSelected.periodStartTime = dServer;
                    rCTech.room.updateAuxDataInit(this.roomAuxData);

                    // make the time being updated regularly
                    this.timeUpdateInterval = setInterval(this.updateShownTime, 100);
                },
                hidePeriod(){

                    this.stopPeriod(false);
                    
                    if (!this.readOnly){
                        this.roomAuxDataSelected.showAttemptPeriod = false;
                        rCTech.room.updateAuxDataInit(this.roomAuxData);
                    }
                },
                stopPeriod(sendChange=true, setNull=true){
                    if (this.timeUpdateInterval){
                        clearInterval(this.timeUpdateInterval);
                        this.timeUpdateInterval = undefined;

                        // do not set to null to keep the time at 0:00
                        if (setNull){
                            this.roomAuxDataSelected.periodStartTime = null;
                        }
                        if (sendChange && !this.readOnly){
                            rCTech.room.updateAuxDataInit(this.roomAuxData);
                        }
                    }
                },
                updateShownTime(){
                    // show the time of the current competitor
                    let aux = this.roomAuxDataSelected;
                    let minutes = 0;
                    let seconds = 0;
                    let remainingTime = 0;
                    if (aux?.periodStartTime){
                        // time is running
                        // first, calculate the remaining time.
                        let dStart = new Date(aux.periodStartTime);
                        let dNow = new Date();

                        // a positive timeOffset means that the server time (what dStart is based on) is ahead of the time on this client.
                        let milliSecondsPassed = dNow.valueOf()-(dStart.valueOf()-this.timeOffset);
                        remainingTime = aux.attemptPeriod-milliSecondsPassed/1000;
                        if (remainingTime<0){
                            if (this.timeUpdateInterval){
                                // do not set periodStartTime to null, to ensure that the time is not hidden. 
                                this.stopPeriod(true, false);
                            };
                            minutes = 0;
                            seconds = 0; 
                        }else {
                            minutes = Math.floor(remainingTime/60);
                            seconds = Math.floor((remainingTime-60*minutes));
                        }
                    } else {
                        // time is stopped and eventually not existing
                        if (aux?.attemptPeriod){
                            minutes = Math.floor(aux.attemptPeriod/60);
                            seconds = Math.floor((aux.attemptPeriod-60*minutes));
                        } else {
                            minutes = 0;
                            seconds = 0;
                        }
                    }
                    this.shownTime = minutes.toString() + ":" + seconds.toString().padStart(2,0);
                    this.last15 = minutes*60+seconds<=15;

                    return remainingTime > 0;
                    
                },
                // show the correct time; additionally, we have to start the interval for updating the time, if the timer was started on the server and is not started yet here
                // 2022-06: moved here from vuContestTech; called in watchers
                timeManager(){
                    let timeRunning = this.updateShownTime();
                    if (timeRunning && this.timeUpdateInterval===undefined && this.selectedXSeries && this.roomAuxDataSelected.periodStartTime){
                        // start the timer
                        this.timeUpdateInterval = setInterval(this.updateShownTime, 100);
                    }
                },
                fitName(elementId, startgroup, pretext=""){

                    // in some cases, it seems that positionNext.length>1 is not false yet, but nextAthleteStart is already undefined; in that case just return ''
                    /*if (!startgroup){
                        return '';
                    }*/

                    // try to fit firstname and name in a html element
                    // returns the best possible name
                    let el = document.getElementById(elementId);

                    // if the mode was just changed from 0 to 1, the element might not be shown yet. In that case, simply show the last name 
                    if (!el){
                        return startgroup.athleteName;
                    }

                    // store the overflow-style, then set it to hidden
                    let overflowBefore = el.style.overflow;
                    let innerTextBefore = el.innerText;
                    if ( !overflowBefore || overflowBefore === "visible" ){
                        el.style.overflow = "hidden";
                    }

                    // first try firstname / lastname
                    el.innerText = `${pretext}${startgroup.athleteForename} ${startgroup.athleteName}`;
                    if (el.clientWidth >= el.scrollWidth){
                        el.style.overflow = overflowBefore;
                        //el.innerText = innerTextBefore;
                        return el.innerText;
                    }

                    // fn. / lastname
                    el.innerText = `${pretext}${startgroup.athleteForename[0]}. ${startgroup.athleteName}`;
                    if (el.clientWidth >= el.scrollWidth){
                        el.style.overflow = overflowBefore;
                        //el.innerText = innerTextBefore;
                        return el.innerText;
                    }

                    el.style.overflow = overflowBefore;
                    //el.innerText = innerTextBefore;

                    // if both did nto fit, return just the lastname
                    return `${pretext}${startgroup.athleteName}`
                },
                rankLocalizer(rank, lang='en'){
                    // return the rank as a localized string, e.g. 
                    // en: 1st, 2nd, 3rd, 4th, ...
                    // de: 1., 2., 3., ...
                    // rank is always based on the number or empty (if no rank)
                    if (rank==undefined){
                        return '';
                    }
                    if (rank==0){
                        // there is no rank 0! print no rank when 0
                        return '';
                    }
                    if (lang=='de'){
                        return `${rank}.`
                    }else {
                        // english is the default
                        if (rank==1){
                            return '1st';
                        }else if (rank==2){
                            return '2nd';
                        } else if (rank==3){
                            return '3rd';
                        } else {
                            return `${rank}th`;
                        }
                    }
                },
                // resultLOcalizer: create the result string for the given result (inlcuding the resultOverrule)
                // the result is 
                // - empty until there is a first cleared height
                // - the last valid height
                // - NM_: no valid height, and three failed attempts
                // - DISQ
                // - DNS
                resultLocalizer(ssr, lang="en"){

                    const tempRankingData = this.tempRankingData[this.selectedSeries][ssr.xSeriesStart];

                    const rank = tempRankingData.rankUntil[tempRankingData.rankUntil.length-1]; // overall rank
                    const finished = tempRankingData.finished;
                    const resultOverrule = ssr.resultOverrule;

                    // DISQ, DNS
                    if (resultOverrule>1){
                        return this.participationStatesTech.find(el=>el.value==resultOverrule)?.abbreviation;
                    }

                    // retired
                    if (resultOverrule==1){
                        // if the athlete had a result then show the last height together with the abbreviaiton for retired
                        if (tempRankingData.lastValidHeight>0){
                            return this.meterStr(tempRankingData.lastValidHeight) + " m, " + this.participationStatesTech.find(el=>el.value==resultOverrule)?.abbreviation;
                        } else {
                            return this.participationStatesTech.find(el=>el.value==resultOverrule)?.abbreviation;
                        }
                    }

                    // regular:
                    if (tempRankingData.lastValidHeight>0){
                        return this.meterStr(tempRankingData.lastValidHeight) + ' m';
                    } else {
                        if (finished){
                            // no valid result
                            return '<%= __("NM") %>';
                        } else {
                            // no result yet
                            return '';
                        }
                    }

                },
                getLastResults(numRes=2){
                    // get the specified number of results 
                },
                saveDateUtc(series, evt){
                    series.datetime = new Date(evt.srcElement.value).toISOString();
                },
                formatInputDate(date){
                    // date can be of type date or a datestring
                    // create a string that javascript accepts for input.value (unfortunately there is no automatic translation between javascript date and the format that input accepts...!)
                    let s = "";
                    let d = new Date(date); // doesnt change anything is date is already a date
                    s += d.getFullYear();
                    s += "-" + (d.getMonth()+1).toString().padStart(2,0);
                    s += "-" + d.getDate().toString().padStart(2,0);
                    s += "T" + d.getHours().toString().padStart(2,0);
                    s += ":" + d.getMinutes().toString().padStart(2,0);
                    return s;
                },
                siteChanged(series, evt){
                    // called e.g. when the time or the site was changed
                    if (evt.target.value===null || evt.target.value=='null'){
                        rCTech.room.updateSeriesInit(series, 'xSite', null);
                    } else {
                        rCTech.room.updateSeriesInit(series, 'xSite', parseInt(evt.target.value));
                    }
                },
                dateChanged(series, evt){
                    rCTech.room.updateSeriesInit(series, 'datetime', (new Date(evt.target.value).toISOString()));
                },
                bgInfo(SSR){
                    // return an array with all infoa to show in the background, e.g. PB, SB
                    // each entry must contain the text, class and columnReference to be applied 
                    let arr = [];

                    let aux = this.auxData.xStartgroup[SSR.xStartgroup]
                    let h;
                    let text;
                    // first, check if the PB can be found
                    if (aux.bestPerf && aux.bestPerf>0){
                        h = this.sortedHeightsForRes.find(el=>el.height && el.height>=aux.bestPerf); // the height is not necessarily shown
                        if (h){
                            text = "<%= __('PB') %>";
                            if (h.height == aux.bestPerf){
                                text = "=" + text;
                            } 
                            arr.push({text, class:'PBhint', columnReference:h.heightRef})
                        }
                    }

                    // second, check for SB and only add it, if there is either no PB or the PB is shown at a higher height
                    if (aux.bestPerfLast && aux.bestPerfLast>0){
                        let h2 = this.sortedHeightsForRes.find(el=>el.height && el.height>=aux.bestPerfLast); // the height is not necessarily shown
                        if (h2){
                            text = "<%= __('SB') %>";
                            if (h2.height == aux.bestPerfLast){
                                text = "=" + text;
                            } 
                            if (h && h.height != h2.height){
                                arr.push({text, class:'SBhint', columnReference:h2.heightRef});
                            }
                        }
                    }

                    return arr;
                },

                gotoQuali(relatedGroup){
                    window.location = "./groupsQualifications?xEventGroup="+relatedGroup.round.eventgroup.xEventGroup; 
                },

                sortedRes(ssr){
                    // all results and empty objects for non exiting attempts 
                    const r = []
                    for (let i=0; i<this.conf.attempts; i++){
                        let res = ssr.resultstech.find(el=>el.attempt==i+1);
                        if (res){
                            r.push(res);
                        } else {
                            r.push({
                                xResult: ssr.xSeriesStart,
                                attempt: i+1,
                                status: -1, //not existant
                                result: null,
                                wind: null,
                            })
                        }
                    }
                    return r;
                },
                missingRes(resultstech){
                    const missingAttempts = []
                    for (let i=0; i<this.conf.attempts; i++){
                        if (resultstech.findIndex(el=>el.attempt==i+1)==-1){
                            missingAttempts.push(i+1);
                        }  
                    }
                    return missingAttempts;
                },
            },
            watch:{
                mode: {
                    immediate:true, // make sure this watcher is always run at startup
                    handler:function(newMode,oldMode){ 
                        if (newMode>0 && oldMode==0){
                            this.sortValue1 = 1; // keep the default order!
                            this.sortValue2 = 2;
                        } else if(newMode==0 && oldMode>0){
                            this.sortValue1 = 1;
                            this.sortValue2 = 1;
                        }
                    },
                },
                series: {
                    immediate:true, // make sure this watcher is always run at startup
                    handler:function(seriesNew, seriesOld){
                        if (seriesOld===undefined){
                            return [];
                        }
                        // if the series-data is handed over initially, try to get the selected xSeries from the url get parameter.
                        if (seriesOld.length == 0){

                            // get the selected series from the GET parameter
                            let u = new URL(window.location.href);
                            if (u.searchParams.has('xSeries')){
                                let xSeries = Number(u.searchParams.get('xSeries'))

                                // get the index of the respective series
                                let ind = this.series.findIndex(s=>s.xSeries==xSeries);
                                if (ind>=0){
                                    this.selectedSeries = ind;
                                }
                            }


                        }

                        if (seriesNew == seriesOld){
                            // change was within the series, typically by "onChange" in the room or local changes
                            
                            // Do NOT call calculateNextAthlete when: 
                            // - the client is writing, then the necessary changes were already applied
                            // - the client is reading only and the positionsNext did not change
                            // - actually no series are available
                            let positionNextChanged = false;
                            if (this.series.length>0){
                                if (this.selectedXSeries){
                                    if (JSON.stringify(this.positionNext) != JSON.stringify(this.roomAuxData[this.selectedXSeries]?.positionNext)){
                                        positionNextChanged = true;
                                    }
                                }
                                // if another function requries to call calculateNextAthlete (which also calls calculateTempRankingData), it will set onSeriesChangeCalcNextAth=true and we force calculateNextAthlete.
                                // TODO: not sure if the autoAdvance condition is needed
                                if ( (!this.onSeriesChangeCalcNextAth) && ((!this.readOnly) && (!this.autoAdvance)) && (  positionNextChanged==false)){
                                    this.calculateTemporaryRankingData();
                                } else {
                                    this.calculateNextAthlete();
                                }

                            }

                        } else {
                            // here typically "afterFullReload" or "dataArrived" in room
                            this.calculateNextAthlete();
                        }

                        if (seriesOld.length == 0){
                            // no series before; this of course also occurs when the series are initially defined, but this should still be fine
                            // this must be done AFTER calculateNextAthlete!
                            this.showAuto();
                        }

                        this.onSeriesChangeCalcNextAth = false;

                    },
                    deep:true, // this will increase the computational load, I know... but I see no other solution
                },
                'roomAuxDataSelected.periodStartTime': function(newTime, oldTime){
                    this.timeManager();
                },
                'roomAuxDataSelected.attemptPeriod': function(newTime, oldTime){
                    this.timeManager();
                },
                'roomAuxDataSelected.showAttemptPeriod': function(newTime, oldTime){
                    this.timeManager();
                },
                'roomAuxDataSelected.positionNext': {
                    // note: since it reacts to changes to any of the properties, it will be executed as many time as there are items in positionNext. (To avoid this we had to not alter the items within positionNext, but to exchange the object. However, propertyTransfer by default changes all properties one after the other and does on purpose not exchange full arrays and objects)
                    handler: function(newPos, oldPos){
                        // must call calculateNextAthlete to make this.positionNext being the same as provided by the aux Data
                        this.calculateNextAthlete();
                    },
                    deep:true,
                },
                selectedXSeries: function(newXSeries, oldXSeries){
                    this.timeManager();
                },
                selectedSeries: {
                    immediate:true, // make sure this watcher is always run at startup
                    handler: function(newSeries, oldSeries){

                        // when we change the selectedSeries, we must reset position and positionNext to avoid problems in calculateNextAthlete; however, since this watcher is not always called before other watchers and computed properties (even if we set immediate=true !), we need an alternative to realize that positions should be resetted: selectedSeriesLazy: if calculateNextAthlete detects that selectedSeries != selectedSeriesLazy, then it will reset position and positionNext itself
                        //this.position = []; // in techHigh
                        //this.positionNext = []; // in techHigh
                        // can we be sure that selectedXSeries is updated before selectedSeries? probably not. Therefore, get the xSeries manually here
                        if (this.series.length>0){
                            const xSeries = this.series[this.selectedSeries].xSeries;
                            if (this.selectedXSeries != xSeries){
                                console.log('selectedXSeries is indeed not recomputed before selectedSeries has changed.');
                            }
                            this.position = this.roomAuxData[xSeries].position; 
                            this.positionNext = this.roomAuxData[xSeries].positionNext;
                        } else {
                            this.position = []; 
                            this.positionNext = [];
                        }
                        this.selectedSeriesLazy = newSeries;

                        // since calculate next athlete does not itself lower the mode we reset it here and then call calculateNextAthlete:
                        this.mode = 0;
                        this.calculateNextAthlete();
                    },
                },
            },
            computed:{

                techResModColTemplate: function(){
                    // rank, bib, name, birthyear, club, bestPerf, <all attempts>, remark, resultOverrule=participationState 
                    const attempts = Array(this.conf.attempts).fill(0).reduce((valSum, valNow, i)=>{
                        return valSum + ` [att${i+1}] auto`;
                    }, '').trim();
                    return `[rank] auto [bib] auto [name] auto [birthyear] auto [club] auto [bestPerf] auto ${attempts} [remark] auto [resultOverrule] auto `;
                },
                attempts: function(){
                    return Array.from({length: this.conf.attempts}, (_, i) => i + 1);
                },

                mergeSeries: function(){
                    // make sure that mergeSeries is like "not merged" when there is only one series, i.e. no merging needed
                    if (this.series.length<=1){
                        return 0;
                    } else {
                        this.conf.mergeSeries;
                    }
                },

                
                /* !!! properties for SERIES CREATION and COMPETITION !!! */
                maxDateTime: function(){
                    return `${this.meeting.dateTo.slice(0,10)}T23:59`;
                },
                minDateTime: function(){
                    return `${this.meeting.dateFrom.slice(0,10)}T00:00`;
                },
                defaultSite: function(){
                    return this.sites.find(s=>{
                        if (s.type != 1) return false
                        if (s.seriesonsite){
                            if (s.seriesonsite.find(sos=>sos.xBaseDiscipline == this.contest.xBaseDiscipline)){
                                return true;
                            }
                        }
                        return false;
                    });
                },
                defaultSiteConf: function(){
                    if (this.defaultSite){
                        try{
                            const conf = JSON.parse(this.defaultSite.conf);
                            return conf;
                        }catch(ex){
                            logger.log(10, 'The site configuration object is not a valid JSON.')
                        }
                    }
                },

                // transfer some of the aux properties form the writing room, if this room is a readOnly room (position and positionNext are transferred in calculateNextAthlete)
                    // this is needed when the positionNext and position do not change (when a change arrives on reading clients), because normally those properties are transferred there
                currentHeight: function(){
                    if (this.readOnly){
                        return this.roomAuxDataSelected.currentHeight;
                    } else {
                        return this.currentHeight2; // locally calculated
                    }
                },
                currentJumpoffHeightInd: function(){
                    if (this.readOnly){
                        return this.roomAuxDataSelected.currentJumpoffHeightInd;
                    } else {
                        return this.currentJumpoffHeightInd2;// locally calculated
                    }
                },
                /*attempt(){
                    if (this.readOnly){
                        return this.roomAuxDataSelected.attempt;
                    } else {
                        return this.attempt2; // locally calculated
                    }
                },
                attemptNext: function(){
                    if (this.readOnly){
                        return this.roomAuxDataSelected.attemptNext;
                    } else {
                        return this.attemptNext2; // locally calculated
                    }
                },*/
                roomAuxDataSelected: function(){
                    return this.roomAuxData[this.selectedXSeries];
                },

                urlFieldMonitor: function(){
                    // the url of the field monitor for the selected series
                    return window.location.origin + '/' + getLanguage() + "/" + getMeetingShortname() + `/techLongBoard?xContest=${findGetParameter('xContest')}&xSeries=${this.selectedXSeries}`;
                },
                conf: function(){
                    let o = this.parseConf(this.contest.conf);
                    return o;
                },
                filters: function(){
                    // create a custom filter for everything that filters by name, first name and bib at the same time. (club would be nice, but is not possible with the builtin-filters, since the club would have to be part of the object structure, but only the xClub is, but not the clubs and its name.) 
                    
                    // split the input string by whitespace
                    let filterWords = this.filterAthletes.split(" ");

                    // every word may be part of every of the four columns
                    let filter = {};
                    let i=1;
                    for (let filterWord of filterWords){
                        filter["filter" + i] = {keys:['athleteName', 'athleteForename', 'bib', 'sex, clubName', 'country'], value:filterWord} //
                        i += 1;
                    }
                    return filter;

                },

                seriesAsStartgroups: function(){
                    // "copy" the series and its seriesstartsresults (as startgroup)
                    let seriesAsStartgroups = [];
                    for (let i=0;i<this.series.length; i++){

                        let series = this.series[i];
                        
                        // add the other data of the series, for informational purposes only! A change to those is useless.
                        // do NOT use copyObject here, since it would destroy the reactivity. Use propertyTransfer instead.
                        let seriesCopy = {};
                        propertyTransfer(this.series[i], seriesCopy); // seriesstartsresults is actually already added here, but will be deleted again:

                        // get the startgroup for every seriesstartsresult
                        let SSRs = [];
                        series.seriesstartsresults.forEach(ssr=>{
                            // create a copy of the ssr
                            let ssrCopy = copyObject(ssr);
                            // find the startgroup for the respective seriesstartsresult and add it to the list
                            let startgroup = this.startgroups.find(SG=>SG.xStartgroup == ssr.xStartgroup)
                            if (startgroup){
                                ssrCopy.startgroup = startgroup;
                                ssrCopy.ssrOriginal = ssr;
                            } else {
                                console.log('Error: could not find xStartgroup of an assigned athlete. This data inconsistency should not occure. Try to fully reload the auxilary data.')
                            }

                            // reference the original (!) 'parent'; avoids that xSeries has to be defined to be used in "changePosition"
                            ssrCopy.series = seriesCopy;
                            ssrCopy.seriesOriginal = series;

                            SSRs.push(ssrCopy)
                        })
                        
                        seriesCopy.seriesstartsresults= SSRs;
                        seriesCopy.seriesOriginal = series;
                        seriesAsStartgroups.push(seriesCopy);
                    }

                    // sort the series
                    seriesAsStartgroups.sort((a,b)=>{
                        return a.number-b.number;
                    })
                    // sort the seriesstartsresults
                    seriesAsStartgroups.forEach(series=>{
                        series.seriesstartsresults.sort((a,b)=>{
                            return a.position-b.position;
                        })
                    })

                    return seriesAsStartgroups;
                },


                /* !!! properties for SERIES CREATION only !!! */

                seriesAssignments: function(){
                    // filter all series assignments to show only tech long (type==2) assignements
                    return this.seriesAssignmentsAll.filter(sa=>sa.baseDisciplineTypes.indexOf(2)>=0);
                },

                defaultPosition: function(){
                    // returns an array with the default position array; this is needed to reset the array and to know if the order currently is changed or not
                    const ssrs = this.series[this.selectedSeries].seriesstartsresults;
                    let posCopy = this.position.slice();
                    posCopy.sort((xSSR1,xSSR2)=>{
                        const SSR1 = ssrs.find(s=>s.xSeriesStart==xSSR1);
                        const SSR2 = ssrs.find(s=>s.xSeriesStart==xSSR2);
                        return SSR1.position - SSR2.position
                    })
                    return posCopy;
                },

                // to move around the atheletes e.g. from non-assigned to series we have to work on the startgroups. Create an array with all unassigned startgroups (unassignedAthletes) and one for every series with the same info (seriesAsStartgroups). 

                unassignedAthletes: function(){
                    // create an array of all unassigned athletes, including those with present=false
                    // first copy the full list of startsingroups
                    let unassignedAthletes = this.startgroups.slice(); //map(el=>el.xStartgroup);

                    // remove all entries which are references in a series
                    for (let i=0; i<this.series.length; i++){
                        this.series[i].seriesstartsresults.forEach((el, seriesIndex)=>{
                            let ind = unassignedAthletes.findIndex(el2=> el.xStartgroup==el2.xStartgroup);
                            if (ind<0){
                                console.log('Error: could not find xStartgroup of an assigned athlete. This data inconsistency should not occure. Try to fully reload the auxilary data.')
                            } else {
                                // remove the startgroups
                                unassignedAthletes.splice(ind,1);
                            }
                        })
                    }
                    return unassignedAthletes;
                },
                
                seriesAssignmentOverlay: function(){
                    // show the configuration of the currently selected series assignment algorithm
                    return this.seriesAssignments[this.selectedSeriesAssignment].overlayName;
                },

                /* !!! properties for COMPETITION only !!! */

                selectedXSeries: function(){
                    if (this.series.length>0){
                        return this.series[this.selectedSeries].xSeries;
                    }
                    return undefined;
                },
                auxData: function(){
                    // change the xStartgroup array to an object with objects, where xStartgroup is the key
                    let auxData = {};
                    auxData.xStartgroup = {};
                    this.startgroups.forEach(el=>{
                        auxData.xStartgroup[el.xStartgroup]=el;
                    })
                    return auxData;
                },
                currentAthleteStart: function(){
                    return this.getStartByXSeriesStart(this.positionNext[0]);
                },
                nextAthleteStart: function(){
                    if (this.positionNext.length>1){
                        return this.getStartByXSeriesStart(this.positionNext[1]);
                    }else{
                        return undefined;
                    }
                },
                sortedStarts1: function(){
                    let i = this.fakeProperty; // just to make sure sortedStarts gets updated on rank changes
                    // TODO
                    //return this.series[this.selectedSeries].seriesstartsresults;

                    // we cannot just sort the seriesstartsresults-array as this would also change the order at several different places (especially the algorithm for 'the next athlete sequence' might not work anymore!)                            

                    // create an array with all array-indexes (0 to length-1) of the seriesstartsresults array; (the initialized elements are empty first and map only uses non-empty fields. Thus we first fill with undefined and then create in indices)
                    let order = Array(this.series[this.selectedSeries].seriesstartsresults.length).fill(undefined).map(function (x, i) { return i; })

                    let compareFn = (a,b)=>{a-b} // fallback
                    if (this.sortValue1 == 1){
                        // default sequence
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            return A.position - B.position
                        }
                    } else if (this.sortValue1 == 2){
                        // sort by rank
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let rA = this.tempRankingData[this.selectedSeries][A.xSeriesStart].rankUntil[this.conf.attempts-1];
                            let rB = this.tempRankingData[this.selectedSeries][B.xSeriesStart].rankUntil[this.conf.attempts-1];
                            if (rA==0 && rB==0){

                                // both have no rank (yet):
                                // the order should be: in competition without a valid result < retired NM < regular NM < DNS < DQ < not started yet
                                const assignVal = function(X, rX){
                                    if (X.resultOverrule==0 && !rX.finished){
                                        return 0;
                                    }
                                    if (X.resultOverrule==1){
                                        // retired, NM
                                        return 2;
                                    }
                                    if (X.resultOverrule==0 && rX.finished){
                                        // regular NM
                                        return 4;
                                    }
                                    if (X.resultOverrule==5){
                                        // DNS
                                        return 6;
                                    }
                                    if (X.resultOverrule==6){
                                        // DQ
                                        return 8;
                                    }
                                    // should never arrive here
                                    alert('should not be here');
                                    return 100;
                                }
                                const Aval = assignVal(A, this.tempRankingData[this.selectedSeries][A.xSeriesStart]);
                                const Bval = assignVal(B, this.tempRankingData[this.selectedSeries][B.xSeriesStart]);
                                 
                                return Aval - Bval;
                            } else if (rA==0){
                                // A must be lower than B
                                return 1;
                            } else if (rB==0){
                                // B must be lower than A
                                return -1;
                            } else {
                                // sort by rank
                                return rA-rB;
                            }
                        }
                    } else if (this.sortValue1 == 3){
                        // sort by name
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];

                            return (auxA.athleteName + auxA.athleteForename).localeCompare(auxB.athleteName + auxB.athleteForename);
                        }
                    } else if (this.sortValue1 == 4){
                        // sort by bib
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];
                            
                            return auxA.bib - auxB.bib;
                        }
                    }
                    order.sort(compareFn);

                    return order;

                },
                sortedStarts2: function(){
                    let i = this.fakeProperty; // just to make sure sortedStarts gets updated on rank changes

                    // we cannot just sort the seriesstartsresults-array as this would also change the order at several different places (especially the algorithm for 'the next athlete sequence' might not work anymore!)                            

                    // create an array with all array-indexes (0 to length-1) of the seriesstartsresults array; (the initialized elements are empty first and map only uses non-empty fields. Thus we first fill with undefined and then create in indices)
                    let order = Array(this.series[this.selectedSeries].seriesstartsresults.length).fill(undefined).map(function (x, i) { return i; })

                    let compareFn = (a,b)=>{a-b} // fallback
                    if (this.sortValue2 == 1){
                        // default sequence
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            return A.position - B.position
                        }
                    } else if (this.sortValue2 == 2){
                        // sort by rank
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let rA = this.tempRankingData[this.selectedSeries][A.xSeriesStart].rankUntil[this.conf.attempts-1];
                            let rB = this.tempRankingData[this.selectedSeries][B.xSeriesStart].rankUntil[this.conf.attempts-1];
                            if (rA==0 && rB==0){
                                // both have no rank (yet):
                                // the order should be: in competition without valid height < retired NM < regular NM < DNS < DQ < not started yet
                                const assignVal = function(X, rX){
                                    if (X.resultOverrule==0 && !rX.finished){
                                        // differentiate with result and without result
                                        if (rX.failedAttemptsSinceLastValid>0){
                                            // already has a result
                                            return 0
                                        } else {
                                            // no result yet; at the very end
                                            return 10
                                        }
                                    }
                                    if (X.resultOverrule==1){
                                        // retired, NM
                                        return 2;
                                    }
                                    if (X.resultOverrule==0 && rX.finished){
                                        // regular NM
                                        return 4;
                                    }
                                    if (X.resultOverrule==5){
                                        // DNS
                                        return 6;
                                    }
                                    if (X.resultOverrule==6){
                                        // DQ
                                        return 8;
                                    }
                                    // should never arrive here
                                    alert('should not be here');
                                    return 100;
                                }
                                const Aval = assignVal(A, this.tempRankingData[this.selectedSeries][A.xSeriesStart]);
                                const Bval = assignVal(B, this.tempRankingData[this.selectedSeries][B.xSeriesStart]);
                                 
                                return Aval - Bval;
                            } else if (rA==0){
                                // A must be lower than B
                                return 1;
                            } else if (rB==0){
                                // B must be lower than A
                                return -1;
                            } else {
                                // sort by rank
                                return rA-rB;
                            }
                        }
                    } else if (this.sortValue2 == 3){
                        // sort by name
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];

                            return (auxA.athleteName + auxA.athleteForename).localeCompare(auxB.athleteName + auxB.athleteForename);
                        }
                    } else if (this.sortValue2 == 4){
                        // sort by bib
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];
                            
                            return auxA.bib - auxB.bib;
                        }
                    }
                    order.sort(compareFn);

                    return order;

                },
                resultGridTemplateCol: function(){

                    // make sure the resultGridTemplate is updated when the xHeight is exchanged
                    let i = this.fakeProperty;

                    //let h = this.sortedHeights;
                    let h = this.sortedHeightsForRes; // 2024-08-06
                    let s = '[rank] max-content [position] max-content [bib] max-content [athletes] max-content [result] max-content';
                    for (let h of this.sortedHeightsForRes){
                        s += ' ['+h.heightRef+'] max-content'; /* the label for the line must not be a number, but a string */
                    }
                    s += ' [end]';
                    return s;
                },
                resultGridTemplateRow: function(){
                    return `repeat(${this.sortedStarts2.length+1}, max-content)`; // plus the header row
                },
                discipline: function(){
                    return this.disciplines.find(d=>d.xBaseDiscipline==this.contest.xBaseDiscipline);
                },
                disciplineConfiguration: function(){
                    // get the first discipline with matching baseDiscipline and parse its configuration
                    let d = this.discipline;//.disciplines.find(d=>d.xBaseDiscipline==this.contest.xBaseDiscipline);
                    if (!d || d.baseConfiguration==''){
                        return {type:'throw', wind:false};
                    } else {
                        let o = JSON.parse(d.baseConfiguration);
                        o.type = o.type ?? 'throw';
                        o.wind = o.wind ?? false;
                        return o;
                    }
                },
                wind: function(){
                    return true; // TODO: remove
                    return this.disciplineConfiguration.wind;
                },
                resultInCurrentAttempt: function(){
                    // get the result of the athlete in the current attempt. This function will only return a non-null value when the currentAthlete has already a result. This only happens when autoAdvance=false and the writing client has not pressed "advance" yet (i.e. calculateNextAthlete was not yet run) 
                    // returns the result as a string (5.43 m, X, -) or False (when no result yet)

                    let x = this.fakeProperty;

                    // check whether there is already a result for the current athlete on the current height
                    let res = this.currentAthleteStart.resultstech.find(r=>r.attempt == this.currentAttempt);
                    if (res==undefined){
                        return false;
                    }
                    if (res.result == null || res.status==1){
                        return 'X';
                    } 
                    if (res.status == 2){
                        return '-';
                    }
                    if (res.result){
                        return this.formatDistance(res.result); 
                    }
                    return false;
 
                },

            },
            beforeMount(){
                // work on data before it is showed the first time
                // moved to when the data arrives
            },
            mounted:function(){
                // initialize all series assignments
                this.seriesAssignments.forEach((SA)=>{
                    SA.initFunc.bind(this)();
                })

                // regularly update the shown time
                this.timeInterval = setInterval(()=>{
                    const t = new Date();
                    this.timeHours = t.getHours().toString().padStart(2,0);
                    this.timeSeconds = t.getSeconds().toString().padStart(2,0);
                    this.timeMinutes = t.getMinutes().toString().padStart(2,0);
                    this.timeOdd = t.getMilliseconds() < 500;
                }, 100); // 10 times per second

                // register event for keys x, o, -
                addEventListener('keydown', (evt)=>{

                    // do NOT handle this when NOT in competition mode and when changing the attempt time
                    // wind is checked below
                    const remark = document.getElementById('competitionRemark'); 
                    const time = document.getElementById('attemptTime');
                    if (this.show != 'competition' || document.activeElement==remark || document.activeElement==time){
                        return;
                    }

                    // only handle the event once
                    if (evt.repeat) return;
                    // only on writing clients
                    if (this.readOnly) return;
                    // only in the modes regular and merged final
                    if (this.mode <1 || this.mode==2 || this.mode>3) return;
                    // only handle when on competiztion window
                    if (this.show=='competition'){
                        if (evt.key=='x'){
                            this.failed();
                        } else if (evt.key=='-'){
                            // only handle as passed if not a wind entry is selected (then it simply is a regular -)
                            if (!document.activeElement.id.includes('wind')){
                                this.passed();
                            }
                        } else if (evt.key=='Enter'){
                            // depends on whether the athlete already has a result in the current attempt (--> next athlete) or not (simply save the result)
                            if (this.resultInCurrentAttempt){
                                this.calculateNextAthlete();
                            } else {
                                this.saveResult();
                            }
                        }
                    } else if(this.show=='resMod'){
                        // TODO
                        // enter: store result only
                        // tab: store result and advance to next result
                    };

                })                
            },
            components:{
                'draggable': vuedraggable,
                'v-table':VTable,
                'v-th': VTh,
                'v-tr':VTr,
            },
        }

        vueSeriesAdminTech = Vue.createApp(vueAppConfig).mount('#vueSeriesAdminTech')

        // load the room:
        let ms = getMeetingShortname();

        // get the GET-parameter xContest (null if not found)
        let xContest = findGetParameter('xContest')
        
        //xContest = 3; // TODO: delete

        if (xContest!=null && !isNaN(xContest)){
            xContest = Number(xContest)
            // start the roomClientView
            rCTech = new vuContestTechLong(vueSeriesAdminTech, ms, xContest, writing);

            rSites = new vuSites(vueSeriesAdminTech, ms);

        } else {
            // eventually show a message that there is no  
        }

    }

</script>
<script type="module">
    // MODULE stuff for printing
    import {dContestSheet, dSeriesSheetHigh, dPersonContestSheetHigh, dPersonContestResultHigh, dHeaderFooter, printer, pPersonContestSheetHigh, pSeriesContestSheetHigh, pContestSheetHigh, pHeaderFooter, pPersonContestResultHigh, pSeriesContestResultsHigh, pContestResultsHigh} from "/static/printDocumentStructure.js";


    /**
     * Create the data structure for printing
     * @param {object} contest The contest object of the room
     * @param {array} series Array storing all series 
     * @param {array} startgroups Array with all additional information (name, firstname, event, etc) for each startgroup=seriesStartResult
     * @param {array} categories
     * @param {array} heights
     * @param {array} disciplines
     * @param {array} relatedGroups
     * @param {array} sites all sites
     * @param {integer} xSeries The series to show. Null means that all series are printed. default=null 
     * @returns dContest instance with all series/persons as childs
     */
    function createDataStructureSeries(contest, series, startgroups, categories, heights, disciplines, relatedGroups, sites, xSeries=null){

        // get the name of the discipline
        let discName = disciplines.find(d=>d.xBaseDiscipline==contest.xBaseDiscipline)?.name 

        let cContest =  new dContestSheet(contest.datetimeAppeal, contest.datetimeCall, contest.datetimeStart, contest.name, contest.status, contest.conf, discName, relatedGroups, categories);

        // create each series-container and add it to the contest
        for (let s of series){
            if (xSeries==null || s.xSeries == xSeries){
                
                // get the name of the site
                let siteName = '';
                if (s.xSite !== null){
                    const site = sites.find(si=>si.xSite == s.xSite);
                    if (site){
                        siteName = site.name;
                    }
                }

                let cSeries = new dSeriesSheetHigh(s.xSeries, s.status, s.number, s.name, siteName, s.seriesstartsresults, heights, s.datetime);

                // add each person in this series. Get the necessary information from the startgroup
                for (let ssr of s.seriesstartsresults){
                    // try to find the startgroup corresponding to SSR
                    let startGroup = startgroups.find(sg=>sg.xStartgroup==ssr.xStartgroup)
                    if (startGroup){

                        // get the category name
                        let cat = categories.find(c=> c.xCategory==startGroup.xCategory);
                        let catName;
                        if (cat){
                            catName = cat.shortname;
                        }

                        let p = new dPersonContestSheetHigh(startGroup.athleteName, startGroup.athleteForename, startGroup.bib, startGroup.birthdate, startGroup.country, startGroup.regionShortname, startGroup.clubName, startGroup.eventGroupName, startGroup.xDiscipline, ssr.position, catName, heights, ssr.startConf)

                        cSeries.children.push(p);
                    } else {
                        // TODO: replace by correct logging!
                        console.log(`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`)
                        throw {code:5, message:`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`}
                    }
                }

                // sort the persons by their position
                cSeries.sortChildren('position');

                cContest.addSeries(cSeries);
            }
        }
        cContest.sortSeries('number')
        return cContest
    }

    /**
     * Create the data structure for printing
     * @param {object} contest The contest object of the room
     * @param {array} series Array storing all series 
     * @param {array} startgroups Array with all additional information (name, firstname, event, etc) for each startgroup=seriesStartResult
     * @param {array} categories
     * @param {array} heights
     * @param {array} disciplines
     * @param {array} relatedGroups
     * @param {array} sites all sites
     * @param {integer} xSeries The series to show. Null means that all series are printed. default=null 
     * @returns dContest instance with all series/persons as childs
     */
    function createDataStructureResults (contest, series, startgroups, categories, heights, disciplines, relatedGroups, sites, tempRankingData, conf, xSeries=null){

        // get the name of the discipline
        let discName = disciplines.find(d=>d.xBaseDiscipline==contest.xBaseDiscipline)?.name 

        // dContest sheet is the same (pContestSheet will be different) 
        let cContest =  new dContestSheet(contest.datetimeAppeal, contest.datetimeCall, contest.datetimeStart, contest.name, contest.status, contest.conf, discName, relatedGroups, categories, {}, false);

        // create each series-container and add it to the contest
        for (let s of series){
            if (xSeries==null || s.xSeries == xSeries){
                
                // get the name of the site
                let siteName = '';
                if (s.xSite !== null){
                    const site = sites.find(si=>si.xSite == s.xSite);
                    if (site){
                        siteName = site.name;
                    }
                }

                let cSeries = new dSeriesSheetHigh(s.xSeries, s.status, s.number, s.name, siteName, s.seriesstartsresults, heights, s.datetime, series.length>1); // only show the series line when there is more than one series

                // add each person in this series. Get the necessary information from the startgroup
                for (let ssr of s.seriesstartsresults){
                    // try to find the startgroup corresponding to SSR
                    let startGroup = startgroups.find(sg=>sg.xStartgroup==ssr.xStartgroup)
                    if (startGroup){

                        // get the category name
                        let cat = categories.find(c=> c.xCategory==startGroup.xCategory);
                        let catName;
                        if (cat){
                            catName = cat.shortname;
                        }

                        // get the temporary ranking data
                        let trd = tempRankingData[ssr.xSeriesStart];

                        // create an array with all results, where each result looks like: [3.50, 'XO', 0] // 0 denotes the jumpoffOrder
                        let results = [];
                        for (let res of ssr.resultshigh){
                            // find the height
                            let h = s.heights.find(h=>h.xHeight == res.xHeight);
                            // create the string
                            let resultStr ='';
                            resultStr += 'X'.repeat(res.resultsHighFailedAttempts);
                            if (res.resultsHighValid){
                                resultStr += 'O';
                            }
                            if (res.resultsHighPassed){
                                resultStr += '-';
                            }
                            results.push({
                                height: h.height/100,
                                resultStr,
                                jumpoffOrder: h.jumpoffOrder,
                            })
                        }
                        // sort the results (should typically be sorted already; however, we never know...)
                        results.sort((a,b)=>{
                            if (a.jumpoffOrder != b.jumpoffOrder){
                                return a.jumpoffOrder - b.jumpoffOrder;
                            }
                            return a.height - b.height;
                        })

                        let p = new dPersonContestResultHigh(startGroup.athleteName, startGroup.athleteForename, startGroup.bib, startGroup.birthdate, startGroup.country, startGroup.regionShortname, startGroup.clubName, startGroup.eventGroupName, startGroup.xDiscipline, ssr.position, catName, trd.rankUntil[trd.rankUntil.length-1], trd.lastValidHeight, results, ssr.startConf, ssr.resultOverrule, ssr.resultRemark, ssr.qualification, true);

                        cSeries.children.push(p);
                    } else {
                        // TODO: replace by correct logging!
                        console.log(`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`)
                        throw {code:5, message:`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`}
                    }
                }

                // sort the persons by their rank
                cSeries.sortChildren(['resultOverruleSorting', 'rankSorting']);

                cContest.addSeries(cSeries);
            }
        }
        cContest.sortSeries('number')
        return cContest
    }

    async function printResultsTechLong(){
        // dynamically get the print configuration for the current language
        let lang = getLanguage();
        const {confPrint} = await import(`/${lang}/confPrint`);
        const conf = confPrint;

        let cContest = createDataStructureResults(vueSeriesAdminTech.contest, vueSeriesAdminTech.series, vueSeriesAdminTech.startgroups, vueSeriesAdminTech.categories, vueSeriesAdminTech.allHeights, vueSeriesAdminTech.disciplines, vueSeriesAdminTech.relatedGroups, vueSeriesAdminTech.sites, vueSeriesAdminTech.tempRankingData, conf, null);
        let hf = new dHeaderFooter([cContest], vueSeriesAdminTech.meeting);
        
        // define the translations from dataContainers to prtContainers
        const dataToPrint = {
            dHeaderFooter: pHeaderFooter,
            dContestSheet: pContestResultsHigh, 
            dSeriesSheetHigh: pSeriesContestResultsHigh, 
            dPersonContestResultHigh: pPersonContestResultHigh
        }

        let p = await printer.create([hf], dataToPrint, conf, true)

        p.showNewTab()

        return p;

    }

    async function printSeriesTechLong(){

        // dynamically get the print configuration for the current language
        let lang = getLanguage();
        const {confPrint} = await import(`/${lang}/confPrint`);
        const conf = confPrint;

        let cContest = createDataStructureSeries(vueSeriesAdminTech.contest, vueSeriesAdminTech.series, vueSeriesAdminTech.startgroups, vueSeriesAdminTech.categories, vueSeriesAdminTech.allHeights, vueSeriesAdminTech.disciplines, vueSeriesAdminTech.relatedGroups, vueSeriesAdminTech.sites, null);
        let hf = new dHeaderFooter([cContest], vueSeriesAdminTech.meeting);

        // define the translations from dataContainers to prtContainers
        const dataToPrint = {
            dHeaderFooter: pHeaderFooter,
            dContestSheet: pContestSheetHigh,
            dSeriesSheetHigh: pSeriesContestSheetHigh,
            dPersonContestSheetHigh: pPersonContestSheetHigh
        }

        let p = await printer.create([hf], dataToPrint, conf, true)
        //let p = new printer([hf], true)

        // add the page number in a rather strange way, by directly replacing a placeholder in the content stream as a hex word. Please note that with that approach the text will not be aligned correctly when the alignment is not left, since the original alignment done in some function was based on the placeholder and not the replaced string.
        // To increase speed, we could not try to replace a part of a string (which requires searching all strings for the given needle), but instead simply replace a shole string, which only requires the comparison of full strings and a replacement whenever needed. 

        // encode the string to be replaced 
        /*let placeholder = p.fonts.Helvetica.encodeText('{The number of pages}')

        // encode replacement string 
        let replacer = p.fonts.Helvetica.encodeText('Page X of Y')

        for (let iO of p.doc.context.indirectObjects.values()){ // indirectObjects is a MAP
            // only further consider PDF content streams and Tj operators
            if (iO.constructor.name == 'PDFContentStream'){
                for (let oP of iO.operators){
                    if (oP.name==='Tj'){
                        // this is a text operator
                        // now search for the encoded text and replace it
                        // args of Tj have always only one element
                        oP.args[0].value = oP.args[0].value.replace(placeholder.value, replacer.value);
                    }
                }
            }
        }*/
        // Tested. Works. (But this is certainly not the best approach.)

        p.showNewTab()

        return p
    }

    // make sure the pritnContest function is visible/accessible to all other rooms.
    window.printSeriesTechLong = printSeriesTechLong;
    window.printResultsTechLong = printResultsTechLong;
</script>
<!-- up to here, content of techLongBase; all subsequent stuff (i.e. how the data is shown) is defined separately. -->
<%- content %>