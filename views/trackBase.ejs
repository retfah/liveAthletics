<script src="/static/vuContestTrack.js"></script>
<script type="module">
    // include stuff which is in a module; add it to window, so that it can be used 
    import {formatCountryRegion, disciplineFormatters, validatePerformance} from '/static/performanceProcessing.js';
    window.formatCountryRegion = formatCountryRegion;
    window.disciplineFormatters = disciplineFormatters;
    window.validatePerformance = validatePerformance;

</script>
<script>

    // this code originally was based on techHigh

    /**
     * Series creation for track:
     * - provide an option for swapping lanes (two athletes change their lanes.) With draggable this can be done as shown here:https://stackoverflow.com/questions/63433028/vue-draggable-how-to-only-replace-item-chosen-to-prevent-shifting-all-other-it
     * - provide the possibility that pressing Ctrl and or Shift change the behavior between "insert element and automatically move all others" (draggable default), "swap lanes" and "add to same lane"
     **/

    // connect to the room (defined by te ID in the URL/http-GET-param)
    // class vuContestTest is imported above

    class vuSites extends roomClientVue{
        
        constructor(vue, meetingShortname){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            super('sites@' + meetingShortname, false, true, '/static/rSitesClient.js', 'rSitesClient', '')
    
            // needed to call things in the vue class
            this.vue = vue;
        }
    
        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }
    
        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            this.vue.sites = this.room.data.sites; // this will actually store a proxy of the data!
        }
        
        dataArrived(){
            // raised as soon as the room has its data stored for the first time
            this.vue.sites = this.room.data.sites;
    
        }
    }

    class vuSiteTest extends roomClientVue{
        
        constructor(vue, meetingShortname){
            // parent constructor: initializes the room
            //(roomName, writing, storeInfos, path, className, datasetName='')
            // TODO: this is only for testing; actually, rSItesClient is the wrong class, but since we do not do any changes, it actually should not matter.
            super('sites/1@' + meetingShortname, false, true, '/static/rSiteTrackClient.js', 'rSiteTrackClient', '')
    
            // needed to call things in the vue class
            this.vue = vue;
        }
    
        /**
         * called when a a writing ticket is stored or deleted
         */
        onWritingTicketChange(){
            if (this.room.writingTicketID){
                //this.vueServerAdmin.readOnly = false;
            } else {
                //this.vueServerAdmin.readOnly = true;
            }
        }
    
        onChange(){
            //this.vue.$forceUpdate();
        }
        
        afterFullreload(){
            // set the changed data-property as data of the vue-instance
            //this.vue.sites = this.room.data.sites; // this will actually store a proxy of the data!
        }
        
        dataArrived(){
            // raised as soon as the room has its data stored for the first time
            //this.vue.site = this.room.data.sites;
    
        }
    }

    var rCTrack;
    var rSites;
    var rSiteTest;
    var vueSeriesAdminTrack; 

    function startTrackAdminRead(){
        // no writing right
        startTrackAdmin(false);
    }

    function startTrackAdmin(writing=true){

        /**
         * IMPORTANT NOTE: 
         * 1.) this room shall also work offline, i.e. all changes are written to a stack on the client which will be synchronized as soon as possible. However, this also needs that the changes are directly applied on the client, instead of applying them not before the answer of the server in "online-only" pages.
         * 2) If a change cannot be processed on the server, it has to be reverted on the client! This makes it necessary that the addToStack function is called with everything needed to perform a rollback of the change. This basically needs that the init-function in the room gets the new and old data. 
         * 3) Unfortunately, basic html events such as "onchange" do not provide the old and new value, but only the new. The best function we can use instead is a vue-watcher on the property. However, this has the problem that it is not only called when a change is done through the veu-app, but also if the data is changed from the room (because both raise the Proxy...). If we simply would watch for data changes and always send a change request to the server on change, we might end in an infinite loop, where client A changes something, B gets the change and modifies its data, the B's vue-watcher is raised, send the change to the server, client A gets it and there the watcher is raised again and so on...
         * 4) To ommit this problem, the best solution I have found is to have a special proeprty (here: propagateChange), which is set to true in an onchange event, hopefully raised before the watcher, and only if this is set to true, the change is sent to the server. The property then of course must be reset instantly.
         **/

        // TODO: eventually move this into vue

        let vueAppConfig = {
            data(){
                return {

                    list1:[1,2,3],
                    list2:[4,5,6],

                    dragged:null, // note which element is currently dragged

                    sites:[],

                    heatInterval: 60, // in s

                    developMode:false,
                    //showContestInfo: false,
                    show:'none', // TODO: automatically show most reasonable thing at startup
                    overlay: undefined, // either undefined or 'createSeries'
                    overlay2: undefined, // createSeries or undefined
                    overlay3: undefined, // config or undefined
                    // there will be no waiting page, but a limit to one client and this will be the first offline working page.
                    burgerChecked: false, // burger menu activated

                    onSeriesChangeCalcNextAth: true,

                    // show a clock on some screens (e.g. live screen); 
                    // start an interval to update the time in "mounted", if the time is odd, show the ":" between minutes and hours 
                    timeHours:'00',
                    timeMinutes:'00',
                    timeSeconds:'00',
                    timeOdd: false,
                    timeInterval: null, // the function to stop the interval

                    // the data is split into three parts, to be able to reuse the seriesAdmin parts
                    // TODO: also split computed properties, watchers and methods!

                    /* !!! data for SERIES CREATION and COMPETITION !!! */
                    categories:[],
                    meeting:{},     // informational only
                    disciplines:[], // informational only, to be able to show the name of the discipline and get some conf-data about the discipline, such as the max-reasonable height used to create the limit until where the heights shall be created
                    // TODO

                    //activateLate: false, // thing that cannot be drawn at startup, e.g. because they rely 
                    readOnly: false, // whether we can do changes or not (have a writingTicket or not)
                    
                    // info overlay
                    infoTitle: '',
                    infoContent:'',
                    infoVisible:false,

                    // yesNo overlay
                    yesNoVisible:false,
                    yesNoText: '',
                    yesNoTitle: '',
                    yesNoFunction:()=>{},

                    contest:{ // to be overridden as soon as the room-data arrives
                        status: 10,
                    },
                    startgroups: [],
                    relatedGroups: [],
                    // IMPORTANT: the contest data must be equivalent to the data in techHigh (which should be the case since this was based on the database structure)

                    // the names and id's of series and contest states:
                    // Note: the comment before the ejs-include only affects the first row of the included file; (thats why it still works)
                    // also gets seriesStates and participationStates
                    //<%- include('contestStates.ejs') %>

                    numSeries:0,
                    //unassignedAthletes:[100,101, 102, 103],
                    unassignedAthletesCreate:[], // the array is manually populated when the initial series assignment is shown

                    series:[],
                    seriesObj:[], //{1:[15,16], 2:[17,18]},


                    /* !!! data for SERIES CREATION ONLY !!! */

                    propagateChange: false, // if the most recent change on the data (registered and monitored via "watchers") must be propagated to the server or not. (Not is typically the case when the changes comes from the server or any other change on the data done in the room but not in the data)

                    updateHeightIncrease: -1, // show change-line for height increases
                    heightIncreaseBeforeUpdate: {}, // resetting to previous values on height increase change
                    confForMod: {}, // the conf-object that is modified during conf changes. Recreated everytime conf-change is opened. At the end, the changes are either stored back to to the JSON in contest.conf (which then is applied to the computed property conf) or we just do nothing. 
                    newHeightIncreaseStart: undefined,
                    newInterval: undefined,

                    // series assignments (the different strategies that can be applied)
                    seriesAssignmentsAll: [
                    //includes<% seriesAssignments.forEach((SA)=>{ %>
                        // next include:<%- include(SA, {type:"js"}) %>,
                    //<% }); %>
                    ],
                    seriesAssignmentConfiguration:{}, // object will be populated by init functions of the respective functions
                    selectedSeriesAssignment: 0, // by default choose the first series assignment strategy

                    filterAthletes:'',
                    showFullDetails: false, // TODO: true for debugging only

                    /* !!! data for COMPETITION only !!! */
                    
                    xHeightTemp: -1, // temporary xHeight, until the height could be written to the DB and we get the actual index, we use this. Auto-increment into negative. When the correct key arrives, we must not only change the key in xHeight, but also in every result!  
                    xResultTemp: -1, // temporary xResult (needed for identical element id's; it is not referenced somewhere)
                    updateHeightIncrease: -1, // show change-line for height increases
                    heightIncreaseBeforeUpdate: {}, // resetting to previous values on height increase change

                    selectedSeries: 0, // which series we are working on. 
                    selectedSeriesLazy: 0, // which series we were working on before
                    //allHeights:[], // contains all already fixed and all predicted heights; computed property as of 2022-06
                    mode: 0, // 0: before all startHeights are set, 1=competition running (or is ready to be started), 2=jumpoff, 3=finished
                    currentHeight2: -1,  // in cm
                    currentJumpoffHeightInd2: -1, // during jumpoff, store here the current index in the jumpoff order
                    jumpoffHeightRequired: false, // true if a new height should be defined by the user
                    bestAtEachJumpoffHeight: [],
                    manualJumpoffHeight:0, // used to set the default next jumpoff height, before we actually see the input element
                    position:[], // array with the xStartgroup of all athletes starting on the current height, defining the order in the copetition; changed by the drag and drop part; in the jumpoff, it contains all athletes that still participate in the jumpoff, independent whether they aready jumped on the current height
                    positionNext: [], // the first element contains the index in the position array of the first athlete to come, the second element the second, and so on; during the main competition, positionNext has the same length as position; in the jumpoff, it can be smaller, since it only contains the athletes that will still jump on the current jumpoff-height, while position also contains the athletes that already jumped on the current height
                    tempRankingData: { // all data needed for ranking and for gettign the current athlete
                        //xSeriesStart
                        /*12:{
                            totalFailedAttempts: 0, // until and with the last valid hight
                            failedAttemptsSinceLastValid: 0, // after 3, the person is out of the competition. 
                            failedAttemptsOnLastValid: 0,
                            lastValidHeight: 0,
                            nextJumpingHeight: 0, // is this really needed? lastValidHeight should be enough..?
                            rank: 0, // (temporary, ) locally calculated rank. 
                        },
                        13:{

                        }*/
                    },
                    maxLastValidHeight: 0, // store which was the heighest, last valid height; required in the jumpoff
                    attempt2: 0, // in normal mode==1: 1 to 3; in jumpoff used to announce the i-th jumpoff height
                    attemptNext2: 0, // 1 to 3; for the next athlete (not the current). It is easier to store this value than to (re)calculate it for drawing.
                    
                    currentResultChange: {}, // the result that we are currently changing in the results view 1
                    currentResultString:'',
                    currentResultStringCopy:'',
                    resultKeyPressed: -1, // the key that was pressed last inside a addResult-input. If this is the esc-key, the blur event will not be evaluated. 
                    sortValue1: 1,
                    sortValue2: 2, // default by rank
                    fakeProperty:0, // just needed to make sure that the sortedStart's are updated when the ranks change. (Start Vue's updating process)
                    temporaryDeactivation: false, // just to deactivate parts of the html form being rendered temporarily
                    timeOffset: 0,
                    roomAuxData:{
                        // uses xSeries to reference objects storing the following information:
                        // positionNext:[],
                        // position:[],
                        // attemptPeriod: 60, // s
                        // periodStartTime: undefined, // date-string of the server time when the attempt period started
                        // showAttemptPeriod: false,
                        // currentHeight
                        // currentJumpoffHeightInd
                        // attempt
                        // attemptNext 
                    },
                    autoAdvance: false,
                    attemptTime: "1:00", // TODO: aventually as time instead of string
                    attemptTimeSetting: "00:30",
                    shownTime: "0:00", // shall be string
                    timeUpdateInterval: undefined,
                    last15: false, // last 15 s
                    //currentResultRegistered: false,
                }
            },
            methods:{

                /* !!! methods for both SERIES creation and COMPETITION !!! */

                parseJSON(startConf){
                    if (startConf){
                        return JSON.parse(startConf);
                    }else {
                        return {}
                    }
                },

                statusChanged(){
                    // check whether the current "show" property is meaningful; if not, automatically set a meaningful property
                    const matchStatusShow = [
                        {from: 0, to:39, shows:['rollCall', 'contestInfo']},
                        {from: 60, to:89, shows:['series', 'contestInfo']},
                        {from: 95, to:180, shows:['startheights', 'competition', 'order', 'resMod', 'resShow', 'settings', 'contestInfo']},
                    ]; 
                    const range = matchStatusShow.find(el=>el.from<=this.contest.status && el.to>=this.contest.status);
                    // check if the current selected show makes sense
                    if (range && range.shows.indexOf(this.show)==-1){
                        this.showAuto();
                    }
                },
                showAuto(){
                    // automatically show the most meaningful page when the selected status is changed
                    if (this.contest.status<=39){
                        this.show='rollCall';
                    } else if (this.contest.status<=89 && this.contest.status>=60){
                        this.show = 'series';
                    } else if (this.contest.status<=180 && this.contest.status>=95){
                        this.show = 'competition';
                    }
                },

                statusBackgroundColor(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.backgroundColor;
                    }
                    return '#333333';
                },
                colorHexMultiplier(color, f){
                    // split the hex code into the three parts and multiply it with f
                    let R = Math.min(255,Math.round(f*parseInt(color.slice(1,3),16)));
                    let G = Math.min(255,Math.round(f*parseInt(color.slice(3,5),16)));
                    let B = Math.min(255,Math.round(f*parseInt(color.slice(5,7),16)));
                    return '#' + R.toString(16).padStart(2,0) + G.toString(16).padStart(2,0) + B.toString(16).padStart(2,0);
                },
                statusBackgroundColorHover(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return this.colorHexMultiplier(s.backgroundColor)
                        // split the hex code into the three parts and multiply it with 0.8
                        /*let f = 0.8;
                        let R = Math.round(f*parseInt(s.backgroundColor.slice(1,3),16));
                        let G = Math.round(f*parseInt(s.backgroundColor.slice(3,5),16));
                        let B = Math.round(f*parseInt(s.backgroundColor.slice(5,7),16));
                        return '#' + R.toString(16).padStart(2,0) + G.toString(16).padStart(2,0) + B.toString(16).padStart(2,0);*/
                    }
                    return '#111111';
                },
                statusTextColor(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.textColor;
                    }
                    return status;
                },
                statusText(status, states=this.contestStates){
                    let s = states.find(s=>s.value==status);
                    if (s){
                        return s.text;
                    }
                    return status;
                },

                selectedSeriesChanged(){

                    let u = new URL(window.location.href)
                    u.searchParams.set('xSeries', this.series[this.selectedSeries].xSeries);
                    // this would reload the page
                    // window.location.href = u.href;
                    // this way only the path in the tab should be changed without any reload. 
                    window.history.replaceState(window.history.state, "", u.href)
                    
                },

                /**
                 * returns the index and the object itself of the first object where the property prop is equal to value 
                 * @param {array of objects} arr 
                 * @param {string} prop 
                 * @param {*} val 
                 * @return {array} [index, the object]
                 */
                findObjInArrayByProp(arr, prop, val){
                    for (let i=0; i<arr.length;i++){
                        if (arr[i][prop] == val){
                            return [i, arr[i]];
                        }
                    }
                    return [-1, {}];
                },
                autoManageAuxData(autoSaveToServer=true){

                    // this should all be done now (2022-06) in the room! It is wrong to do this in the view!

                    /*// based on the available series, automatically create (with default values) and delete the auxData per series.
                    // returns true if something has changed (so far 2022-06 not needed)

                    let changed = false;

                    // first make sure, that all currently available auxData have their respective series; otherwise delete them
                    for (let xSeries in this.roomAuxData){
                        let series = this.series.find(s=>s.xSeries==xSeries);
                        if (!series){
                            delete this.roomAuxData[xSeries];
                            changed=true;
                        }
                    }

                    // then check that all available series have also an entry in auxData
                    for (let series of this.series){
                        if (!(series.xSeries in this.roomAuxData)){
                            this.roomAuxData[series.xSeries] = {
                                positionNext:[],
                                position:[],
                                attemptPeriod: 60, // s; mainly related to the next athlete
                                periodStartTime: null, // date-string of the server time when the attempt period started
                                showAttemptPeriod: false, 
                                currentHeight: -1,
                                currentJumpoffHeightInd: -1,
                                attempt: 0,
                                attemptNext: 0,
                            };
                            changed = true;
                        }
                    }
                    
                    if (changed && autoSaveToServer && !this.readOnly){
                        rCTrack.room.updateAuxDataInit(this.roomAuxData);
                    }
                    return changed;*/
                },
                overlayInfo(title, content){
                    this.infoTitle = title;
                    this.infoContent = content;
                    this.infoVisible = true;
                },

                /* !!! methods for SERIES creation only !!! */

                unassignedAthleteChanged(evt){
                    // override the default behavior (add/remove to/from 'displayData' within v-table, which does not work) and add/remove the element instead to/from 'unassignedAthletesCreate'
                    console.log('drag changed');
                    if ('removed' in evt){
                        // remove the element from 'unassignedAthletesCreate'
                        var i = this.unassignedAthletesCreate.indexOf(evt.removed.element);
                        if (i!=-1){
                            // should always come here; remove the element
                            this.unassignedAthletesCreate.splice(i,1);
                        }

                    } else if ('added' in evt){
                        // add the element to 'unassignedAthletesCreate'
                        this.unassignedAthletesCreate.push(evt.added.element.startsingroup)
                    }
                },

                // to make an element a dropzone, it needs the following event handlers:
                // - ondragover
                // - ondrop
                preventDrag(evt){
                    // this is needed on all placeholders to make sure that the click is not propagated to the underlying series (to drag series). This should only be possible around the athletes
                    evt.preventDefault();
                    evt.stopPropagation();
                    evt.stopImmediatePropagation();
                },
                dragOver(element, list, evt){
                    //console.log('dragOver');
                    if (!this.dragged){
                        return false;
                    }
                    // prevent unassigned athlete to be dropped on existing athlet
                    if (this.dragged.replace && (element.startsingroup || list==this.unassignedAthletesCreate)){
                        evt.dataTransfer.dropEffect = "none";
                    } else {
                        evt.dataTransfer.dropEffect = "move";
                    }
                    evt.preventDefault();
                },
                dragEnd(evt){
                    // if we dropped the element, dragged will already be null, since drop-event is fired first
                    console.log('dragEnd')
                    this.dragged=null;
                },
                dragEnter(evt){
                    console.log('dragEnter')
                    if (!this.dragged){
                        return false;
                    }
                    // change color
                    evt.currentTarget.classList.add('swappos');
                    evt.preventDefault();
                },
                dragLeave(evt){
                    console.log('dragLeave')
                    if (!this.dragged){
                        return false;
                    }
                    // this event is called whenever the lowermost element (here: td) is left, and not only when the element with the drag-listener (here: tr) is left; thus, we need to differentiate whether the tr was left or only the td
                    // NOTE: it seems like toElement and fromElement are swapped here
                    // NOTE: this is also called when drop ends over an element, even if dropping is not possible. In that case fromElement is empty (it would make more sense if toElement was empty...). Thus, first make sure both elements exist
                    if (evt.toElement && evt.fromElement && evt.toElement.parentNode!=evt.fromElement.parentNode){
                        // change color
                        evt.currentTarget.classList.remove('swappos');
                    }

                },
                drop(list, index, evt){
                    // do not react on dragged series:
                    if (!this.dragged){
                        return;
                    }
                    console.log('drop');
                    evt.preventDefault();

                    // differentiate different cases
                    // within the same series
                    if (this.dragged.list==list){
                        if (list == this.unassignedAthletesCreate){
                            // do not sort within the unassigned athletes
                            this.dragged=null;
                            return false;
                        }
                        // swap the startsingroup
                        var sig1 = list[index].startsingroup;
                        list[index].startsingroup = this.dragged.element.startsingroup;
                        this.dragged.element.startsingroup = sig1;
                    } else {

                        if (this.dragged.list == this.unassignedAthletesCreate){
                            // unassigned to series
                            // remove in unassigned athletes
                            // NOTE: since the unassignedAthletesCreate can be sorted different from the view, we need to find the index and cannot use the provided index
                            let ind = this.unassignedAthletesCreate.indexOf(this.dragged.element);
                            this.unassignedAthletesCreate.splice(ind,1);

                            // replace placeholder in series
                            list[index].startsingroup= this.dragged.element;

                        } else if (list == this.unassignedAthletesCreate){
                            // series to unassigned

                            // add athlete to unassigned athletes
                            this.unassignedAthletesCreate.push(this.dragged.element.startsingroup)

                            // change the element to a placeholder
                            this.dragged.element.startsingroup=null;

                        } else{
                            // series to series
                            // swap the startsingroup
                            var sig1 = list[index].startsingroup;
                            list[index].startsingroup = this.dragged.element.startsingroup;
                            this.dragged.element.startsingroup = sig1;
                        }


                    }
                    this.dragged = null;
                    evt.currentTarget.classList.remove('swappos');
                    this.updateEmptyInitLanes(this.seriesObj); // needed to recalculate the positions after an invalidated lane was removed
                },
                // same as "drop", but for the series assignment after the initial assignment, where the changes are processed in the room
                drop2(list, evt, element){
                    // do not react on dragged series:
                    if (!this.dragged){
                        return;
                    }
                    console.log('drop');
                    evt.preventDefault();

                    // Note: we cannot store unassignedAthetes/series.SSRs as a list as we do in the init rooms, since unassignedAthletes/series.SSRs is a computed property (i.e. has no proxy) and Vue.js does not realize that and proxies the data when we store it to vue.data (in dragStart). Thus, the list is not stored as a list, but as a string ('unassignedAthletes') or as an integer (xSeries).

                    // differentiate different cases
                    if (this.dragged.list==list){
                        // within the same series
                        if (list == "unassignedAthletes"){
                            // do not sort within the unassigned athletes
                            this.dragged=null;
                            return false;
                        }

                        let data = {
                            series1: this.dragged.element.seriesOriginal, 
                            series2: this.dragged.element.seriesOriginal,
                            SSR1: this.dragged.element.ssrOriginal,
                        }

                        // swap the startsingroup
                        // differentiate whether it is swapped with an empty lane or not!
                        if (element.startsingroup == null){
                            // with empty lane
                            data.position = element.position;
                            data.lane = element.lane;
                        } else {
                            // with another athlete
                            data.SSR2 = element.ssrOriginal;
                        }

                        rCTrack.room.swapPositionInit(data);
                        
                    } else {

                        if (this.dragged.list == "unassignedAthletes"){
                            // unassigned to series
                            // remove in unassigned athletes not needed, since this is a computed property

                            // get the series object
                            let series = this.series.find(s=>s.xSeries == list);

                            rCTrack.room.addSSRInit(series, this.dragged.element.xStartgroup, element.position, element.lane);


                        } else if (list == "unassignedAthletes"){
                            // series to unassigned

                            // add athlete to unassigned athletes
                            rCTrack.room.deleteSSRInit(this.dragged.element.seriesOriginal, this.dragged.element.ssrOriginal);

                        } else{
                            // series to series
                            // nearly the same code as for swap within a series
                            // swap the startsingroup
                            
                            let data = {
                                series1: this.dragged.element.seriesOriginal, 
                                series2: this.series.find(s=>s.xSeries == list),
                                SSR1: this.dragged.element.ssrOriginal,
                            }

                            // swap the startsingroup
                            // differentiate whether it is swapped with an empty lane or not!
                            if (element.startsingroup == null){
                                // with empty lane
                                data.position = element.position;
                                data.lane = element.lane;
                            } else {
                                // with another athlete
                                data.SSR2 = element.ssrOriginal;
                            }

                            rCTrack.room.swapPositionInit(data);
                        }


                    }
                    this.dragged = null;
                    evt.currentTarget.classList.remove('swappos');
                    this.updateEmptyInitLanes(this.seriesObj); // needed to recalculate the positions after an invalidated lane was removed
                },
                dragStart(list, element, index, evt, replace=false){
                    // set replace to true for 
                    // - drag elements in unassignedAthletes
                    // - invalid lanes (e.g. when the number of persons per lane or the number of lanes gets reduced after persons were assigned)
                    console.log('dragStart');
                    // since we must know later, what vue data (and not only which html-element) was dragged, we must keep that record
                    this.dragged = {list, element, index, replace}; // if replace is false, swap is used
                    // prevent that also the series (drag element on the parent) will change
                    evt.stopPropagation();
                },

                changeOnSeries(evt, series, index){
                    console.log(`ath changed in series`);
                    console.log(evt);

                    if ('added' in evt && !("lane" in evt.added.element)){
                        // if the element was actually from the unassigned athletes, we have to make sure it is a correct object for the present list
                        // overwrite the default behavior
                        this.seriesObj[index].SSRs[evt.added.newIndex] = {
                        //series.SSRs[evt.added.newIndex] = {
                            lane: 0,
                            alert: 0,
                            posInLane:0,
                            position: 0,
                            startsingroup: evt.added.element,
                        }
                    }
                    this.updatePositions(series);
                    return true;
                },
                siteChanged(series, evt){
                    // called e.g. when the time or the site was changed
                    if (evt.target.value===null || evt.target.value=='null'){
                        rCTrack.room.updateSeriesInit(series, 'xSite', null);
                    } else {
                        rCTrack.room.updateSeriesInit(series, 'xSite', parseInt(evt.target.value));
                    }
                },
                dateChanged(series, evt){
                    rCTrack.room.updateSeriesInit(series, 'datetime', (new Date(evt.target.value).toISOString()));
                },
                initSeriesChanged(evt){
                    // make sure that again the number of the series as well as the default times are correct
                    for (let h=1; h<= this.seriesObj.length; h++){
                        this.seriesObj[h-1].number = h;
                        this.seriesObj[h-1].datetime = this.getStarttime(h);
                    }
                },
                seriesStateChanged(evt){
                    // not needed for series assignment
                },
                presentChanged(affectedRow){
                    // the present status of an athlete was changed. Hand over the request to the room. 
                    rCTrack.room.updatePresentStateInit(affectedRow);
                },
                startUpdateConf(){
                    this.confForMod = this.parseConf(this.contest.conf);
                    this.overlay3 = 'config';
                },
                abortUpdateConf(){
                    this.overlay3 = undefined;
                },
                saveUpdateConf(){
                    this.overlay3 = undefined;
                    this.propagateChange = true; // store the change to server!
                    this.contest.conf = JSON.stringify(this.confForMod);
                    this.updateEmptyInitLanes(this.seriesObj);
                },
                startInLanesChanged(){
                    if (this.confForMod?.startInLanes===false){
                        // set the value for the group size to the default of the default-site
                        this.confForMod.groupSize = this.defaultSiteConf?.heatSizeRuns ?? 26;
                    } else if (this.confForMod?.startInLanes===true){
                        this.confForMod.groupSize = 1;
                    }
                },
                parseConf(jason){
                    // a valid JSON must contain {} or []; an empty string, as it might occur in the DB as a default, is not valid!
                    let conf;
                    try{
                        conf = JSON.parse(jason);
                    }catch(ex){
                        conf = {};
                    }
                    // make sure that the reuired stuff is present
                    if (!('groupSize' in conf)){
                        logger.log(2, 'GroupSize not in the contest configuration.')
                        conf.groupSize = 1;
                    }
                    if (!('startInLanes' in conf)){
                        logger.log(2, 'StartInLanes not in the contest configuration.')
                        conf.startInLanes = true;
                    }
                    return conf;
                },
                getCategory(xCategory, property='shortname'){
                    let cat = this.categories.find(c=>c.xCategory==xCategory)
                    if (cat){
                        return  cat[property]
                    } else {
                        return '';
                    }
                },
                getYearShort(dateString){
                    let d = new Date(dateString);
                    return d.getFullYear().toString().slice(-2);
                },
                endRollCallCreateSeries(){
                    this.propagateChange = true;
                    this.contest.status = 70;
                    this.show="series";
                    if(this.series.length==0){
                        this.showInitialSeriesAssignment();
                    }
                },
                formatPerf(heightInDB){
                    if (heightInDB){
                        return window.disciplineFormatters[3](heightInDB, this.discipline, true);
                    }

                    return "";
                },
                formatTime(time, dateIfNeeded=true, secondsIfNeeded=true){
                    // return a formatted time value.
                    // if dateFrom=dateTo, only return the time; otherwise include the portion of date needed.
                    // if seconds are given, include them
                    let s = '';
                    let d = new Date(time);
                    if (dateIfNeeded && this.meeting.dateFrom != this.meeting.dateTo){
                        s += (d.getMonth()+1).toString().padStart(2,0);
                        s += "." + d.getDate().toString().padStart(2,0) + ' ';
                    }
                    s += `${d.getHours()}`.padStart(2, '0');
                    s += ":" + `${d.getMinutes()}`.padStart(2,'0');
                    if (secondsIfNeeded && d.getSeconds() != 0){
                        s += ':' + `${d.getSeconds()}`.padStart(2,'0');
                    }

                    return s;

                },
                showInitialSeriesAssignment(){
                    // create a list of all unassigned athletes for the initial series assignment. This is a separate list from the unassignedAthletes for the base configuration
                    this.resetInitialSeriesAssignment()
                    
                    this.overlay2 = 'createSeries';
                },
                updatePositions(seriesObj2){
                    // update the position (and lane) values if not startInLanes
                    if (this.conf.startInLanes){
                        return;
                    }
                    
                    // simply loop over the series and recreate all positions and lanes
                    for (let i=0; i < seriesObj2.SSRs.length; i++){
                        const ssr = seriesObj2.SSRs[i];
                        ssr.lane = i+1;
                        ssr.position = i+1;
                        ssr.posInLane = 1;
                    }
                },
                updateEmptyInitLanes(seriesObj2){
                    // called e.g. after the number of lanes/groupSize/startInLanes have changed, when a new series is added, when an seriesStart is added or deleted,

                    // there is nothing to do when the contest is not started in lanes
                    if (!this.conf.startInLanes){
                        return;
                    }
                    
                    for (let heat of seriesObj2){
                        // every startsingroup/seriesStartResult-object should look like this:
                        // {position, lane, posInLane, startsingroup, alert}

                        // first, delete unnecessary empty lanes or mark filled lanes with alert=1
                        for (let iLane=heat.SSRs.length-1; iLane>=0; iLane--){
                            const lane = heat.SSRs[iLane];
                            if (lane.lane>this.conf.lanes || lane.posInLane>this.conf.groupSize){
                                // empty lanes can be deleted, occupied ones must be marked with alert=1
                                if (lane.startsingroup){
                                    lane.alert=1;
                                } else {
                                    heat.SSRs.splice(iLane, 1);
                                }
                            } else {
                                lane.alert = 0;
                            }
                        }

                        // add missing lanes:
                        for (let iLane = 1; iLane<=this.conf.lanes; iLane++){
                            for (let iPosInLane = 1; iPosInLane<=this.conf.groupSize; iPosInLane++){
                                // try to find the lane; if not, add an empty one
                                if (!heat.SSRs.find(ssr=>ssr.lane==iLane && ssr.posInLane == iPosInLane)){
                                    heat.SSRs.push({
                                        position: 0,
                                        lane: iLane,
                                        alert: 0,
                                        posInLane: iPosInLane,
                                        startsingroup: null,
                                    })
                                } 
                            }
                        }

                        // sort the elements (important: this must be done before the next step!)
                        heat.SSRs.sort((lane1, lane2)=>{
                            if (lane1.lane != lane2.lane) return lane1.lane-lane2.lane;
                            if (lane1.posInLane != lane2.posInLane) return lane1.posInLane - lane2.posInLane;
                            return 0
                        })

                        // finally update the positions (Note: this cannot be done earlier, since the positions must also consider invalidated lanes and added lanes). Empty lanes get the position value of the next occupied lane, since this is what is needed to add a person between another.
                        // at the same time: check whether there are empty lanes between occupied lanes
                        // add alert=2 to those SSRs
                        let position = 1;
                        let firstOccupied = -1;
                        let lastOccupied;
                        let empty = []
                        for (let iLane=0;iLane< heat.SSRs.length; iLane++){
                            const lane = heat.SSRs[iLane];
                            lane.position = position; // before 2022-12-19 position was always incresed here; now we only increase the position of the lane is occupied.
                            if (lane.startsingroup){
                                position++;
                                lastOccupied = iLane;
                                if (firstOccupied<0){
                                    firstOccupied = iLane;
                                }
                            } else {
                                // reset alert here, since the non-empty lanes are already defined and should not be overwritten
                                lane.alert = 0;
                                empty.push(iLane)
                            }
                        }
                        for (let emptyLane of empty){
                            if (emptyLane>firstOccupied && emptyLane<lastOccupied){
                                heat.SSRs[emptyLane].alert=2;
                            }
                        }

                    }
                },
                /**
                 * n: the number of the series 
                 **/
                getStarttime(n){
                    const d = new Date(this.contest.datetimeStart);
                    // set a reasonable default value! Must change when the order of series changes
                    let datetime = new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds() + this.disciplineConfiguration.heatInterval*(n-1));
                    return datetime;
                },
                addEmptySeriesInitial(){
                    // add an empty series to the seriesObj used in the inital series configuration tool
                    let xSite = this.defaultSite?.xSite ?? null;
                    this.seriesObj.push({
                        number: this.seriesObj.length+1, 
                        xSite: xSite, 
                        status: 10, 
                        name: '', 
                        datetime: this.getStarttime(this.seriesObj.length+1), 
                        SSRs:[], // will be filled by updateEmptyInitLanes
                    });
                    this.updateEmptyInitLanes(this.seriesObj);
                },
                resetInitialSeriesAssignment(){
                    // recreate the set of unassigned athletes (=all startingroup where present=true): 
                    this.unassignedAthletesCreate = this.startgroups.filter(el=>el.present);

                    // delete all current series:
                    this.seriesObj = [];
                },
                createSeriesAutomatically(){
                    // first, reset current series
                    this.resetInitialSeriesAssignment();

                    // use selected algorithm to do automatic assignment
                    this.seriesAssignments[this.selectedSeriesAssignment].assignFunc.bind(this)()

                    // hide the overlay
                    this.overlay=undefined;
                    
                    // activate the ok button
                    //this.$refs["saveInitSeries"].focus();
                },
                saveInitSeries(){
                    // save the initial series assignment
                    
                    // TODO: manually populate the actual series object; as soon as the change is processed on the server, the IDs will be replaced here with the actual IDs. 
                    // DIFFICULTY: Assume a client without connection, a series is (locally) generated, then it is deleted again. As soon as we have connection, the changes are sent to the server. However, the answer for the series creation cannot be processed completely, because the series was deleted meanwhile in the local data. HOW CAN THIS PROBLEM BE SOLVED?:
                    // IDEA 1: fail-safe programming. If an object does not exist anymore, simply do not care and just continue. This only works when we do not try to know, what element must be updated on data arrival via e.g. the series number, when we have a unique identifier, e.g. a temporary ID or we have function where the objects are referenced (not the position in the array or the array itself!)
                    
                    // The series structure should look like this
                    // series : all series objects
                    // series[0].seriesstartsresults : all athletes in this series

                    // since the number of the series is not changed on moving the series, we must do it here
                    for (let i=1; i<=this.seriesObj.length; i++){
                        this.seriesObj[i-1].number = i;
                    } 

                    // do all the data managament in the room and not within vue!
                    rCTrack.room.initialSeriesCreationInit(this.seriesObj);

                    this.overlay2 = undefined;

                    return false; // avoid reload of the page

                },
                deleteSeries(xSeries){
                    rCTrack.room.deleteSeriesInit(xSeries);
                    this.yesNoVisible = false;
                    //this.showTimeUpdate();
                },
                initDeleteSeries(series){
                    this.yesNoTitle = '<%= __("Delete heat") %>';
                    this.yesNoText = `<%= __("Do you want to delete heat ${series.number}?") %>`;
                    this.yesNoFunction = ()=>{
                        this.deleteSeries(series.xSeries);
                    }
                    this.yesNoVisible = true;
                },
                addSeries(){
                    // add an empty series
                    let xSite = null
                    if (this.defaultSite){
                        xSite = this.defaultSite.xSite;
                    }
                    rCTrack.room.addSeriesInit(xSite, this.getStarttime(this.series.length+1));
                },
                deleteAllSeriesInit(){
                    // show warning
                    this.yesNoVisible = true,
                    this.yesNoText = '<%= __("Delete all series") %>';
                    this.yesNoTitle = `<%= __("Do you really want to delete all series? This can't be undone.") %>`;
                    this.yesNoFunction = this.deleteAllSeries;
                    
                },
                deleteAllSeries(){
                    this.yesNoVisible=false;
                    // the room functiuon will also change the local data
                    rCTrack.room.deleteAllSeriesInit();
                },
                moveSeries(evt){
                    // called, when series are reordered
                    // no differentiation needed between moved/added/removed, since only move is possible; 

                    // Note: evt.moved.element is NOT the series-element in data.series, since we work on a copy seriesAsStartgroups
                    rCTrack.room.moveSeriesInit(evt.moved.oldIndex, evt.moved.newIndex)

                    this.showTimeUpdate();
                },
                showTimeUpdate(){

                    // show a window to update the starttimes
                    this.heatInterval = this.disciplineConfiguration.heatInterval;
                    this.overlay = 'timeUpdate';

                },
                updateHeatStarttimes(){
                    rCTrack.room.updateHeatStarttimesInit(this.heatInterval);

                    this.overlay = undefined;
                },
                removeSSR(evt){
                    if ("added" in evt){
                        rCTrack.room.deleteSSRInit(evt.added.element.seriesOriginal, evt.added.element.ssrOriginal)
                    }
                    // nothing to do when removed or moved; removed is handled in the add event of the series and moving within the unassignedAthletes is useless, since it is done via the sortable table.
                },
                changePosition(series, evt){
                    // this function is responsible for:
                    // - moving athletes within series
                    // - moving athletes beyond series
                    // - newly assign athletes to a series
                    // --> unassign athletes is handled in "removeSSR"! 

                    // if an athlete is moved from one series to another, the function is called in both series, once with "removed" and once with "added" as the argument; if it is within the same series, then with "moved"
                    // evt .element .newIndex .oldIndex

                    if ("removed" in evt){
                        // if we do the work in added, we  do not need to do anything in removed, since the data will already be gone.
                        // the opposite way around is not possible, since it would not be known where to move the element to.
                    } else if ("added" in evt){

                        // differentiate whether the element is a seriesstartsresult or an xStartgroup (i.e. unassignedAthlete)
                        if ("athleteName" in evt.added.element){
                            // previously was an unassigned athlete
                            // create seriesstartsresults
                            rCTrack.room.addSSRInit(series.seriesOriginal, evt.added.element.xStartgroup, evt.added.newIndex+1, evt.added.newIndex+1);
                        } else {
                            // athlete moved from one series to another; data is a seriesstartsresults entry
                            // hand over all needed references to the original, referenced objects. Make sure the room stays independent from the copied series structure within 
                            // let the room do the rest
                            rCTrack.room.changePositionInit(evt.added.element.ssrOriginal, evt.added.element.seriesOriginal, series.seriesOriginal, evt.added.newIndex+1);
                        }

                    } else if ("moved" in evt){
                        // hand over all needed references to the original, referenced objects. Make sure the room stays independent from the copied series structure within 
                        // let the room do the rest
                        rCTrack.room.changePositionInit(evt.moved.element.ssrOriginal, evt.moved.element.seriesOriginal, series.seriesOriginal, evt.moved.newIndex+1);
                    }
                    
                },

                /* !!! methods for COMPETITION only !!! */

                transferAuxData(){
                    // manually transfer some of the aux properties (position and positionNext are transferred in calculateNextAthlete)
                    // this is needed when the positionNext and position do not change (when a change arrives on reading clients), because normally those properties are transferred there
                    /*this.currentHeight2 = this.roomAuxDataSelected.currentHeight;
                    this.currentJumpoffHeightInd2 = this.roomAuxDataSelected.currentJumpoffHeightInd;
                    this.attempt2 = this.roomAuxDataSelected.attempt;
                    this.attemptNext2 = this.roomAuxDataSelected.attemptNext;*/

                },

                setTime(){
                    // set the time for the attempt period and show it

                    // split the time between hours (here: minutes) and minutes (here: seconds)
                    let t = this.attemptTimeSetting.split(':');
                    let minutes = Number(t[0])
                    let seconds = Number(t[1])
                    if (isNaN(minutes) || isNaN(seconds)){
                        alert('Time is not valid')
                    } else {
                        this.roomAuxDataSelected.attemptPeriod = minutes*60+seconds;

                        this.roomAuxDataSelected.showAttemptPeriod = true;
                        this.roomAuxDataSelected.periodStartTime = null;

                        rCTrack.room.updateAuxDataInit(this.roomAuxData);
                    }
                    this.updateShownTime();

                },
                birthdayToXX(bd){
                // convert the birthday to a two letter year code
                    return bd.substr(2,2);
                },
                getStartByXSeriesStart(xSeriesStart){
                    //return this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart == xSeriesStart)
                    // TODO: revert this, since it is only for debugging
                    let x = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart == xSeriesStart)
                    if (!x){
                        //alert('could not find the athlete!');

                        // TODO: this is NOT a solution, since the returned object is also used to reference xStartgroup, which will fail with this default, non.existing value 
                        return {
                            xSeriesStart: xSeriesStart,
                            xStartgroup: -1,
                            xSeries: -1,
                            position: -1,
                            resultOverrule: 0,
                            resultRemark:'',
                            qualification: 0,
                            startConf: '',
                        }

                    }
                    return x; 
                },
                sortAthletes(seriesIndex){
                    /* this must be the only sort function run on the seriesstartsresults! They need to keep this order all the time. */
                    this.series[seriesIndex].seriesstartsresults.sort((el1, el2)=>{
                        return el1.position-el2.position;
                    })
                },
                sortAthletesAllSeries(){
                    for (i=0;i<this.series.length;i++){
                        this.sortAthletes(i);
                    }
                },
                

                
                
                replaceXResult(xSeriesStart, oldKey, newKey){
                    alert('TODO')

                    // replace the old key by the new key
                    // TODO

                    // if the result is currently changed, we need to change the key of the input element there, as it will be invalid afterwards otherwise
                    let el = document.getElementById('resChange' + oldKey)
                    if (el){
                        el.id = 'resChange' + newKey;
                    }
                },
                updateSSR(ssr){
                    // send the change to the server
                    rCTrack.room.updateSSRInit(ssr);

                },

                calculateTemporaryRankingData(){
                    // still needed?

                },
                calculateNextAthlete(){

                    // Jumpoff: 
                    /*
                    - the jupoff does not necessary take place --> is defined in the jumpoff-variable
                    - ranking in jumpoff: retired athletes are last, in the order of their retiring (i.e. 3 athletes in jumpoff, one retires at the beginning (--> rank 3), the second retires after three more heights (--> second rank) while tha last would continue (--> rank 1))
                    - attention: it is possible that all athletes retire at the same time at any time in the competition. Then all are ranked first. 
                    - the ranking should only be done after a height is jumped by all athletes in the jumpoff (in order to avoid that eventually one person is temporary ranked second, if he still has the chance to be in competition afterwards!)
                    - ranking the following way: (1) more valid is better; (2) more failed is better (i.e. the athlete retired later; only used when >2 athletes in jumpoff)
                    Note: if all athletes want to withdraw, the last withdrawel has to be made in the change-result section; until then, the remaining person is declared the winner.
                    */

                    //this.currentResultRegistered = false;

                    let series = this.series[this.selectedSeries];

                    // if the selectedSeries changes, we must reset position and positionNext to make sure the algorithm trying to alter the position array as little as possible when athletes are added or removed works as it should. 
                    if (this.selectedSeries != this.selectedSeriesLazy) {
                        this.position = [];
                        this.positionNext = [];
                    }

                    // if the series is empty or no series exists yet (or the pre-"selected" series does not exist), do not start the subsequent calculation!
                    if (!series || series.seriesstartsresults.length==0){
                        this.mode=0;
                        return
                    }

                    // check if all startheights are given
                    if (this.allStartHeightsDefined()){

                        // TODO: eventually we should determine the mode automatically as well..? This would also imply changes in calculateTemporaryRankingData

                        // change the mode to competition running, if it was at 'define startheigts' before. (This check is needed since otherwise it would leave jumpoff!) 
                        if (this.mode==0){
                            this.mode=1;
                        }

                        // the currentHeight is calculated automatically:

                        // find the lowest height, where an athlete is in competition (min(nextJumpingHeight)) (neither retired nor DQ nor DNS...) or get the next height after the last valid height of an athlete. 

                        this.calculateTemporaryRankingData();

                        // for athletes that are not yet in competition (no results), get the startheight; for athletes that are in competition, use the lower of lastFinistedHeight+next and firstUnfinished
                        let lowestUnfinished = 1000; // here we can also include the startheight of athletes that were not in competition yet
                        let lowestFinishedDefault = 1000;
                        let lowestFinished = lowestFinishedDefault; // to calculate the next height after this

                        // calculate some Jumpoff-stuff within the same loop
                        let numJumpoffParticipants = 0;
                        let nextJumpoffHeightInd = 1000; // the index in the jumpoffResults-Array represnting the jumping height th next athlete is doing. It is not necessarily the next coming height, e.g. when a few athletes already jumped on that height, while at least one has not.

                        let mainCompetitionFinished = true;
                        series.seriesstartsresults.forEach(start=>{

                            let tmp = this.tempRankingData[start.xSeriesStart];
                            if (!tmp.finished){

                                mainCompetitionFinished = false;

                                // athlete is still in competition
                                if (start.resultshigh.length){
                                    if (tmp.firstUnfinishedHeight){ // might be undefined, when there is no unfinished height
                                        lowestUnfinished = Math.min(lowestUnfinished, tmp.firstUnfinishedHeight);    
                                    }
                                    if (tmp.lastFinishedHeight){ // undefined when there is no finished height yet
                                        // at least one height is finished for this athlete
                                        lowestFinished = Math.min(lowestFinished, tmp.lastFinishedHeight);
                                    }
                                    
                                } else {
                                    // no result yet; use the startheight
                                    lowestUnfinished = Math.min(lowestUnfinished, start.startConf);
                                }
                            }
                            if(tmp.finished && tmp.rank==1) {
                                // finished, and rank 1 --> currently part of the jumpoff
                                numJumpoffParticipants += 1;

                                // get the next height in the jumpoff:
                                if (nextJumpoffHeightInd>tmp.jumpoffResults.length && tmp.jumpoffFailedAtI==10000){
                                    nextJumpoffHeightInd=tmp.jumpoffResults.length+1;
                                }
                            }
                            if (tmp.jumpoffResults.length>0){
                                // if an older jumpoffResult is deleted (which should NOT be done!), it would create a hole (<empty>) in the jumpoffResults --> in that case, the currentJumpoffHeight would be the first empty element in the array!
                                let firstUndef = tmp.jumpoffResults.findIndex(val=>val==undefined);
                                if (firstUndef>=0 && nextJumpoffHeightInd>firstUndef){
                                    nextJumpoffHeightInd = firstUndef;
                                    console.log('There was a jumpoff-height missing. This should not happen, since parts of the code might not work as expected in that case.')
                                    // then we might also have to add this person to the count of the number of participants in the jumpoff:
                                    if (!(tmp.finished && tmp.rank==1)){
                                        numJumpoffParticipants++;
                                    }
                                }
                            }


                        })

                        // when the competition is over, stop here (the rest is not needed and would not work appropriately)
                        if (mainCompetitionFinished){
                            if (numJumpoffParticipants>1 && this.conf.jumpoff){
                                this.mode = 2;
                            } else {
                                this.mode = 3;
                                this.positionNext = [];
                                this.position = [];
                                return; // dont need to continue when the competition is over
                            }
                        } else {
                            this.mode = 1;
                        }

                        if (this.mode==1){

                            let newCurrentHeight;
                            if (lowestFinished == lowestFinishedDefault){
                                // nothing finished yet, thus always lowestUnfinished is governing
                                newCurrentHeight = lowestUnfinished;
                            } else {
                                // the current height is the minimum of: lowestUnfinishedHeight and the next height after the lowestFinishedHeight
                                let i = this.allHeights.indexOf(lowestFinished);
                                let lowestNextHeight = this.allHeights[i+1];
                                
                                newCurrentHeight = Math.min(lowestNextHeight,lowestUnfinished)
                            }

                            // get/create the height-element (it is actually not needed later)
                            let hEl = series.heights.find(h=>h.height==newCurrentHeight && h.jumpoffOrder==0);
                            
                            if (!hEl){
                                if (!this.readOnly){
                                    // create the height, as it does not exist yet
                                    this.addHeight(newCurrentHeight);
                                    hEl = series.heights.find(h=>h.height==newCurrentHeight && h.jumpoffOrder==0);
                                } else {
                                    // cannot continue for teh moment, since the heigght is not available and we cannot create it. The server will soon send the new height and we can continue past here.
                                    return;
                                }
                            }

                            // calculate the new position and positionNext arrays; however, do NOT directly store them to this, but do this copy at the end, based on whether this client is writing or not!
                            let position=[], positionNext=[];
                            if (newCurrentHeight != this.currentHeight2){
                                // the currentHeight has changed! We must a.o. recreate the positions array
                                this.currentHeight2 = newCurrentHeight;

                                // if the currentHeight changes:
                                // 2022-03: I think the following paragraph is wrong. I indeed implemented an algorithm to find the bast position and add the athlete there!
                                // OLD: 
                                // as it is hardly possible to transfer the different order in 'positions' compared to the default given in sSeriesStart, the position is always resetted to the default. 
                                // WHY is is hardly possible: The positions array always stores, who is still in competition on the current height (i.e. not overall). That means at the end, it will finally only contain the very last athlete, as all the others either failed 3 times or have a valid result already. Now we could think of not removing the elements from the array when the athlete do not jump on this height anymore, which would make transferring the changed order much simpler. However, if the user wants to change the order on the current height e.g. in the second attempt, then it would be strange if also athletes would appear that have passed already in the first attempt.

                                // position gives the current (during this height) order of athletes; create this array from scratch:

                                // find out what athletes are starting on this height: not finished, startheight <= currentHeight, has not finished this height yet
                                // first add all starts to the following array, before creating the final position array (TODO: or should we keep the array with the full data? I'm a bit worried because of the observers bound to the object for Vue...)
                                let starts = [];
                                series.seriesstartsresults.forEach(el=>{
                                    if (el.startConf <= this.currentHeight2 && !this.tempRankingData[el.xSeriesStart].finished && (this.tempRankingData[el.xSeriesStart].lastFinishedHeight === undefined || this.tempRankingData[el.xSeriesStart].lastFinishedHeight < this.currentHeight2)){
                                        starts.push(el);
                                    }
                                })

                                // sort the starts
                                starts.sort((a,b)=>{
                                    return a.position-b.position
                                })

                                // derive the position array
                                position = []; 
                                starts.forEach(el=>position.push(el.xSeriesStart));
                            } else {
                                // update the position array, without recreating it from default in order not to lose the current changes to it. 
                                // check for every athlete that should jump on the current height whether he is in the position array or not; finally delete all those entries that are not jumping (anymore)
                                let posCopy = this.position.slice(); 
                                position = this.position.slice();

                                series.seriesstartsresults.forEach(el=>{
                                    if (el.startConf <= this.currentHeight2 && !this.tempRankingData[el.xSeriesStart].finished && (this.tempRankingData[el.xSeriesStart].lastFinishedHeight === undefined || this.tempRankingData[el.xSeriesStart].lastFinishedHeight < this.currentHeight2)){
                                        
                                        let ind = this.position.findIndex(el2=>el2==el.xSeriesStart)
                                        if (ind == -1){
                                            // start must be added on the best position!
                                            // first create an array with the default positions of the athletes in the current positions-list
                                            let positionDefault = Array(this.position.length);
                                            for (let i=0;i<this.position.length;i++){
                                                let start = this.series[this.selectedSeries].seriesstartsresults.find(el=>el.xSeriesStart==this.position[i])
                                                if (!start){
                                                    alert('Error: Something went terribly wrong.');
                                                }
                                                positionDefault[i] = start.position;
                                            }

                                            // go through the possible positions (number of positions: position.length+1)
                                            // best position is where most of the athletes would be correctly before and after according to the position default
                                            let minSortedWrong = this.position.length+10;
                                            let minSortedWrongIndex = -1;
                                            for (let i=0; i<=this.position.length;i++){
                                                let sortedWrong = 0;
                                                // before:
                                                for (let j=0;j<i;j++){
                                                    if (positionDefault[j]>el.position){
                                                        sortedWrong++;
                                                    }
                                                }
                                                // after: 
                                                for (let j=i;j<this.position.length; j++){
                                                    if (positionDefault[j]<el.position){
                                                        sortedWrong++;
                                                    }
                                                }
                                                if (sortedWrong<minSortedWrong){
                                                    minSortedWrong = sortedWrong;
                                                    minSortedWrongIndex = i;
                                                }
                                            }

                                            // add the element at the best position
                                            position.splice(minSortedWrongIndex,0,el.xSeriesStart);

                                        } else {
                                            // remove from posCopy
                                            let ind = posCopy.indexOf(el.xSeriesStart);
                                            if (ind==-1){
                                                alert('Error: Should not happen...');
                                            }else{
                                                posCopy.splice(ind,1);
                                            }
                                        }
                                    }
                                })

                                // delete all elements in position that are still in posCopy
                                posCopy.forEach(el=>{
                                    let ind = position.indexOf(el);
                                    position.splice(ind,1);
                                })
                                // done.

                            }


                            // find out which athlete is the next
                            // 1. find out the minimum number of failed attempts
                            let minFailedAttempts = 10;
                            let minFailedAttemptsCount = 0; // how many times this number of attempts appeared
                            position.forEach(xSeriesStart=>{
                                // get the corresponding start
                                let start = series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart);

                                // get the correspnding height result (if there is one! --> otherwise minFailedAttempts is zero!)
                                let hAth = start.resultshigh.find((el)=>{
                                    h = series.heights.find(hEl=>el.xHeight==hEl.xHeight); // if everything is correct, must always find an element
                                    if (h===undefined){
                                        alert('ERROR: Should never be here. Could not find the corresponding height for a given xHeight.');
                                        throw('ERROR: Should never be here. Could not find the corresponding height for a given xHeight.');
                                        
                                    }
                                    return h.height==this.currentHeight2;
                                })
                                if (hAth===undefined){
                                    if (minFailedAttempts==0){
                                        minFailedAttemptsCount++;
                                    }else{
                                        minFailedAttempts=0;
                                        minFailedAttemptsCount=1;
                                    }
                                }else{
                                    if (minFailedAttempts>hAth.resultsHighFailedAttempts){ 
                                        minFailedAttempts=hAth.resultsHighFailedAttempts;
                                        minFailedAttemptsCount=1;
                                        
                                    }else if(minFailedAttempts == hAth.resultsHighFailedAttempts){
                                        minFailedAttemptsCount++;
                                    }
                                }

                            })
                            // now we know what attempt we are in (--> minFailedAttempts+1)
                            this.attempt2 = minFailedAttempts+1;
                            this.attemptNext2 = minFailedAttemptsCount>1 ? minFailedAttempts+1 : minFailedAttempts+2;

                            // now, create the order of the next athletes (positionNext):

                            
                            // OLD:                             
                            //if ((!this.readOnly) || positionNext.length==0){
                            // NEW: 
                            if (true){
                                // get the first athlete where minFailedAttempts == hEl.resultsHighFailedAttempts
                                let currentAthlete = -1;
                                // reinitialize the positionNext array
                                positionNext = Array(position.length);
                                let n = 0;
                                for (let a = minFailedAttempts; a<3; a++){
                                    for (let i=0;i<position.length;i++){
                                        // check for every athlete in the order of the position array, if failed attempt == a; then he starts as n'th athlete from now.
                                        let xSeriesStart = position[i];

                                        // get the corresponding start
                                        let start = series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart);
                                        // get the correspnding height result (if there is one! --> otherwise minFailedAttempts is zero!)
                                        let hAth = start.resultshigh.find((el)=>{
                                            h = series.heights.find(hEl=>el.xHeight==hEl.xHeight); 
                                            return h.height==this.currentHeight2;
                                        })
                                        if (hAth==undefined){
                                            if (minFailedAttempts != 0){
                                                alert ("Error: Should never get here!");
                                            } else {
                                                // if hAth is undefined, then the athlete has no result yet on this height, i.e. his resultsHighFailedAttempts=0
                                                if (a==0){
                                                    positionNext[n] = i;
                                                    n++;
                                                }
                                            }
                                        }else {
                                            if (hAth.resultsHighFailedAttempts==a){
                                                positionNext[n] = i
                                                n++;
                                            }
                                        }
                                    }
                                }
                                if (n != position.length){
                                    alert('Error: something went wrong in this loop.. :-(( The order of next athletes might be wrong.')
                                } 
                            } 

                            //
                            if (this.readOnly){
                                // we actually do not use the position and positionNext data that we just have created, but we use the data that was given via the aux data. But we compare the length of the array in order to detect problems (which should never happen.)
                                if (position.length != this.roomAuxData[series.xSeries].position.length || positionNext.length != this.roomAuxData[series.xSeries].positionNext.length){
                                    console.log('Note: the number of athletes jumping on the current height was calculated differently by this browser than given by the data from the server. This may regulary hapen when the result has already arrived on reading clients, but not the new aus data. If this happens in other constellations, please report the constellation, where this happened, to the developers.')
                                }
                                this.positionNext = this.roomAuxData[series.xSeries].positionNext.slice(); // we use slice to create a copy!
                                this.position = this.roomAuxData[series.xSeries].position;

                                //this next part should not be needed anymore
                                /*this.currentHeight2 = this.roomAuxData[series.xSeries].currentHeight;
                                this.currentJumpoffHeightInd2 = this.roomAuxData[series.xSeries].currentJumpoffHeightInd;
                                this.attempt2 = this.roomAuxData[series.xSeries].attempt;
                                this.attemptNext2 = this.roomAuxData[series.xSeries].attemptNext;*/

                            } else {
                                // writing client. Set position and positionNext. If they have changed, send the changes to the server.
                                if (JSON.stringify(this.position) != JSON.stringify(position) || JSON.stringify(this.positionNext) != JSON.stringify(positionNext) || this.roomAuxData[series.xSeries].currentHeight != this.currentHeight2 || this.roomAuxData[series.xSeries].currentJumpoffHeightInd != this.currentJumpoffHeightInd2 || this.roomAuxData[series.xSeries].attempt != this.attempt2 || this.roomAuxData[series.xSeries].attemptNext != this.attemptNext2) {
                                    this.autoManageAuxData(false);
                                    this.roomAuxData[series.xSeries].positionNext = positionNext;
                                    this.roomAuxData[series.xSeries].position = position;

                                    // additionally propagate the following properties to all clients (this is especially needed when the site is reloaded after the result is entered, but before it is advanced to the next athlete. Then, the current height and attempt would reference to the next height, while the position arrays still reference the last jump on the previous height, as intended.)
                                    this.roomAuxData[series.xSeries].currentHeight = this.currentHeight2;
                                    this.roomAuxData[series.xSeries].currentJumpoffHeightInd = this.currentJumpoffHeightInd2;
                                    this.roomAuxData[series.xSeries].attempt = this.attempt2;
                                    this.roomAuxData[series.xSeries].attemptNext = this.attemptNext2;

                                    // send the changed data to the server
                                    rCTrack.room.updateAuxDataInit(this.roomAuxData);
                                }
                                this.position = position;
                                this.positionNext = positionNext;
                            }

                            
                        } else if (this.mode==2){
                            // in jumpoff mode.

                            // Important: Regarding the position and positionNext arrays, the whole jumpoff is handled as "one height", i.e. the positions array is reduced when somebody did his jump. Instead, the positionNext array gets modified. (In other words: the different jumpoff heights are equivalend to the attempts in the regular competition.)

                            // a new jumpoff height is requried when there is no jumpoff height with jumpoffOrder==nextJumpoffHeightInd
                            this.jumpoffHeightRequired = false; // needed such that adding the next jumpoff height in the heights-menu works as well 
                            if (series.heights.findIndex(h=>h.jumpoffOrder==nextJumpoffHeightInd)==-1){
                                this.jumpoffHeightRequired = true;

                                // suggest the next height for the jumpoff
                                // check whether the new height already exists or let the user define the next jumpoff height!
                                let lastJumpoffIndex = 0;
                                let lastJumpoffHeight = 0;
                                for(let i=0;i<series.heights.length;i++){
                                    let el = series.heights[i];
                                    if (lastJumpoffIndex<el.jumpoffOrder){
                                        lastJumpoffHeight = el.height;
                                        lastJumpoffIndex = el.jumpoffOrder;
                                    }
                                }
                                
                                // create the new height
                                let val = 0; 
                                if (nextJumpoffHeightInd==1){
                                    // the first jumpoffHeight if the first height after the height where all jumpoff-paritcipants have succeeded

                                    // find the smallest height after the maxlastValidHeight
                                    val = 10000;
                                    series.heights.forEach((el,ind)=>{
                                        if (el.height>this.maxLastValidHeight && el.height<val){
                                            val = el.height;
                                        }
                                    })

                                } else {
                                    if (this.bestAtEachJumpoffHeight[this.bestAtEachJumpoffHeight.length-1]){
                                        // TODO: get the jumpoffHeightVariation via baseDiscipline
                                        // increase the last jumpoffHeight by this.jumpoffHeightVariation (i.e. 2cm for HJ and 5cm fo PV)
                                        val = lastJumpoffHeight + this.disciplineConfiguration.jumpoffHeightVariation;
                                    }else {
                                        // decrease the last jumpoffHeight by this.jumpoffHeightVariation (i.e. 2cm for HJ and 5cm fo PV)
                                        val = lastJumpoffHeight - this.disciplineConfiguration.jumpoffHeightVariation;
                                    }
                                }
                                // predefine the next height and let the user confirm teh height
                                this.manualJumpoffHeight = val;
                                
                            }

                            // formerly, nextJumpoffHeight was really the next jumpoffHeight. However, it is used as the currentJumpoffHeight now.
                            this.currentJumpoffHeightInd2 = nextJumpoffHeightInd;
                            // try to take over the positions from the previous height. This only works, when there are the same or fewer athletes.

                            // get all athletes that are still in the jumpoff (including those that jumped already on the current height!), i.e. all athletes where jumpoffFailedAtI>currentJumpoffHeightInd
                            
                            let recreatePos = false;
                            let starts = []; // only used in case of additional athletes, which may only happen after changes in past results
                            Object.entries(this.tempRankingData).forEach(([xSeriesStart, el])=>{

                                if (el.jumpoffFailedAtI>this.currentJumpoffHeightInd2 && el.rank==1){//(el.jumpoffResults.length==nextJumpoffHeightInd || el.jumpoffResults[nextJumpoffHeightInd]==undefined){
                                    starts.push(series.seriesstartsresults.find(el=>el.xSeriesStart==xSeriesStart));
                                    if(this.position.indexOf(parseInt(xSeriesStart))==-1){
                                        // if would have to add, we will recreate the positions array  afterwards
                                        recreatePos = true;
                                    }
                                }
                            })

                            // work on local copies of position and positionNext and finally detect possible changes
                            let position = this.position.slice();
                            let positionNext = this.positionNext.slice();
                            if (recreatePos){
                                // sort the starts
                                starts.sort((a,b)=>{
                                    return a.position-b.position;
                                })

                                // derive the position array
                                position = []; 
                                starts.forEach(el=>position.push(el.xSeriesStart));

                                /* positionNext = Array(position.length);
                                for (let i=0;i<positionNext.length;i++){
                                    positionNext[i] = i;
                                } */

                            } else {
                                // delete positions that do not start on this height:
                                let i = position.length;
                                while (i--){
                                    let xSeriesStart = position[i];
                                    if (this.tempRankingData[xSeriesStart].jumpoffFailedAtI<=this.currentJumpoffHeightInd2){//(this.tempRankingData[xSeriesStart].jumpoffResults.length != nextJumpoffHeightInd && this.tempRankingData[xSeriesStart].jumpoffResults[nextJumpoffHeightInd]!=undefined){
                                        position.splice(i,1);
                                    }
                                }
                            }

                            // OLD (pre 2022-03 = pre position/positionNext work as they should and non-autoAdvance works):
                            //if ((!this.readOnly) || positionNext.length==0) {
                            // NEW: 
                            if (true){
                                // define the order of athletes on the current height (positionNext)
                                // loop over the position array and check which athletes will still jump on the current height
                                positionNext = [];
                                for (let i=0; i<position.length; i++){
                                    let xSeriesStart = position[i];
                                    if(this.tempRankingData[xSeriesStart].jumpoffResults[this.currentJumpoffHeightInd2-1]==undefined){
                                        positionNext.push(i);
                                    }
                                }
                            }

                            if (this.readOnly){
                                // we actually do not use the position and positionNext data that we just have created, but we use the data that was given via the aux data. But we compare the length of the array in order to detect problems (which should never happen.)
                                if (position.length != this.roomAuxData[series.xSeries].position.length || positionNext.length != this.roomAuxData[series.xSeries].positionNext.length){
                                    console.log('Note: the number of athletes jumping on the current height was calculated differently by this browser than given by the data from the server. This may regulary hapen when the result has already arrived on reading clients, but not the new aus data. If this happens in other constellations, please report the constellation, where this happened, to the developers.')
                                }
                                this.positionNext = this.roomAuxData[series.xSeries].positionNext.slice(); // we use slice to create a copy!
                                this.position = this.roomAuxData[series.xSeries].position;

                                // should not be needed anymore
                                /*this.currentHeight2 = this.roomAuxData[series.xSeries].currentHeight;
                                this.currentJumpoffHeightInd2 = this.roomAuxData[series.xSeries].currentJumpoffHeightInd;
                                this.attempt = this.roomAuxData[series.xSeries].attempt;
                                this.attemptNext2 = this.roomAuxData[series.xSeries].attemptNext;*/

                            } else {
                                // writing client. Set position and positionNext. If they have changed, send the changes to the server.
                                if (JSON.stringify(this.position) != JSON.stringify(position) || JSON.stringify(this.positionNext) != JSON.stringify(positionNext) || this.roomAuxData[series.xSeries].currentHeight != this.currentHeight2 || this.roomAuxData[series.xSeries].currentJumpoffHeightInd != this.currentJumpoffHeightInd2 || this.roomAuxData[series.xSeries].attempt != this.attempt2 || this.roomAuxData[series.xSeries].attemptNext != this.attemptNext2) {
                                    this.autoManageAuxData(false);
                                    this.roomAuxData[series.xSeries].positionNext = positionNext;
                                    this.roomAuxData[series.xSeries].position = position;

                                    // additionally propagate the following properties to all clients (this is especially needed when the site is reloaded after the result is entered, but before it is advanced to the next athlete. Then, the current height and attempt would reference to the next height, while the position arrays still reference the last jump on the previous height, as intended.)
                                    this.roomAuxData[series.xSeries].currentHeight = this.currentHeight2;
                                    this.roomAuxData[series.xSeries].currentJumpoffHeightInd = this.currentJumpoffHeightInd2;
                                    this.roomAuxData[series.xSeries].attempt = this.attempt2;
                                    this.roomAuxData[series.xSeries].attemptNext = this.attemptNext2;

                                    // send the changed data to the server
                                    rCTrack.room.updateAuxDataInit(this.roomAuxData);
                                }
                                this.position = position;
                                this.positionNext = positionNext;
                            }
                        }


                        // make sure the ordering is updated (needed at least when the ordering is set to ranking)
                        this.fakeProperty++;

                    } else {
                        // show: not all athletes have a startheight
                        this.mode = 0;
                        this.position = [];
                        this.positionNext = [];
                    }

                },
                

                saveCurrentResChange(start){
                    /*let el = document.getElementById('resChange' + this.currentResultChange.xResult);
                    //let el = document.getElementById('resChange');
                    if (el==undefined){
                        alert('ERROR: cound not find the html-element of the result change. Should actually never happen. ');
                        return;
                    }*/

                    // if the string is empty, delete the result completely, otherwise, just alter it
                    if (this.currentResultString==''){
                        
                        rCTrack.room.deleteResultInit(this.currentResultChange, start)


                    }else if (this.currentResultString != this.currentResultStringCopy){

                        // get the height element to find out whether it is a jumpoff-height
                        let hEl = this.sortedHeights.find((el)=>{return el.xHeight==this.currentResultChange.xHeight})
                        if (!hEl){
                            alert('ERROR: could not find the height corresponding to the ')
                        }

                        let raw = this.strToResult(this.currentResultString, false, hEl.jumpoffOrder>0)

                        if (raw){
                            // transfer the changes to the actual result
                            this.currentResultChange.resultsHighPassed = raw.resultsHighPassed;
                            this.currentResultChange.resultsHighValid = raw.resultsHighValid;
                            this.currentResultChange.resultsHighFailedAttempts= raw.resultsHighFailedAttempts;

                            rCTrack.room.updateResultInit(this.currentResultChange, start)

                        }else{
                            alert("<%= __('The entered result is invalid. The previous value is restored.') %>")
                        }
                    }
                    // leave the result change mode:
                    this.currentResultChange = {};
                },

                addResultBlur(start, $event){
                    if (this.resultKeyPressed!=27){
                        this.addResult(start);
                    }
                    this.resultKeyPressed = -1;
                },
                addResult(start){

                    // add a result 
                    let valEl = document.getElementById('newResultValue' + start.xSeriesStart);
                    let heightEl = document.getElementById('newResultHeight' + start.xSeriesStart);

                    if (valEl.value!=''){
                        // first try to parse the entered result string
                        let resParsed = this.strToResult(valEl.value);
                        if (!resParsed){
                            // TODO: what shall be reverted
                            alert("<%= __('The entered result is invalid. Saving is aborted.') %>")
                            return;
                        }

                        // check that the result is also reasonable together with the previous results:
                        // - not more than 2 failed attempts in a row
                        // - athlete was not finished before already
                        // - not nothing
                        if (this.tempRankingData[start.xSeriesStart].finished ){
                            alert("ERROR: the athlete is already finished! Actually you should not even be able to enter a result.");
                            valEl.value = '';
                            return;
                        }

                        if (this.tempRankingData.failedAttemptsSinceLastValid + resParsed.resultsHighFailedAttempts + resParsed.resultsHighPassed + resParsed.resultsHighValid>3){
                            // TODO: 
                            alert("<%= __('The entered result is invalid, as the number of failed attempts since the last valid jump is >3. Saving is aborted.') %>")
                            valEl.value = '';
                            return;
                        }
                        if (resParsed.resultsHighFailedAttempts + resParsed.resultsHighPassed + resParsed.resultsHighValid==0){
                            // TODO: 
                            alert("<%= __('The entered result is invalid, as neither passed, nor valid nor a failed attempt was entered. Saving is aborted.') %>")
                            valEl.value = '';
                            return;
                        }

                        // get the xHeight for the selected height (if it exists)
                        let hEl = this.sortedHeights.find(el=>el.height == heightEl.value && el.jumpoffOrder==0)
                        if (!hEl){
                            this.addHeight(heightEl.value)
                            hEl = this.sortedHeights.find(el=>el.height == heightEl.value && el.jumpoffOrder==0)
                        }
                        let res = {
                            xResult: start.xSeriesStart,
                            xHeight: hEl.xHeight,
                            resultsHighFailedAttempts: resParsed.resultsHighFailedAttempts, // how many fails on this hight
                            resultsHighValid: resParsed.resultsHighValid, 
                            resultsHighPassed: resParsed.resultsHighPassed // verzichtet (-) 
                        };
                        start.resultshigh.push(res)

                        // send the change to the server
                        rCTrack.room.addResultInit(res, start);


                        // reset the field 
                        valEl.value = '';
                        // define the new focus:
                        if (this.tempRankingData[start.xSeriesStart].finished){
                            // focus the next athletes field, where the athletes results
                            // i= index of the current athlete
                            let i = this.sortedStarts1.findIndex(el=>start.xSeriesStart==el.xSeriesStart);
                            for (let j=i+1;j<this.sortedStarts1.length;j++){
                                // check if the athlete is not finished yet
                                if (!this.tempRankingData[this.sortedStarts1[j].xSeriesStart].finished){
                                    document.getElementById('newResultValue'+this.sortedStarts1[j].xSeriesStart).focus();
                                    break;
                                }
                            }
                        }else{
                            // focus the same element again
                            valEl.focus();
                        }
                    }



                // is the height automatically removed from the heights options dropdown? Otherwise make Vue reload in some way.

                },
                changeResult(res){
                    this.currentResultChange=res;

                    // create a copy of the current result-string. If we are not doing it this way, the value of the html-element will instantly be changed back to the original value, before blur actually hits and we can store the changed result. Additionally, it allows not to raise an update event when there was no change.
                    let resStr = this.resultToStr(res);
                    this.currentResultString = resStr;
                    this.currentResultStringCopy = resStr;

                    // set the focus: problem: when the element is still hidden, it cannot get the focus. And Vue will change the hidden status with a slight delay (either just asynchronous or indeed with a delay), thus we also have to implement some delay here:
                    setTimeout(()=>{document.getElementById('resChange' + res.xResult).focus();}, 1) // time in ms (1 ms so far seems to be enough, 3-2020)
                    //document.getElementById('resChange' + res.xResult).focus();
                    //document.getElementById('resChange').focus();
                },
                sortedResults(results){
                    // sort the results by height /to make it look nice

                    let sortingFailed = false;
                    // create an array copy, in order not to sort the original array
                    let resCopy = [...results].sort((resA,resB)=>{
                        // get the height for both results
                        let hA = this.sortedHeights.find(h=>h.xHeight==resA.xHeight);
                        let hB = this.sortedHeights.find(h=>h.xHeight==resB.xHeight);
                        if (hA==undefined || hB==undefined){
                            logger.log(20, `Could not sort the result-array. Returning the unsorted array.`);
                            sortingFailed = true;
                            return 0;
                        } else {
                            return hA.height-hB.height;
                        }
                    })
                    if (sortingFailed){
                        return results;
                    } else {
                        return resCopy;
                    }
                },
                seriesStatusChanged(){

                    // send the change to the server
                    // TODO: changed call now!!!
                    //rCTrack.room.updateSeriesInit(this.series[this.selectedSeries]);
                },
                

                fitName(elementId, startgroup, pretext=""){

                    // in some cases, it seems that positionNext.length>1 is not false yet, but nextAthleteStart is already undefined; in that case just return ''
                    /*if (!startgroup){
                        return '';
                    }*/

                    // try to fit firstname and name in a html element
                    // returns the best possible name
                    let el = document.getElementById(elementId);

                    // if the mode was just changed from 0 to 1, the element might not be shown yet. In that case, simply show the last name 
                    if (!el){
                        return startgroup.athleteName;
                    }

                    // store the overflow-style, then set it to hidden
                    let overflowBefore = el.style.overflow;
                    let innerTextBefore = el.innerText;
                    if ( !overflowBefore || overflowBefore === "visible" ){
                        el.style.overflow = "hidden";
                    }

                    // first try firstname / lastname
                    el.innerText = `${pretext}${startgroup.athleteForename} ${startgroup.athleteName}`;
                    if (el.clientWidth >= el.scrollWidth){
                        el.style.overflow = overflowBefore;
                        //el.innerText = innerTextBefore;
                        return el.innerText;
                    }

                    // fn. / lastname
                    el.innerText = `${pretext}${startgroup.athleteForename[0]}. ${startgroup.athleteName}`;
                    if (el.clientWidth >= el.scrollWidth){
                        el.style.overflow = overflowBefore;
                        //el.innerText = innerTextBefore;
                        return el.innerText;
                    }

                    el.style.overflow = overflowBefore;
                    //el.innerText = innerTextBefore;

                    // if both did nto fit, return just the lastname
                    return `${pretext}${startgroup.athleteName}`
                },
                rankLocalizer(rank, lang='en'){
                    // return the rank as a localized string, e.g. 
                    // en: 1st, 2nd, 3rd, 4th, ...
                    // de: 1., 2., 3., ...
                    if (lang=='de'){
                        return `${rank}.`
                    }else {
                        // english is the default
                        if (rank==1){
                            return '1st';
                        }else if (rank==2){
                            return '2nd';
                        } else if (rank==3){
                            return '3rd';
                        } else {
                            return `${rank}th`;
                        }
                    }
                },
                getLastResults(numRes=2){
                    // get the specified number of results 
                },
                saveDateUtc(series, evt){
                    series.datetime = new Date(evt.srcElement.value).toISOString();
                },
                formatInputDate(date){
                    // date can be of type date or a datestring
                    // create a string that javascript accepts for input.value (unfortunately there is no automatic translation between javascript date and the format that input accepts...!)
                    let s = "";
                    let d = new Date(date); // doesnt change anything is date is already a date
                    s += d.getFullYear();
                    s += "-" + (d.getMonth()+1).toString().padStart(2,0);
                    s += "-" + d.getDate().toString().padStart(2,0);
                    s += "T" + d.getHours().toString().padStart(2,0);
                    s += ":" + d.getMinutes().toString().padStart(2,0);
                    return s;
                },
            },
            watch:{
                mode: function(newMode,oldMode){ 
                    if (newMode>0 && oldMode==0){
                        this.sortValue1 = 2;
                        this.sortValue2 = 2;
                    } else if(newMode==0 && oldMode>0){
                        this.sortValue1 = 1;
                        this.sortValue2 = 1;
                    }
                },
                series: {
                    handler:function(seriesNew, seriesOld){
                        // if the series-data is handed over initially, try to get the selected xSeries from the url get parameter.
                        if (seriesOld.length == 0){

                            // get the selected series from the GET parameter
                            let u = new URL(window.location.href);
                            if (u.searchParams.has('xSeries')){
                                let xSeries = Number(u.searchParams.get('xSeries'))

                                // get the index of the respective series
                                let ind = this.series.findIndex(s=>s.xSeries==xSeries);
                                if (ind>=0){
                                    this.selectedSeries = ind;
                                }
                            }

                        }

                        if (seriesOld.length == 0){
                            // no series before; this of course also occurs when the series are initially defined, but this should still be fine
                            this.showAuto();
                        }

                    },
                    deep:true, // this will increase the computational load, I know... but I see no other solution
                },
                // TODO: to be adapted for the startTime
                'roomAuxDataSelected.periodStartTime': function(newTime, oldTime){
                    //this.timeManager();
                },

                selectedXSeries: function(newXSeries, oldXSeries){
                    //this.timeManager();
                },
                contestWatching: {
                    // we cannot directly watch contest, because if the changes were within the object, the oldContestObj would reference the same as newContestObj. However, the contestWatching property is always a new copy and thus new and old should be correct
                    // (The alternative would be to have watchers for each property that might change, e.g. 'contest.status', ...)

                    // this is how we watch changes not only of the property "contest", but of all the properties within it:
                    deep:true,
                    handler: function(newContestObj, oldContestObj){
                        // harmonized over all changes on the contest properties
                        // TODO: problem: if the full contest data is changed (e.g. after the room gets the first data or after full reload), this watch event is raised as well, which is problematic...
                        // send the request to the server. On positive return, nothing will be done. If negative, all changes from that point on will have to be reverted.
                        if (this.propagateChange){
                            rCTrack.room.updateContest2Init(newContestObj, oldContestObj);
                            this.propagateChange = false;
                        }
                    }
                },
            },
            computed:{
                
                /* !!! properties for SERIES CREATION and COMPETITION !!! */

                maxDateTime: function(){
                    return `${this.meeting.dateTo.slice(0,10)}T23:59`;
                },
                minDateTime: function(){
                    return `${this.meeting.dateFrom.slice(0,10)}T00:00`;
                },

                defaultSite: function(){
                    return this.sites.find(s=>s.type==0);
                },
                defaultSiteConf: function(){
                    if (this.defaultSite){
                        try{
                            const conf = JSON.parse(this.defaultSite.conf);
                            return conf;
                        }catch(ex){
                            logger.log(10, 'The site configuration object is not a valid JSON.')
                        }
                    }
                },
                trackSites: function(){
                    return this.sites.filter(s=>s.type==0);
                },
                
                roomAuxDataSelected: function(){
                    return this.roomAuxData[this.selectedXSeries];
                },

                urlFieldMonitor: function(){
                    // the url of the field monitor for the selected series
                    return window.location.origin + '/' + getLanguage() + "/" + getMeetingShortname() + `/trackBoard?xContest=${findGetParameter('xContest')}&xSeries=${this.selectedXSeries}`;
                },

                contestWatching: function(){
                    // create a copy of the contest object to make sure that newContestObj and oldContestObj in the contest(Watching)-watcher are truly the old and new object, and not the same. 
                    return JSON.parse(JSON.stringify(this.contest));
                },
                conf: function(){
                    return this.parseConf(this.contest.conf);
                },
                filters: function(){
                    // create a custom filter for everything that filters by name, first name and bib at the same time. (club would be nice, but is not possible with the builtin-filters, since the club would have to be part of the object structure, but only the xClub is, but not the clubs and its name.) 
                    
                    // split the input string by whitespace
                    let filterWords = this.filterAthletes.split(" ");

                    // every word may be part of every of the four columns
                    let filter = {};
                    let i=1;
                    for (let filterWord of filterWords){
                        filter["filter" + i] = {keys:['athleteName', 'athleteForename', 'bib', 'sex, clubName', 'country'], value:filterWord} //
                        i += 1;
                    }
                    return filter;

                },

                seriesAsStartgroups: function(){
                    // "copy" the series and its seriesstartsresults (as startgroup)
                    let seriesAsStartgroups = [];
                    for (let i=0;i<this.series.length; i++){

                        let series = this.series[i];
                        
                        // add the other data of the series, for informational purposes only! A change to those is useless.
                        // do NOT use copyObject here, since it would destroy the reactivity. Use propertyTransfer instead.
                        let seriesCopy = {};
                        propertyTransfer(this.series[i], seriesCopy); // seriesstartsresults is actually already added here, but will be deleted again:
                        

                        // get the startgroup for every seriesstartsresult
                        let SSRs = [];
                        series.seriesstartsresults.forEach(ssr=>{
                            // create a copy of the ssr
                            let ssrCopy = copyObject(ssr);
                            // find the startgroup for the respective seriesstartsresult and add it to the list
                            let startgroup = this.startgroups.find(SG=>SG.xStartgroup == ssr.xStartgroup)
                            if (startgroup){
                                ssrCopy.startsingroup = startgroup;
                                ssrCopy.ssrOriginal = ssr;
                            } else {
                                console.log('Error: could not find xStartgroup of an assigned athlete. This data inconsistency should not occure. Try to fully reload the auxilary data.')
                            }

                            // reference the original (!) 'parent'; avoids that xSeries has to be defined to be used in "changePosition"
                            ssrCopy.series = seriesCopy;
                            ssrCopy.seriesOriginal = series;

                            SSRs.push(ssrCopy)
                        })
                        
                        seriesCopy.SSRs= SSRs;
                        seriesCopy.seriesOriginal = series;
                        seriesAsStartgroups.push(seriesCopy);
                    }

                    // sort the series
                    seriesAsStartgroups.sort((a,b)=>{
                        return a.number-b.number;
                    })
                    // sort the seriesstartsresults
                    seriesAsStartgroups.forEach(series=>{
                        series.SSRs.sort((a,b)=>{
                            return a.position-b.position;
                        })
                    })
                    // add posInLane and lane (to make updateEmptyLane to work)
                    seriesAsStartgroups.forEach(series=>{
                        let lastLane = 0;
                        let lastPosInLane = 0;
                        series.SSRs.forEach(SSR=>{
                            SSR.lane = SSR.startConf;
                            if (SSR.lane == lastLane){
                                SSR.posInLane = ++lastPosInLane;
                            } else {
                                SSR.posInLane = 1
                            }
                            lastLane = SSR.lane;
                        })
                    })

                    this.updateEmptyInitLanes(seriesAsStartgroups);

                    return seriesAsStartgroups;
                },


                /* !!! properties for SERIES CREATION only !!! */

                // to move around the atheletes e.g. from non-assigned to series we have to work on the startgroups. Create an array with all unassigned startgroups (unassignedAthletes) and one for every series with the same info (seriesAsStartgroups). 

                unassignedAthletes: function(){
                    // create an array of all unassigned athletes, including those with present=false
                    // first copy the full list of startsingroups
                    let unassignedAthletes = this.startgroups.slice(); //map(el=>el.xStartgroup);

                    // remove all entries which are references in a series
                    for (let i=0; i<this.series.length; i++){
                        this.series[i].seriesstartsresults.forEach((el, seriesIndex)=>{
                            let ind = unassignedAthletes.findIndex(el2=> el.xStartgroup==el2.xStartgroup);
                            if (ind<0){
                                console.log('Error: could not find xStartgroup of an assigned athlete. This data inconsistency should not occure. Try to fully reload the auxilary data.')
                            } else {
                                // remove the startgroups
                                unassignedAthletes.splice(ind,1);
                            }
                        })
                    }
                    return unassignedAthletes;
                },

                seriesAssignments: function(){
                    // filter all series assignments to show only track (ytype==3) assignements
                    return this.seriesAssignmentsAll.filter(sa=>sa.baseDisciplineTypes.indexOf(3)>=0);
                },
                
                seriesAssignmentOverlay: function(){
                    // show the configuration of the currently selected series assignment algorithm
                    return this.seriesAssignments[this.selectedSeriesAssignment].overlayName;
                },

                /* !!! properties for COMPETITION only !!! */

                selectedXSeries: function(){
                    if (this.series.length>0){
                        return this.series[this.selectedSeries].xSeries;
                    }
                    return undefined;
                },
                auxData: function(){
                    // change the xStartgroup array to an object with objects, where xStartgroup is the key
                    let auxData = {};
                    auxData.xStartgroup = {};
                    this.startgroups.forEach(el=>{
                        auxData.xStartgroup[el.xStartgroup]=el;
                    })
                    return auxData;
                },
                sortedStarts1: function(){
                    let i = this.fakeProperty; // just to make sure sortedStarts gets updated on rank changes
                    // TODO
                    //return this.series[this.selectedSeries].seriesstartsresults;

                    // we cannot just sort the seriesstartsresults-array as this would also change the order at several different places (especially the algorithm for 'the next athlete sequence' might not work anymore!)                            

                    // create an array with all array-indexes (0 to length-1) of the seriesstartsresults array; (the initialized elements are empty first and map only uses non-empty fields. Thus we first fill with undefined and then create in indices)
                    let order = Array(this.series[this.selectedSeries].seriesstartsresults.length).fill(undefined).map(function (x, i) { return i; })

                    let compareFn = (a,b)=>{a-b} // fallback
                    if (this.sortValue1 == 1){
                        // default sequence
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            return A.position - B.position
                        }
                    } else if (this.sortValue1 == 2){
                        // sort by rank
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let rA = this.tempRankingData[A.xSeriesStart].rank;
                            let rB = this.tempRankingData[B.xSeriesStart].rank;
                            if (rA==0 && rB==0){
                                // both have no rank yet: sort by default order
                                return A.position - B.position;
                            } else if (rA==0){
                                // A must be lower than B
                                return 1;
                            } else if (rB==0){
                                // B must be lower than A
                                return -1;
                            } else {
                                // sort by rank
                                return rA-rB;
                            }
                        }
                    } else if (this.sortValue1 == 3){
                        // sort by name
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];

                            return (auxA.athleteName + auxA.athleteForename).localeCompare(auxB.athleteName + auxB.athleteForename);
                        }
                    } else if (this.sortValue1 == 4){
                        // sort by bib
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];
                            
                            return auxA.bib - auxB.bib;
                        }
                    }
                    order.sort(compareFn);

                    return order;

                },
                sortedStarts2: function(){
                    let i = this.fakeProperty; // just to make sure sortedStarts gets updated on rank changes

                    // we cannot just sort the seriesstartsresults-array as this would also change the order at several different places (especially the algorithm for 'the next athlete sequence' might not work anymore!)                            

                    // create an array with all array-indexes (0 to length-1) of the seriesstartsresults array; (the initialized elements are empty first and map only uses non-empty fields. Thus we first fill with undefined and then create in indices)
                    let order = Array(this.series[this.selectedSeries].seriesstartsresults.length).fill(undefined).map(function (x, i) { return i; })

                    let compareFn = (a,b)=>{a-b} // fallback
                    if (this.sortValue2 == 1){
                        // default sequence
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            return A.position - B.position
                        }
                    } else if (this.sortValue2 == 2){
                        // sort by rank
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let rA = this.tempRankingData[A.xSeriesStart].rank;
                            let rB = this.tempRankingData[B.xSeriesStart].rank;
                            if (rA==0 && rB==0){
                                // both have no rank yet: sort by default order
                                return A.position - B.position;
                            } else if (rA==0){
                                // A must be lower than B
                                return 1;
                            } else if (rB==0){
                                // B must be lower than A
                                return -1;
                            } else {
                                // sort by rank
                                return rA-rB;
                            }
                        }
                    } else if (this.sortValue2 == 3){
                        // sort by name
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];

                            return (auxA.athleteName + auxA.athleteForename).localeCompare(auxB.athleteName + auxB.athleteForename);
                        }
                    } else if (this.sortValue2 == 4){
                        // sort by bib
                        compareFn = (a, b)=>{
                            let A = this.series[this.selectedSeries].seriesstartsresults[a];
                            let B = this.series[this.selectedSeries].seriesstartsresults[b];
                            let auxA = this.auxData.xStartgroup[A.xStartgroup];
                            let auxB = this.auxData.xStartgroup[B.xStartgroup];
                            
                            return auxA.bib - auxB.bib;
                        }
                    }
                    order.sort(compareFn);

                    return order;

                },
                disciplineConfiguration: function(){
                    // get the first discipline with matching baseDiscipline and parse its configuration
                    let d = this.disciplines.find(d=>d.xBaseDiscipline==this.contest.xBaseDiscipline);
                    if (!d){
                        return {startInLanes:true, groupSize:1, distance: 0, wind:true, straight:true};
                    } else {
                        let o = JSON.parse(d.baseConfiguration);
                        // avoid problems when the definition was not right in the DB
                        o.startInLanes = o.startInLanes ?? true;
                        o.groupSize = o.groupSize ?? 1;
                        o.distance = o.distance ?? 0;
                        o.wind = o.wind ?? true;
                        o.straight = o.straight ?? true;
                        o.heatInterval = o.heatInterval ?? 60; // 60 s
                        return o;
                    }
                },
                discipline: function(){
                    return this.disciplines.find(d=>d.xBaseDiscipline==this.contest.xBaseDiscipline);
                }, 

            },
            beforeMount(){
                // work on data before it is showed the first time
                // moved to when the data arrives
/*                this.createAllHeights();
                this.evaluateHeightDeletable();*/
            },
            mounted:function(){
                // initialize all series assignments
                this.seriesAssignments.forEach((SA)=>{
                    SA.initFunc.bind(this)();
                })

                // regularly update the shown time
                this.timeInterval = setInterval(()=>{
                    const t = new Date();
                    this.timeHours = t.getHours().toString().padStart(2,0);
                    this.timeSeconds = t.getSeconds().toString().padStart(2,0);
                    this.timeMinutes = t.getMinutes().toString().padStart(2,0);
                    this.timeOdd = t.getMilliseconds() < 500;
                }, 100); // 10 times per second
                
            },
            components:{
                'draggable': vuedraggable,
                'v-table':VTable,
                'v-th': VTh,
                'v-tr':VTr,
            },
        }

        vueSeriesAdminTrack = Vue.createApp(vueAppConfig).mount('#vueSeriesAdminTrack')

        // load the room:
        let ms = getMeetingShortname();

        // get the GET-parameter xContest (null if not found)
        let xContest = findGetParameter('xContest')

        if (xContest!=null && !isNaN(xContest)){
            xContest = Number(xContest)
            // start the roomClientView
            rCTrack = new vuContestTrack(vueSeriesAdminTrack, ms, xContest, writing);
        } else {
            // eventually show a message that there is no  
        }

        rSites = new vuSites(vueSeriesAdminTrack, ms);
        rSiteTest = new vuSiteTest(vueSeriesAdminTrack, ms); // TODO: remove; only for testing

    }

</script>
<script type="module">
    // MODULE stuff for printing
    // TODO: modify for track disciplines
    import {dContestSheet, dSeriesSheetHigh, dPersonContestSheet, dHeaderFooter, printer, pPersonContestSheetHigh, pSeriesContestSheetHigh, pContestSheetHigh, pHeaderFooter} from "/static/printDocumentStructure.js";


    /**
     * Create the data structure for printing
     * @param {object} contest The contest object of the room
     * @param {array} series Array storing all series 
     * @param {array} startgroups Array with all additional information (name, firstname, event, etc) for each startgroup=seriesStartResult
     * @param {integer} xSeries The series to show. Null means that all series are printed. default=null 
     * @returns dContest instance with all series/persons as childs
     */
    function createDataStructure(contest, series, startgroups, categories, heights, disciplines, relatedGroups, xSeries=null){

        // get the name of the discipline
        let discName = disciplines.find(d=>d.xBaseDiscipline==contest.xBaseDiscipline)?.name 

        let cContest =  new dContestSheet(contest.datetimeAppeal, contest.datetimeCall, contest.datetimeStart, contest.status, contest.conf, discName, relatedGroups, categories);

        // create each series-container and add it to the contest
        for (let s of series){
            if (xSeries==null || s.xSeries == xSeries){

                let cSeries = new dSeriesSheetHigh(s.xSeries, s.status, s.number, s.name, s.xSite, s.seriesstartsresults, heights);

                // add each person in this series. Get the necessary information from the startgroup
                for (let ssr of s.seriesstartsresults){
                    // try to find the startgroup corresponding to SSR
                    let startGroup = startgroups.find(sg=>sg.xStartgroup==ssr.xStartgroup)
                    if (startGroup){

                        // get the category name
                        let cat = categories.find(c=> c.xCategory==startGroup.xCategory);
                        let catName;
                        if (cat){
                            catName = cat.shortname;
                        }

                        let p = new dPersonContestSheet(startGroup.athleteName, startGroup.athleteForename, startGroup.bib, startGroup.birthdate, startGroup.country, startGroup.regionShortname, startGroup.clubName, startGroup.eventGroupName, startGroup.xDiscipline, ssr.position, catName, heights, ssr.startConf)

                        cSeries.children.push(p);
                    } else {
                        // TODO: replace by correct logging!
                        console.log(`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`)
                        throw {code:5, message:`Could not find the person for the seriesStart ${ssr.xSeriesStart}. Printing not possible.`}
                    }
                }

                // sort the persons by their position
                cSeries.sortChildren('position');

                cContest.addSeries(cSeries);
            }
        }
        cContest.sortSeries('number')
        return cContest
    }

    async function printContest(){

        // dynamically get the print configuration for the current language
        let lang = getLanguage();
        const {confPrint} = await import(`/${lang}/confPrint`);
        const conf = confPrint;

        let cContest = createDataStructure(vueSeriesAdminTrack.contest, vueSeriesAdminTrack.series, vueSeriesAdminTrack.startgroups, vueSeriesAdminTrack.categories, vueSeriesAdminTrack.allHeights, vueSeriesAdminTrack.disciplines, vueSeriesAdminTrack.relatedGroups,null);
        let hf = new dHeaderFooter([cContest], vueSeriesAdminTrack.meeting);

        // define the translations from dataContainers to prtContainers
        const dataToPrint = {
            dHeaderFooter: pHeaderFooter,
            dContestSheet: pContestSheetHigh,
            dSeriesSheetHigh: pSeriesContestSheetHigh,
            dPersonContestSheet: pPersonContestSheetHigh
        }

        let p = await printer.create([hf], dataToPrint, conf, true)
        //let p = new printer([hf], true)

        // add the page number in a rather strange way, by directly replacing a placeholder in the content stream as a hex word. Please note that with that approach the text will not be aligned correctly when the alignment is not left, since the original alignment done in some function was based on the placeholder and not the replaced string.
        // To increase speed, we could not try to replace a part of a string (which requires searching all strings for the given needle), but instead simply replace a shole string, which only requires the comparison of full strings and a replacement whenever needed. 

        // encode the string to be replaced 
        /*let placeholder = p.fonts.Helvetica.encodeText('{The number of pages}')

        // encode replacement string 
        let replacer = p.fonts.Helvetica.encodeText('Page X of Y')

        for (let iO of p.doc.context.indirectObjects.values()){ // indirectObjects is a MAP
            // only further consider PDF content streams and Tj operators
            if (iO.constructor.name == 'PDFContentStream'){
                for (let oP of iO.operators){
                    if (oP.name==='Tj'){
                        // this is a text operator
                        // now search for the encoded text and replace it
                        // args of Tj have always only one element
                        oP.args[0].value = oP.args[0].value.replace(placeholder.value, replacer.value);
                    }
                }
            }
        }*/
        // Tested. Works. (But this is certainly not the best approach.)

        p.showNewTab()

        return p
    }

    // make sure the pritnContest function is visible/accessible to all other rooms.
    window.printContest = printContest;
</script>
<!-- up to here, content of techHighBase; all subsequent stuff (i.e. how the data is shown) is defined separately. -->
<%- content %>